!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!                                                                                                                            !!!!
!!!!    ParaMonte: Parallel Monte Carlo and Machine Learning Library.                                                           !!!!
!!!!                                                                                                                            !!!!
!!!!    Copyright (C) 2012-present, The Computational Data Science Lab                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!    This file is part of the ParaMonte library.                                                                             !!!!
!!!!                                                                                                                            !!!!
!!!!    LICENSE                                                                                                                 !!!!
!!!!                                                                                                                            !!!!
!!!!       https://github.com/cdslaborg/paramonte/blob/main/LICENSE.md                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!>  \brief
!>  This module contains classes and procedures for generating random matrices distributed
!>  on the space of positive definite matrices, such that their determinants is uniformly or power-law distributed.
!>
!>  \details
!>  The procedures of this module generate random covariance matrices based on the following approaches:<br>
!>  <ol>
!>      <li>    The first class of methods is based on the observation that every real positive definite matrix \f$M\f$ has a Cholesky factorization
!>              \f{equation}{
!>                  M = LL*
!>              \f}
!>              where \f$L\f$ is a uniquely defined lower triangular matrix with positive diagonal entries.<br>
!>              Therefore, \f$M\f$ can be constructed from a given random \f$L\f$.<br>
!>              The **Gram method** is fast, however, the resulting matrix \f$M\f$ does not possess any particular structure.<br>
!>      <li>    The second class of methods is based on a modified version of the Vine algorithm of *Lewandowski, Kurowicka, and Joe (2009),
!>              "Generating random correlation matrices based on vines and extended onion method"*.<br>
!>              The resulting matrices generated by procedures of this module are randomly distributed over the space of the correlation matrices such that,
!>              \f{equation}{
!>                  \pi(\left|\ms{rand}\right| ~\big|~ \eta) \propto \left|\ms{rand}\right|^{\eta} ~,
!>              \f}
!>              where,
!>              <ol>
!>                  <li>    \f$\left|\ms{rand}\right|\f$ represents the determinant of the generated matrix \f$\ms{rand}\f$, and
!>                  <li>    \f$\eta\f$ is an arbitrary scalar non-negative constant.
!>              </ol>
!>              Note that the definition of \f$\eta\f$ in this module corresponds to \f$\eta - 1\f$ in the proposed algorithm of Lewandowski et al. (2009).<br>
!>              Setting \f$\eta = 0.\f$ corresponds to a uniform distribution of the random matrices on the space of the correlation matrices.<br>
!>              The off-diagonal elements of the random correlation matrix follow the [Beta distribution](@ref pm_distBeta):
!>              \f{equation}{
!>                  \ms{rand}_{ij} \sim \mathcal{B}(\eta + \ms{ndim} / 2, \eta + \ms{ndim} / 2) ~,~ i \neq j ~,~ 1 \leq i, j \leq \ms{ndim} ~,
!>              \f}
!>              over the range \f$(-1, +1)\f$, where \f$\ms{ndim}\f$ represents the rank of the correlation matrix.<br>
!>              Larger values of \f$\eta\f$ lead to random correlation matrices with more homogeneous structure.<br>
!>              Smaller values of \f$\eta\f$ lead to random correlation matrices with more heterogeneous structure with strong correlations along some dimensions.<br>
!>              The resulting correlation matrix can be arbitrarily scaled along different dimensions to generate power-law randomly-distributed **covariance matrix**.<br>
!>  </ol>
!>
!>  \see
!>  [pm_distBeta](@ref pm_distBeta)<br>
!>
!>  \test
!>  [test_pm_distCov](@ref test_pm_distCov)<br>
!>
!>  \todo
!>  \pvhigh
!>  The output square matrices from the onion method are frequently non-positive-definite, particularly in higher dimensions.<br>
!>  A closer look into the root causes of this instability must be done.<br>
!>
!>  \final
!>
!>  \author
!>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

module pm_distCov

    use pm_distUnif, only: rngf_type, xoshiro256ssw_type
    use pm_kind, only: SK, IK, LK

    implicit none

    character(*, SK), parameter :: MODULE_NAME = "@pm_distCov"

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This the derived type whose instances imply the use of the Gram
    !>  algorithm for generating random covariance matrices.<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{gram_type}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: gram_type
    !>      type(gram_type), parameter :: gram
    !>
    !>      gram = gram_type()
    !>
    !>  \endcode
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{gram_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type gram_type
    end type gram_type

    !>  \brief
    !>  The scalar constant of type [gram_type](@ref pm_distCov::gram_type) implying the use of the Gram
    !>  algorithm for generating random covariance matrices.<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{gram}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: gram
    !>
    !>  \endcode
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{gram}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type(gram_type), parameter :: gram = gram_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: gram
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This the derived type whose instances imply the use of the Dvine
    !>  algorithm for generating random covariance matrices as described in algorithm of Lewandowski et al. (2009).<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{dvine_type}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: dvine_type
    !>      type(dvine_type), parameter :: dvine
    !>
    !>      dvine = dvine_type()
    !>
    !>  \endcode
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{dvine_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type dvine_type
    end type dvine_type

    !>  \brief
    !>  The scalar constant of type [dvine_type](@ref pm_distCov::dvine_type) implying the use of the Dvine
    !>  algorithm for generating random covariance matrices as described in algorithm of Lewandowski et al. (2009).<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{dvine}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: dvine
    !>
    !>  \endcode
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{dvine}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type(dvine_type), parameter :: dvine = dvine_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: dvine
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This the derived type whose instances imply the use of the Onion algorithm for generating
    !>  random covariance matrices as described in algorithm of Lewandowski et al. (2009).<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{onion_type}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: onion_type
    !>      type(onion_type), parameter :: onion
    !>
    !>      onion = onion_type()
    !>      print *, onion%info
    !>
    !>  \endcode
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{onion_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type onion_type
        integer(IK) :: info = 0_IK  !<  The scalar `integer` of default kind \IK, whose non-zero value indicates the Cholesky factorization failure within the Onion method.
    end type onion_type

    !>  \brief
    !>  The scalar module variable object of type [onion_type](@ref pm_distCov::onion_type) implying the use of the Onion
    !>  algorithm for generating random covariance matrices as described in algorithm of Lewandowski et al. (2009).<br>
    !>
    !>  \details
    !>  Unlike [dvine](@ref pm_distCov::dvine) which is a scalar `parameter`,
    !>  [onion](@ref pm_distCov::onion) is a **module variable**, whose presence is merely for convenience.<br>
    !>  As such, this variable's usage must be restricted to only experimental or serial applications, because **this object is not thread-safe**.<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>
    !>  \interface{onion}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: onion
    !>      print *, onion%info
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The use of module variable can become a thread safety problem in parallel shared memory applications.<br>
    !>  All it takes to resolve this thread safety is to not use this variable and declare a local object of type [onion_type](@ref pm_distCov::onion_type) instead.<br>
    !>
    !>  \note
    !>  See the documentation of [getCovRand](@ref pm_distCov::getCovRand) for example usage.<br>
    !>
    !>  \see
    !>  [gram](@ref pm_distCov::gram)<br>
    !>  [dvine](@ref pm_distCov::dvine)<br>
    !>  [onion](@ref pm_distCov::onion)<br>
    !>  [gram_type](@ref pm_distCov::gram_type)<br>
    !>  [dvine_type](@ref pm_distCov::dvine_type)<br>
    !>  [onion_type](@ref pm_distCov::onion_type)<br>
    !>  [getCovRand](@ref pm_distCov::getCovRand)<br>
    !>  [setCovRand](@ref pm_distCov::setCovRand)<br>
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)<br>
    !>
    !>  \final{onion}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    type(onion_type) :: onion = onion_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: onion
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return a random positive-definite (correlation or covariance) matrix using the Gram method.<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.<br>
    !>  See also [setCovRand](@ref pm_distCov::setCovRand) for generating random covariance matrices using the method of Dvine or Onion.<br>
    !>
    !>  \param[in]  mold        :   The input scalar of,
    !>                              <ol>
    !>                                  <li>    type `complex` of kind \CKALL,
    !>                                  <li>    type `real` of kind \RKALL,
    !>                              </ol>
    !>                              whose type and kind determines the type and kind of the output `rand`.<br>
    !>                              The value of `mold` is ignored entirely within the algorithm.<br>
    !>  \param[in]  ndim        :   The input positive scalar of type `integer` of default kind \IK,
    !>                              representing the rank of the matrix (the number of dimensions) of shape `(ndim, ndim)`.<br>
    !>                              (**optional**. It must be present **if and only if** the input `scale` argument is missing or is a scalar.)
    !>  \param[in]  scale       :   The input scalar or `contiguous` vector of size `ndim` of type `real` of the same kind as the output argument `rand`,
    !>                              representing the scale of the matrix (e.g., the standard deviation of a covariance matrix) along each dimension.<br>
    !>                              (**optional**. default = `1.`. It can be present **if and only if** it is a scalar or, it is a vector **and** the input argument `ndim` is missing.)
    !>
    !>  \return
    !>  `rand`                  :   The output matrix of shape `(1:ndim, 1:ndim)` of the same type and kind as the input argument `mold`,
    !>                              containing a random positive-definite matrix.<br>
    !>
    !>  \interface{getCovRand}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: getCovRand
    !>
    !>      rand(1:ndim, 1:ndim) = getCovRand(mold, scale(1:ndim))
    !>      rand(1:ndim, 1:ndim) = getCovRand(mold, ndim, scale = scale)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `all([0 < scale])` must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \note
    !>  Unlike the case for [setCovRand](@ref pm_distCov::setCovRand), when the input argument `scale` is missing,
    !>  the diagonal elements of the output correlation matrix are strictly enforced to `1`.<br>
    !>
    !>  \example{getCovRand}
    !>  \include{lineno} example/pm_distCov/getCovRand/main.F90
    !>  \compilef{getCovRand}
    !>  \output{getCovRand}
    !>  \include{lineno} example/pm_distCov/getCovRand/main.out.F90
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)
    !>
    !>  \final{getCovRand}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>
    interface getCovRand

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    impure module function getCovRandGRNGDS0_CK5(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_CK5
#endif
        use pm_kind, only: CKG => CK5
        integer(IK)             , intent(in)                    :: ndim
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , optional      :: scale
        complex(CKG)                                            :: rand(ndim, ndim)
    end function
#endif

#if CK4_ENABLED
    impure module function getCovRandGRNGDS0_CK4(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_CK4
#endif
        use pm_kind, only: CKG => CK4
        integer(IK)             , intent(in)                    :: ndim
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , optional      :: scale
        complex(CKG)                                            :: rand(ndim, ndim)
    end function
#endif

#if CK3_ENABLED
    impure module function getCovRandGRNGDS0_CK3(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_CK3
#endif
        use pm_kind, only: CKG => CK3
        integer(IK)             , intent(in)                    :: ndim
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , optional      :: scale
        complex(CKG)                                            :: rand(ndim, ndim)
    end function
#endif

#if CK2_ENABLED
    impure module function getCovRandGRNGDS0_CK2(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_CK2
#endif
        use pm_kind, only: CKG => CK2
        integer(IK)             , intent(in)                    :: ndim
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , optional      :: scale
        complex(CKG)                                            :: rand(ndim, ndim)
    end function
#endif

#if CK1_ENABLED
    impure module function getCovRandGRNGDS0_CK1(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_CK1
#endif
        use pm_kind, only: CKG => CK1
        integer(IK)             , intent(in)                    :: ndim
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , optional      :: scale
        complex(CKG)                                            :: rand(ndim, ndim)
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    impure module function getCovRandGRNGDS0_RK5(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        integer(IK)             , intent(in)                    :: ndim
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , optional      :: scale
        real(RKG)                                               :: rand(ndim, ndim)
    end function
#endif

#if RK4_ENABLED
    impure module function getCovRandGRNGDS0_RK4(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        integer(IK)             , intent(in)                    :: ndim
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , optional      :: scale
        real(RKG)                                               :: rand(ndim, ndim)
    end function
#endif

#if RK3_ENABLED
    impure module function getCovRandGRNGDS0_RK3(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        integer(IK)             , intent(in)                    :: ndim
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , optional      :: scale
        real(RKG)                                               :: rand(ndim, ndim)
    end function
#endif

#if RK2_ENABLED
    impure module function getCovRandGRNGDS0_RK2(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        integer(IK)             , intent(in)                    :: ndim
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , optional      :: scale
        real(RKG)                                               :: rand(ndim, ndim)
    end function
#endif

#if RK1_ENABLED
    impure module function getCovRandGRNGDS0_RK1(mold, ndim, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        integer(IK)             , intent(in)                    :: ndim
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , optional      :: scale
        real(RKG)                                               :: rand(ndim, ndim)
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    impure module function getCovRandGRNGDS1_CK5(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)                                            :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if CK4_ENABLED
    impure module function getCovRandGRNGDS1_CK4(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)                                            :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if CK3_ENABLED
    impure module function getCovRandGRNGDS1_CK3(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)                                            :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if CK2_ENABLED
    impure module function getCovRandGRNGDS1_CK2(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)                                            :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if CK1_ENABLED
    impure module function getCovRandGRNGDS1_CK1(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)            , intent(in)                    :: mold
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)                                            :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    impure module function getCovRandGRNGDS1_RK5(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)                                               :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if RK4_ENABLED
    impure module function getCovRandGRNGDS1_RK4(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)                                               :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if RK3_ENABLED
    impure module function getCovRandGRNGDS1_RK3(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)                                               :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if RK2_ENABLED
    impure module function getCovRandGRNGDS1_RK2(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)                                               :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

#if RK1_ENABLED
    impure module function getCovRandGRNGDS1_RK1(mold, scale) result(rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCovRandGRNGDS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)               , intent(in)                    :: mold
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)                                               :: rand(size(scale, 1, IK), size(scale, 1, IK))
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Return a random positive-definite power-law-distributed (correlation) matrix.<br>
    !>
    !>  \brief
    !>  See the documentation of [pm_distCov](@ref pm_distCov) for details.
    !>
    !>  \param[inout]   rng     :   The input/output scalar that can be an object of,
    !>                              <ol>
    !>                                  <li>    type [rngf_type](@ref pm_distUnif::rngf_type),
    !>                                          implying the use of intrinsic Fortran uniform RNG.<br>
    !>                                  <li>    type [xoshiro256ssw_type](@ref pm_distUnif::xoshiro256ssw_type),
    !>                                          implying the use of [xoshiro256**](https://prng.di.unimi.it/) uniform RNG.<br>
    !>                              </ol>
    !>  \param[out]     rand    :   The output matrix of shape `(1:ndim, 1:ndim)` of,<br>
    !>                              <ol>
    !>                                  <li>    type `complex` of kind \CKALL,
    !>                                  <li>    type `real` of kind \RKALL,
    !>                              </ol>
    !>                              containing a random (optionally power-law-distributed determinant) positive-definite matrix.<br>
    !>                              The output `rand` can of `complex` type **if and only if** the optional input argument `method` is missing.<br>
    !>  \param[inout]   method  :   The input/output scalar constant that can be one of the following:
    !>                              <ol>
    !>                                  <li>    The scalar input constant [dvine](@ref pm_distCov::dvine) implying the use of the Dvine
    !>                                          algorithm for generating random covariance matrices whose determinants are
    !>                                          [power-law distributed](@ref pm_distPower) with exponent `eta`.<br>
    !>                                          In this case, the argument `method` has `intent(in)`.<br>
    !>                                  <li>    A scalar output variable of type [onion_type](@ref pm_distCov::onion_type)
    !>                                          such as [onion](@ref pm_distCov::onion) implying the use of the Onion
    !>                                          algorithm for generating random covariance matrices whose determinants are
    !>                                          [power-law distributed](@ref pm_distPower) with exponent `eta`.<br>
    !>                                          In this case, the argument `method` has `intent(out)`.<br>
    !>                                          If the Cholesky factorization within the Onion algorithm fails,
    !>                                          `method%info` will be set to the order of the leading minor of
    !>                                          the specified input subset of `mat` that is not positive definite,
    !>                                          indicating the occurrence of an error and that the factorization could not be completed.<br>
    !>                                          Otherwise, the `info` component of the onion `method` is set to `0`.<br>
    !>                              </ol>
    !>                              The resulting matrix distribution from [dvine](@ref pm_distCov::dvine) and [onion](@ref pm_distCov::onion)
    !>                              are identically distributed but [onion](@ref pm_distCov::onion) method tends to have slightly faster runtime.<br>
    !>                              The larger `eta` is, the more the output random matrix looks like the Identity matrix.<br>
    !>                              Setting `eta = 0.` corresponds to a uniform distribution of the output matrix
    !>                              over the space of positive-definite correlation matrices.<br>
    !>                              See the description of the output argument `rand` for more information on the
    !>                              effects of `eta` on the off-diagonal elements of the output positive-definite matrix.<br>
    !>                              (**optional**. If missing the Gram method is used for random matrix generation. It must be missing for output `rand` of type `complex`.)
    !>  \param[in]      eta     :   The input non-negative scalar of type `real` of the same kind as the output argument `rand`.<br>
    !>                              The larger `eta` is, the more the output random matrix looks like the Identity matrix.<br>
    !>                              Setting `eta = 0.` corresponds to a uniform distribution of the output matrix
    !>                              over the space of positive-definite correlation matrices.<br>
    !>                              See the description of the output argument `rand` for more information on the
    !>                              effects of `eta` on the off-diagonal elements of the output positive-definite matrix.<br>
    !>                              (**optional**. It must be present **if and only if** the input argument `method` is also present.)
    !>  \param[in]      scale   :   The input scalar or `contiguous` vector of size `ndim` of type `real` of the same kind as the output argument `rand`,
    !>                              representing the scale of the matrix (e.g., the standard deviation of a covariance matrix) along each dimension.<br>
    !>                              (**optional**. default = `1.`)
    !>
    !>  \interface{setCovRand}
    !>  \code{.F90}
    !>
    !>      use pm_distCov, only: setCovRand
    !>
    !>      ! Default (Gram) method.
    !>
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim))
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim), scale)
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim), scale(1:ndim))
    !>
    !>      ! Other methods.
    !>
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim), method, eta)
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim), method, eta, scale)
    !>      call setCovRand(rng, rand(1:ndim, 1:ndim), method, eta, scale(1:ndim))
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `0 <= eta` must hold for the corresponding input arguments.<br>
    !>  The condition `all([0 < scale])` must hold for the corresponding input arguments.<br>
    !>  The condition `size(rand, 1) == size(rand, 2)` must hold for the corresponding input arguments.<br>
    !>  The condition `rank(scale) == 0 .or. all(size(scale) == shape(rand))` must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \warning
    !>  Beware that when the input argument `scale` is missing,
    !>  the diagonal elements of the output correlation matrix are not enforced to match `1`.<br>
    !>  As such, numerical matrix multiplication errors may lead to diagonal matrix values slightly deviating from `1`.
    !>  If you need such a guarantee on the diagonal elements of the output random correlation matrix, use [getCovRand](@ref pm_distCov::getCovRand).<br>
    !>
    !>  \example{setCovRand}
    !>  \include{lineno} example/pm_distCov/setCovRand/main.F90
    !>  \compilef{setCovRand}
    !>  \output{setCovRand}
    !>  \include{lineno} example/pm_distCov/setCovRand/main.out.F90
    !>
    !>  \test
    !>  [test_pm_distCov](@ref test_pm_distCov)
    !>
    !>  \todo
    !>  \phigh
    !>  The current implementation of this generic interface uses a naive method of computing the Cholesky factorization with a default matrix packing for the Onion method.<br>
    !>  The RFP packing format must be also implemented for this generic interface.<br>
    !>
    !>  \todo
    !>  \phigh
    !>  The current implementation of the Gram method can be significantly improved, both computationally and functionally.<br>
    !>
    !>  \final{setCovRand}
    !>
    !>  \author
    !>  \AmirShahmoradi, Monday March 6, 2017, 3:22 pm, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin.<br>

    ! setCovRandG RK

    interface setCovRand

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandGRNGFSD_RK5(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandGRNGFSD_RK4(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandGRNGFSD_RK3(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandGRNGFSD_RK2(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandGRNGFSD_RK1(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandGRNGFS0_RK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandGRNGFS0_RK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandGRNGFS0_RK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandGRNGFS0_RK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandGRNGFS0_RK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandGRNGFS1_RK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandGRNGFS1_RK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandGRNGFS1_RK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandGRNGFS1_RK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandGRNGFS1_RK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandGRNGXSD_RK5(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandGRNGXSD_RK4(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandGRNGXSD_RK3(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandGRNGXSD_RK2(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandGRNGXSD_RK1(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandGRNGXS0_RK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandGRNGXS0_RK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandGRNGXS0_RK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandGRNGXS0_RK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandGRNGXS0_RK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandGRNGXS1_RK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandGRNGXS1_RK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandGRNGXS1_RK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandGRNGXS1_RK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandGRNGXS1_RK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! setCovRandG CK

    interface setCovRand

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine setCovRandGRNGFSD_CK5(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(rngf_type)         , intent(in)                    :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine setCovRandGRNGFSD_CK4(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(rngf_type)         , intent(in)                    :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine setCovRandGRNGFSD_CK3(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(rngf_type)         , intent(in)                    :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine setCovRandGRNGFSD_CK2(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(rngf_type)         , intent(in)                    :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine setCovRandGRNGFSD_CK1(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFSD_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(rngf_type)         , intent(in)                    :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine setCovRandGRNGFS0_CK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine setCovRandGRNGFS0_CK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine setCovRandGRNGFS0_CK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine setCovRandGRNGFS0_CK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine setCovRandGRNGFS0_CK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS0_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine setCovRandGRNGFS1_CK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine setCovRandGRNGFS1_CK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine setCovRandGRNGFS1_CK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine setCovRandGRNGFS1_CK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine setCovRandGRNGFS1_CK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGFS1_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(rngf_type)         , intent(in)                    :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    PURE module subroutine setCovRandGRNGXSD_CK5(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    PURE module subroutine setCovRandGRNGXSD_CK4(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    PURE module subroutine setCovRandGRNGXSD_CK3(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    PURE module subroutine setCovRandGRNGXSD_CK2(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    PURE module subroutine setCovRandGRNGXSD_CK1(rng, rand)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXSD_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    PURE module subroutine setCovRandGRNGXS0_CK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    PURE module subroutine setCovRandGRNGXS0_CK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    PURE module subroutine setCovRandGRNGXS0_CK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    PURE module subroutine setCovRandGRNGXS0_CK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    PURE module subroutine setCovRandGRNGXS0_CK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS0_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)                    :: scale
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    PURE module subroutine setCovRandGRNGXS1_CK5(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_CK5
#endif
        use pm_kind, only: CKG => CK5
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK4_ENABLED
    PURE module subroutine setCovRandGRNGXS1_CK4(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_CK4
#endif
        use pm_kind, only: CKG => CK4
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK3_ENABLED
    PURE module subroutine setCovRandGRNGXS1_CK3(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_CK3
#endif
        use pm_kind, only: CKG => CK3
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK2_ENABLED
    PURE module subroutine setCovRandGRNGXS1_CK2(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_CK2
#endif
        use pm_kind, only: CKG => CK2
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if CK1_ENABLED
    PURE module subroutine setCovRandGRNGXS1_CK1(rng, rand, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandGRNGXS1_CK1
#endif
        use pm_kind, only: CKG => CK1
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(CKG)               , intent(in)    , contiguous    :: scale(:)
        complex(CKG)            , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! setCovRandD

    interface setCovRand

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandDRNGFSD_RK5(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandDRNGFSD_RK4(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandDRNGFSD_RK3(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandDRNGFSD_RK2(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandDRNGFSD_RK1(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandDRNGFS0_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandDRNGFS0_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandDRNGFS0_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandDRNGFS0_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandDRNGFS0_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandDRNGFS1_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandDRNGFS1_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandDRNGFS1_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandDRNGFS1_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandDRNGFS1_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGFS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandDRNGXSD_RK5(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandDRNGXSD_RK4(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandDRNGXSD_RK3(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandDRNGXSD_RK2(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandDRNGXSD_RK1(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandDRNGXS0_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandDRNGXS0_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandDRNGXS0_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandDRNGXS0_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandDRNGXS0_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandDRNGXS1_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandDRNGXS1_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandDRNGXS1_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandDRNGXS1_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandDRNGXS1_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandDRNGXS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(dvine_type)        , intent(in)                    :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! setCovRandO

    interface setCovRand

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandORNGFSD_RK5(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandORNGFSD_RK4(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandORNGFSD_RK3(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandORNGFSD_RK2(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandORNGFSD_RK1(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandORNGFS0_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandORNGFS0_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandORNGFS0_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandORNGFS0_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandORNGFS0_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine setCovRandORNGFS1_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine setCovRandORNGFS1_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine setCovRandORNGFS1_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine setCovRandORNGFS1_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine setCovRandORNGFS1_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGFS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(rngf_type)         , intent(in)                    :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandORNGXSD_RK5(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXSD_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandORNGXSD_RK4(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXSD_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandORNGXSD_RK3(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXSD_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandORNGXSD_RK2(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXSD_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandORNGXSD_RK1(rng, rand, method, eta)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXSD_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandORNGXS0_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS0_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandORNGXS0_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS0_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandORNGXS0_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS0_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandORNGXS0_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS0_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandORNGXS0_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS0_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)                    :: scale
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setCovRandORNGXS1_RK5(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS1_RK5
#endif
        use pm_kind, only: RKG => RK5
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setCovRandORNGXS1_RK4(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS1_RK4
#endif
        use pm_kind, only: RKG => RK4
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setCovRandORNGXS1_RK3(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS1_RK3
#endif
        use pm_kind, only: RKG => RK3
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setCovRandORNGXS1_RK2(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS1_RK2
#endif
        use pm_kind, only: RKG => RK2
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setCovRandORNGXS1_RK1(rng, rand, method, eta, scale)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setCovRandORNGXS1_RK1
#endif
        use pm_kind, only: RKG => RK1
        type(onion_type)        , intent(out)                   :: method
        type(xoshiro256ssw_type), intent(inout)                 :: rng
        real(RKG)               , intent(in)                    :: eta
        real(RKG)               , intent(in)    , contiguous    :: scale(:)
        real(RKG)               , intent(out)   , contiguous    :: rand(:,:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end module pm_distCov