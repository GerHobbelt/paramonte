!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!                                                                                                                            !!!!
!!!!    ParaMonte: Parallel Monte Carlo and Machine Learning Library.                                                           !!!!
!!!!                                                                                                                            !!!!
!!!!    Copyright (C) 2012-present, The Computational Data Science Lab                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!    This file is part of the ParaMonte library.                                                                             !!!!
!!!!                                                                                                                            !!!!
!!!!    LICENSE                                                                                                                 !!!!
!!!!                                                                                                                            !!!!
!!!!       https://github.com/cdslaborg/paramonte/blob/main/LICENSE.md                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!>  \brief
!>  This module contains classes and procedures for input/output (IO) or generic display operations on standard displays or internal/external files.
!>
!>  \details
!>
!>  Quick start
!>  -----------
!>
!>  The following is a (non-exhaustive) list of the most useful functionalities in this module:<br>
!>  <ol>
!>      <li>    [display_type](@ref pm_io::display_type) is a derived type for creating objects
!>              whose methods (`show`, `wrap`, `skip`, ...) can display all sorts of scalar and array objects of
!>              intrinsic type and kind as well as [containers](@ref pm_container) of various intrinsic types and kinds.<br>
!>      <li>    [getContentsFrom](@ref pm_io::getContentsFrom) and [setContentsFrom](@ref pm_io::setContentsFrom) are functional
!>              and subroutine interfaces for reading the entire contents of a given file or connect unit into a scalar string.<br>
!>      <li>    [getErrTableWrite](@ref pm_io::getErrTableWrite) writes a data matrix as a csv, list-directed or other arbitrarily-delimited table of data to a specified file or unit.<br>
!>      <li>    [getErrTableRead](@ref pm_io::getErrTableRead) reads a csv, list-directed or other arbitrarily-delimited table of data from a specified file or unit.<br>
!>      <li>    [getCountRecord](@ref pm_io::getCountRecord) counts the number of records (optionally matching a user-specified pattern) in a `sequential` access file or unit.<br>
!>      <li>    [getCountRecordLeft](@ref pm_io::getCountRecordLeft) counts the number of records **left**, optionally matching a user-specified pattern, in a `sequential` access connected-file unit.<br>
!>      <li>    [getRecordFrom](@ref pm_io::getRecordFrom) and [setRecordFrom](@ref pm_io::setRecordFrom) read a single line from a specified `sequential` access file or unit into an `allocatable` string.<br>
!>      <li>    [getFieldSep](@ref pm_io::getFieldSep) identifies the most likely separator used in a file to separate fields of a record-oriented file from a list of possible separators of arbitrary length.<br>
!>      <li>    [getFormat](@ref pm_io::getFormat) seamlessly creates a suitable format for outputting a record of fields of
!>              arbitrary type and kind, each field of which can be delimited and optionally contain multiple subfields.<br>
!>      <li>    [setContentsTo](@ref pm_io::setContentsTo) outputs a scalar string to an unconnected file as a binary stream.<br>
!>      <li>    [isOpen](@ref pm_io::isOpen) checks if a file or unit is already connected (opened).<br>
!>      <li>    etc.<br>
!>
!>  </ol>
!>
!>  IO terminology
!>  --------------
!>
!>  The following is a collection of terms and phrases frequently used in the documentation of this module.<br>
!>      -#  A **file** is a logical unit of information created by processes and are managed by the operating system.<br>
!>      -#  The part of the operating system that deals with files is known as the **file system**.<br>
!>      -#  An I/O **record** is a collection of characters or values that are logically related and are frequently processed together.<br>
!>          Three common types of records are:<br>
!>          -#  **formatted**
!>              -#  A formatted record consists of a sequence of ASCII characters that can print in a readable format.
!>              -#  Reading a formatted record converts the data values from readable characters into an internal representation.
!>              -#  Writing a formatted record converts the data from the internal representation into characters.
!>          -#  **unformatted**
!>              -#  An unformatted record contains a sequence of values in an internal representation that can contain both character and noncharacter data.
!>              -#  Reading or writing an unformatted record does not convert any data the record contains from the internal representation.
!>              -#  An unformatted record can also contain no data.
!>          -#  **endfile**
!>              -#  If it exists, an `endfile` record is the last record of a file.
!>              -#  The `endfile` record has no length.
!>              -#  The `endfile` record can be **written explicitly** by the `endfile()` Fortran intrinsic statement.
!>              -#  The `endfile` record can be **written implicitly** to a file connected for sequential access **when**,
!>                  -#  the last data transfer statement was a `write()` statement,
!>                  -#  no intervening file positioning statement referring to the file has been executed,
!>                  -#  and the following is true:
!>                      -#  A `rewind()` or `backspace()` statement references the unit to which the file is connected; or
!>                      -#  The file is closed, either<br>
!>                          -#  explicitly by a `close()` statement, or<br>
!>                          -#  implicitly by a program termination not caused by an error condition, or<br>
!>                          -#  implicitly by another `open()` statement for the same unit.<br>
!>      -#  **File organization** refers to the way records are physically arranged on a storage device.<br>
!>          -#  The main types of file organization in Fortran are the following,<br>
!>                  -#  **Sequential**<br>
!>                      -#  A sequentially organized file consists of records arranged in the sequence in which they are written to the file.
!>                      -#  As a result, records can be added only at the end of the file.
!>                      -#  Attempting to add records at some place other than the end of the file will result in the file begin truncated at the end of the record just written.
!>                      -#  Sequential files can be stored on magnetic tape or disk devices.<br>
!>                      -#  Other peripheral devices, such as terminals, pipes, and line printers as sequential files.
!>                      -#  Sequential files are usually read sequentially, starting with the first record in the file.
!>                      -#  Sequential files with a fixed-length record-type stored on disk can also be accessed by relative record number (**direct access**).
!>                  -#  **Relative (direct access)**<br>
!>                      -#  Relative files are just like arrays [of structures], but instead of residing in the main memory, they are recorded on a disk device.
!>                      -#  Relative files can only be stored on a disk device (e.g., not on magnetic tapes).
!>                      -#  Within a relative file are numbered positions, called **cells**.
!>                      -#  These cells are of fixed equal length and are consecutively numbered from `1` to `n`, corresponding to the first and last cells in the file.
!>                      -#  Each cell either contains either a single record or is empty.
!>                      -#  Records in a relative file are accessed according to the cell number.
!>                      -#  The cell number is the record number relative to the beginning of the file.
!>                      -#  By specifying relative record numbers, one can directly retrieve, add, or delete records regardless of their locations.
!>                      -#  When creating a relative file, the `RECL` can be `inquire`d to determine the size of the fixed-length cells.
!>                      -#  Within the cells, one can store records of varying length, as long as their size does not exceed the cell size.
!>                  -#  **Indexed (not in the Fortran standard)**<br>
!>                      -#  An indexed file is made of "data cells", not necessarily of the same size, and contain **indexes**, lists of **pointers** to these cells arranged by some order.
!>                      -#  The Fortran Standard does not require support for indexed files (although some compilers do).<br>
!>      -#  The two major types of file systems are the following:<br>
!>          -#  A stream of bytes (**byte Sequence**) known as the **stream access** in Fortran.<br>
!>          -#  A stream of records (**record sequence**).<br>
!>              Depending on the lengths of individual record in the file, two separate internal structures are commonly used.<br>
!>              -#  A stream of **equal-length records**, also known as the **direct access** files in Fortran.<br>
!>                  The position in the direct access file in Fortran is specified in terms of **records**.<br>
!>                  All records have the same length (specified by the `RECL=` specifier in call to `open()` statement).<br>
!>                  For example, if a file contains 20 records and has record length equal to 30, then<br>
!>                  -#  the total size of data the program can access from the file is 600 bytes and,<br>
!>                  -#  every read or write operation will access a record containing 30 bytes.<br>
!>              -#  A stream of **arbitrary-length records**, also known as the **sequental access** files in Fortran.<br>
!>      -#  The **record-type** refers to the convention used for storing fields in records.<br>
!>          The record-type of the data within a file is not maintained as an attribute of the file.<br>
!>          The results of using a record type other than the one used to create the file are **indeterminate**.<br>
!>      -#  The **record overhead** is the number of bytes associated with each record used internally by the file system and are not available when a record is read or written.
!>      -#  The following table list the commonly available record types.
!>          Record Type     |   Available File Organizations and Portability Considerations                                 |   Record Overhead
!>          ----------------|-----------------------------------------------------------------------------------------------|------------------
!>          Fixed-length    |   Relative or sequential file organizations.                                                  |   None for sequential.
!>          Variable-length |   Sequential file organization only.                                                          |   Eight bytes per record. The most portable record type.
!>          Stream          |   Sequential file organization only. No record terminator needed.                             |   zero.
!>          Stream_CR       |   Sequential file organization only. It uses `CR` (carriage return) as record terminator.     |   One byte per record.
!>          Stream_LF       |   Sequential file organization only. It uses `LF` (line feed) as record terminator).          |   One byte per record.
!>          Stream_CRLF     |   Sequential file organization only. It uses both `CR` and `LF` as record terminator.         |   Two bytes per record.
!>          Given the above record overheads, `stream` record type yields the smallest possible file sizes.
!>      -#  **Fixed-Length Records** require that all records in the file contain the same number of bytes.<br>
!>          When  a file is opened to contain fixed-length records, the record size must be specified using the `RECL` specified of the `open()` statement.<br>
!>          A sequentially-organized opened file for **direct access** must contain fixed-length records to allow the record position in the file to be computed correctly.
!>      -#  **Variable-Length Records** can contain any number of bytes up to a specified **maximum record length** and apply only to sequential files.<br>
!>          Variable-length records are prefixed and suffixed by 4 bytes of control information containing length fields.<br>
!>          The trailing length field allows a `backspace()` request to skip back over records efficiently.<br>
!>          The 4-byte integer value stored in each length field indicates the number of data bytes (excluding overhead bytes) in that particular variable-length record.<br>
!>          For a record length greater than `2,147,483,639` bytes, the record is divided into **subrecords**. The subrecord can be of any length from `1` to `2,147,483,639`, inclusive.<br>
!>          The sign bit of the leading length field indicates whether the record is continued or not.<br>
!>          The sign bit of the trailing length field indicates the presence of a preceding subrecord.<br>
!>          The position of the sign bit is determined by the endian format of the file.<br>
!>          The following rules describe sign bit values:
!>          -#  A subrecord that is continued has a leading length field with a sign bit value of `1`.
!>          -#  The last subrecord that makes up a record has a leading length field with a sign bit value of `0`.
!>          -#  A subrecord that has a preceding subrecord has a trailing length field with a sign bit value of `1`.
!>          -#  The first subrecord that makes up a record has a trailing length field with a sign bit value of `0`.
!>          -#  If the value of the sign bit is `1`, the length of the record is stored in twos-complement notation.
!>      -#  **Stream files** contain no control information and their contents is not grouped into records.<br>
!>          -#  Stream-access I/O is a method of accessing a file without reference to a record structure.<br>
!>          -#  With stream access, a file is seen as a continuous sequence of bytes and is addressed by a positive integer starting from `1`.<br>
!>          -#  To enable stream access, one should specify `access = "stream"` in the `open()` statement for the file.<br>
!>          -#  A file enabled for stream access is positioned by file storage units (normally bytes) starting at position `1`.<br>
!>          -#  To determine the current position, one must use the `pos` specifier in an `inquire()` statement for the unit.<br>
!>          -#  One can also indicate a required position in a read or write statement with a `pos` specifier.<br>
!>          -#  Stream files can contain character or binary data that is read or written only to the extent of the variables specified on the input or output statement.
!>          -#  Stream files can be connected to external files for stream access as either `formatted` or `unformatted`.
!>          -#  Both `formatted` and `unformatted` forms use external stream files composed of one byte file storage units.
!>          -#  A file connected for `unformatted` stream access has only a stream structure.
!>          -#  By contrast, files connected for `formatted` stream access have both a **record** and a **stream structure**.
!>          -#  These dual structure files have the following characteristics:
!>              -#  Some file storage units represent record markers.
!>              -#  The record structure is inferred from the record markers stored in the file.
!>              -#  There is no theoretical limit on record length.
!>              -#  Writing an empty record without a record marker has no effect.
!>              -#  If there is no record marker at the end of a file, the final record is incomplete but not empty.
!>              -#  The endfile record in a file previously connected for sequential access is not considered part of the file when you connect that file for stream access.
!>          -#  When connected for **formatted stream access**, an external file has the following characteristics:
!>              -#  The first file storage unit in the file is at position `1`.
!>              -#  The relationship between positions of successive file storage units is processor dependent; not all positive integers need to correspond to valid positions.
!>              -#  Some file storage units may contain record markers that impose a record structure on the file in addition to its stream structure.
!>              -#  If there is no record marker at the end of the file, the final record is incomplete. Writing an empty record with no record marker has no effect.
!>          -#  When connected for **unformatted stream access**, an external file has the following characteristics:
!>              -#  The first file storage unit in the file is at position `1`.
!>              -#  The position of each subsequent file storage unit is one greater than the position of the preceding file storage unit.
!>              -#  If it is possible to position the file, the file storage units do not need to be read or written in order of their position.
!>              -#  For example, you may be able to write the file storage unit at position 2, even though the file storage unit at position 1 has not been written.
!>              -#  Any file storage unit can be read from the file while it is connected to a unit, if the file storage unit has been written since the file was created, and a `read()` statement for this connection is allowed.
!>              -#  One **cannot** use `backspace()` in an unformatted stream.
!>      -#  **Sequential-access files** can be either **internal** and **external** files.
!>          -#  **Internal files**
!>              -#  An internal file always has sequential access.
!>              -#  An internal file is a character variable that is not an array section with a vector subscript.
!>              -#  If an internal file is a scalar character variable, the file consists of one record with a length equal to that of the scalar variable.
!>              -#  If an internal file is a character array, each element of the array is a record of the file, with each record having the same length.
!>              -#  An internal file **must contain only formatted records**. `read()` and `write()` are the only statements that can specify an internal file.
!>              -#  If a `write()` statement writes less than an entire record, **blanks fill the remainder of that record**.
!>          -#  **External files**
!>              -#  A file connected for sequential access contains records in the order they were written.
!>              -#  The records must be either **all formatted** or **all unformatted**.
!>              -#  The last record of the file must be an **endfile record**.
!>              -#  The records must not be read or written by `direct` or `stream` access I/O statements **as long as** the file is connected for `sequential` access.
!>      -#  **Direct-access files** allow the records of an external file to be read or written in any order.
!>          -#  The records must be either all formatted or all unformatted.
!>          -#  The records must **not** be read or written using `sequential` or `stream` access, list-directed or namelist formatting, or a nonadvancing input/output statement.
!>          -#  If the file was previously connected for sequential access, the last record of the file is an endfile record.
!>          -#  The endfile record is not considered a part of the file connected for direct access.
!>          -#  Each record in a file connected for direct access has a record number that identifies its order in the file.
!>          -#  The record number is an integer value that must be specified when the record is read or written.
!>          -#  Records are numbered sequentially. The first record is number 1.
!>          -#  Records need not be read or written in the order of their record numbers. For example, records `9`, `5`, and `11` can be written in that order without writing the intermediate records.
!>          -#  All records in a file connected for direct access **must have the same length**, which is specified in the `open()` statement when the file is connected.
!>          -#  Records in a file connected for direct access **cannot be deleted**, but they **can be rewritten** with a new value.
!>          -#  A record cannot be read unless it has first been written.
!>
!>  \note
!>  There are a number of other points to note with respect to files.
!>  -#  The set of allowed names for a file is processor dependent.
!>  -#  Both `sequential` and `direct` access may be available for some files, but normally a file is limited to `sequential`, `direct`, or `stream` access.
!>  -#  A file **never** contains both formatted and unformatted records.
!>
!>  \note
!>  Typical file operations that are also partly covered in this module and partly in [pm_sysPath](@ref pm_sysPath) are,
!>  -#  Create
!>  -#  Delete
!>  -#  Open
!>  -#  Close
!>  -#  Read
!>  -#  Write
!>  -#  Append (This call is a restricted form of write. It can add data only to the end of the file.)
!>  -#  Seek (Repositions the file pointer to a specific place in the file.)
!>  -#  Get Attributes (Processes often need to read file attributes to do their work.)
!>  -#  Set Attributes (Some of the attributes are user settable and can be changed after the file has been created.)
!>  -#  Rename (changes the name of the file.)
!>
!>  \note
!>  Previous versions of this modules contained functions for inquiring various attributes of files via the intrinsic `inquire()` statement.<br>
!>  The current version has deprecated and deleted all such functions as their maintenance is more costly than any potential benefits they may offer.<br>
!>  Such functions cannot be `pure` due to the call to the `inquire()` statement. As such, they are unlikely to be inlined by the compiler.<br>
!>  Furthermore, any call to such functions from outside their parent module requires a `use` statement, followed by the function call,
!>  which effectively yields the same amount of verbosity caused by directly calling the `inquire()` statement.<br>
!>  Additionally, a single call to the Fortran `inquire()` statement can return multiple attributes of a file or unit,
!>  which makes this statement much more concise and efficient as opposed to any user-defined function.<br>
!>
!>  \see
!>  [IBM documentation of Fortran File access methods](https://www.ibm.com/docs/en/xffbg/121.141?topic=files-file-access-methods)<br>
!>  [Intel documentation of Fortran File access methods](https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2023-2/fortran-i-o.html)<br>
!>  [Intel Fortran compiler documentation for **OPEN - RECL Specifier**](https://www.intel.com/content/www/us/en/develop/documentation/fortran-compiler-oneapi-dev-guide-and-reference/top/language-reference/file-operation-i-o-statements/open-statement-specifiers/open-recl-specifier.html)<br>
!>  [Metcalf et al., Modern Fortran Explained - Incorporating Fortran 2018](https://books.google.com/books?id=sB1rDwAAQBAJ&lpg=PP1&pg=PP1#v=onepage&q&f=false)<br>
!>  [Files and records](https://www.ibiblio.org/pub/languages/fortran/ch5-4.html)<br>
!>
!>  \test
!>  [test_pm_io](@ref test_pm_io)
!>
!>  \final{pm_io}
!>
!>  \author
!>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!>  \cond excluded
#if 1
#define __CONTIGUOUS
#else
#define __CONTIGUOUS, contiguous
#endif
!>  \endcond excluded

module pm_io

    use pm_err, only: mark_type
    use pm_err, only: note_type
    use pm_err, only: warn_type
    use pm_err, only: stop_type
    use pm_val2str, only: getStr
    use pm_kind, only: SK, IK, LK
    use pm_option, only: getOption
    use pm_container, only: css_type
    use iso_fortran_env, only: output_unit
    use pm_matrixTrans, only: trans, trans_type

    implicit none

    character(*, SK), parameter :: MODULE_NAME = "@pm_io"

    !>  \brief
    !>  This is the derived type for generating objects containing the source
    !>  file extensions used by different programming language environments.
    !>
    !>  \details
    !>  This derived type is of minimal usage outside the ParaMonte library internal routines.<br>
    !>  If needed, the constant object instances of this derived type [filext](@ref pm_io::filext) can be used.<br>
    !>
    !>  \see
    !>  [filext](@ref pm_io::filext)<br>
    !>
    !>  \final{filext_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 11:35 PM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type :: filext_type
        character(4, SK)    :: ascii        = SK_".txt"
        character(4, SK)    :: binary       = SK_".bin"
        character(2, SK)    :: c            = SK_".c"
        character(4, SK)    :: cobol        = SK_".cbl"
        character(4, SK)    :: cpp          = SK_".cpp"
        character(3, SK)    :: csharp       = SK_".cs"
        character(3, SK)    :: go           = SK_".go"
        character(4, SK)    :: fortran      = SK_".F90"
        character(5, SK)    :: java         = SK_".java"
        character(3, SK)    :: javascript   = SK_".js"
        character(3, SK)    :: julia        = SK_".jl"
        character(2, SK)    :: matlab       = SK_".m"
        character(4, SK)    :: mathematica  = SK_".wls"
        character(3, SK)    :: python       = SK_".py"
        character(2, SK)    :: r            = SK_".R"
        character(3, SK)    :: rust         = SK_".rs"
        character(4, SK)    :: sas          = SK_".sas"
        character(6, SK)    :: swift        = SK_".swift"
    end type

    !>  \brief
    !>  The scalar constant object of type [filext_type](@ref pm_io::filext_type)
    !>  containing file extensions used by different programming language environments.
    !>
    !>  \see
    !>  [filext_type](@ref pm_io::filext_type)<br>
    !>
    !>  \final{filext}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 11:35 PM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(filext_type), parameter :: filext = filext_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: filext
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !integer(IK)     , parameter :: DISPLAY_WIDTH = 132_IK
    !integer(IK)     , parameter :: DISPLAY_THICKNESS_HORZ = 4_IK
    !integer(IK)     , parameter :: DISPLAY_THICKNESS_VERT = 1_IK

    !>  \brief
    !>  The scalar `character` of default kind \SK  of `len = 1` representing the default string that is used for filling the margins of the display or wrapped texts.
    character(*, SK), parameter :: MFILL = SK_"%"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: MFILL
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK of `len = 4` representing representing ASCII character: Horizontal Tab, which is frequently used in external files as column or field separators.
    character(1, SK), parameter :: TAB = achar(9, SK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: TAB
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK of `len = 4` representing the default string that is used in place of the tab character in the display.
    character(*, SK), parameter :: TABEQV = repeat(SK_" ", 4)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: TABEQV
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK of the same value as [TABEQV](@ref pm_io::TABEQV) representing the default indentation of text in the display, when indentation is needed.
    character(*, SK), parameter :: INDENT = TABEQV !//TABEQV
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: INDENT
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK containing the generic IO whitespace-separated IO format.
    character(*, SK), parameter :: FORMAT_GENERIC_BLANK = SK_"(*(g0,:,' '))"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: FORMAT_GENERIC_BLANK
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK containing the generic IO whitespace-separated IO format with in an initial [INDENT](@ref pm_io::INDENT).
    character(*, SK), parameter :: FORMAT_GENERIC_BLANK_TABBED = SK_"('"//INDENT//SK_"',*(g0,:,' '))"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: FORMAT_GENERIC_BLANK_TABBED
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK containing the generic signed comma-space-separated format used as the default within objects of [display_type](@ref pm_io::display_type).
    character(*, SK), parameter :: FORMAT_GENERIC_DISPLAY = SK_"(sp,*(g0,:,', '))"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: FORMAT_GENERIC_DISPLAY
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK containing the generic signed comma-space-separated format that
    !>  can be used as the math-style complex formatting when constructing objects of [display_type](@ref pm_io::display_type).
    character(*, SK), parameter :: FORMAT_GENERIC_DISPLAY_COMPLEX_MATH = SK_"(sp,*(2g0,'i',:,', '))"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: FORMAT_GENERIC_DISPLAY_COMPLEX_MATH
#endif

    !>  \brief
    !>  The scalar `character` of default kind \SK containing the generic signed comma-space-separated format that
    !>  can be used as the Fortran-style complex formatting when constructing objects of [display_type](@ref pm_io::display_type).
    character(*, SK), parameter :: FORMAT_GENERIC_DISPLAY_COMPLEX_FORTRAN = SK_"(sp,*('(',g0,', ',g0,')',:,', '))"
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: FORMAT_GENERIC_DISPLAY_COMPLEX_FORTRAN
#endif

    !>  \brief
    !>  The scalar `character(1, SK)` of default kind \SK of size `4`, containing the four characters used to display a spinning command line cursor.
    character(1, SK), parameter :: SPINNER(4) = [ "|" , "/" , "-" , "\" ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: SPINNER
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    integer(IK)     , parameter :: LEN_IOMSG = 511_IK   !<  \public The scalar `integer` of default kind \IK representing the maximum
                                                        !!          length of an IO error message returned by the Fortran intrinsic routines.
                                                        !!          Note that this an arbitrary length defined globally for consistency.
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: LEN_IOMSG
#endif

    integer(IK)     , parameter :: LEN_RECORD = 8191_IK !<  \public The scalar `integer` of default kind \IK representing the
                                                        !!          effective maximum length of a record in a record-oriented file.
                                                        !!          Note that this is an arbitrary length defined globally for consistency.
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: LEN_RECORD
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  The derived type that can be used for constructing containers of `format`
    !>  or left and right delimiters for the (five) intrinsic Fortran field types.
    !>
    !>  \details
    !>  Object of this derived type can be either,
    !>  <ol>
    !>      <li>    passed as input arguments to the constructor of [display_type](@ref pm_io::display_type)
    !>              to specify the IO formatting of fields of objects of various intrinsic types that are to be subsequently displayed by the methods of [display_type](@ref pm_io::display_type).<br>
    !>      <li>    used in other situations to specify properties of IO fields of various intrinsic types, for example, to specify the left and right delimiters of fields of objects of intrinsic types.<br>
    !>  </ol>
    !>
    !>  \param[in]  string      :   The input `allocatable` scalar `character` of default kind \SK containing a specific formatting property of a field of type `character`.<br>
    !>                              (**optional**. If missing, the corresponding component of the output `field` object remains unallocated.)
    !>  \param[in]  integer     :   The input `allocatable` scalar `character` of default kind \SK containing a specific formatting property of a field of type `integer`.<br>
    !>                              (**optional**. If missing, the corresponding component of the output `field` object remains unallocated.)
    !>  \param[in]  logical     :   The input `allocatable` scalar `character` of default kind \SK containing a specific formatting property of a field of type `logical`.<br>
    !>                              (**optional**. If missing, the corresponding component of the output `field` object remains unallocated.)
    !>  \param[in]  complex     :   The input `allocatable` scalar `character` of default kind \SK containing a specific formatting property of a field of type `complex`.<br>
    !>                              (**optional**. If missing, the corresponding component of the output `field` object remains unallocated.)
    !>  \param[in]  real        :   The input `allocatable` scalar `character` of default kind \SK containing a specific formatting property of a field of type `real`.<br>
    !>                              (**optional**. If missing, the corresponding component of the output `field` object remains unallocated.)
    !>
    !>  \return
    !>  `field`                 :   The output scalar object of type [field_type](@ref pm_io::field_type)
    !>                              containing `allocatable` scalar `character` components corresponding to the input arguments.<br>
    !>                              Any component of the output `field` corresponding to a **missing** input argument remains **unallocated** on output.<br>
    !>
    !>  \interface{field_type}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: field_type
    !>      type(field_type) :: field
    !>
    !>      field = field_type(string = string, integer = integer, logical = logical, complex = complex, real = real)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \elemental
    !>
    !>  \see
    !>  [wrap_type%%wrap()](@ref pm_io::wrap)<br>
    !>  [display_type%%show()](@ref pm_io::show)<br>
    !>  [display_type%%skip()](@ref pm_io::skip)<br>
    !>  [getStrWrapped](@ref pm_str::getStrWrapped)<br>
    !>  [getCentered](@ref pm_arrayCenter::getCentered)<br>
    !>  [setCentered](@ref pm_arrayCenter::setCentered)<br>
    !>  [isFailedGetShellWidth](@ref pm_sysShell::isFailedGetShellWidth)<br>
    !>  [isFailedGetShellHeight](@ref pm_sysShell::isFailedGetShellHeight)<br>
    !>
    !>  \example{field_type}
    !>  \include{lineno} example/pm_io/field_type/main.F90
    !>  \compilef{field_type}
    !>  \output{field_type}
    !>  \include{lineno} example/pm_io/field_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{field_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type :: field_type
        character(:, SK), allocatable :: string     !<  \public The scalar `character` of default kind \SK representing the **default left or right delimiter** to be used for wrapping `character` fields before displaying them.
        character(:, SK), allocatable :: integer    !<  \public The scalar `character` of default kind \SK representing the **default left or right delimiter** to be used for wrapping `integer` fields before displaying them.
        character(:, SK), allocatable :: logical    !<  \public The scalar `character` of default kind \SK representing the **default left or right delimiter** to be used for wrapping `logical` fields before displaying them.
        character(:, SK), allocatable :: complex    !<  \public The scalar `character` of default kind \SK representing the **default left or right delimiter** to be used for wrapping `complex` fields before displaying them.
        character(:, SK), allocatable :: real       !<  \public The scalar `character` of default kind \SK representing the **default left or right delimiter** to be used for wrapping `real` fields before displaying them.
    end type

    !>  \cond excluded
    interface field_type
    pure elemental module function field_typer(string, integer, logical, complex, real) result(field)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: field_typer
#endif
        character(*, SK), intent(in), optional :: string, integer, logical, complex, real
        type(field_type) :: field
    end function
    end interface
    !>  \endcond excluded

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is an `abstract` derived type for constructing concrete derived types to
    !>  distinguish various procedure signatures that require different file forms (e.g., csv, binary, ...).<br>
    !>
    !>  \details
    !>  This `abstract` derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users must use `parameter` objects instantiated from the concrete subclasses of this parent `abstract` derived type.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{form_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, abstract :: form_type
    end type

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a concrete derived type whose instances are exclusively used
    !>  to signify the unknown file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  Objects instantiated from this derived type are exclusively used to differentiate
    !>  the procedures within the various generic interfaces of the ParaMonte library.<br>
    !>  As such, this concrete derived type does not contain any attributes.<br>
    !>
    !>  \note
    !>  This concrete derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users should use the specific object parameter instance of this derived type
    !>  (e.g., [unknown](@ref pm_io::unknown)) as directed by the documentation of the specific procedure they intend to use.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{unknown_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, extends(form_type) :: unknown_type
    end type

    !>  \brief
    !>  This is a scalar `parameter` object of type [unknown_type](@ref pm_io::unknown_type) that is exclusively used
    !>  to signify the unknown file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  For example usage, see the documentation of the target procedure requiring this object.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{unknown}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(unknown_type), parameter :: unknown = unknown_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: unknown
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a concrete derived type whose instances are exclusively used
    !>  to signify the unformatted (binary) file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  Objects instantiated from this derived type are exclusively used to differentiate
    !>  the procedures within the various generic interfaces of the ParaMonte library.<br>
    !>  As such, this concrete derived type does not contain any attributes.<br>
    !>
    !>  \note
    !>  This concrete derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users should use the specific object parameter instance of this derived type
    !>  (e.g., [unformatted](@ref pm_io::unformatted)) as directed by the documentation of the specific procedure they intend to use.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{unformatted_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, extends(form_type) :: unformatted_type
    end type

    !>  \brief
    !>  This is a scalar `parameter` object of type [unformatted_type](@ref pm_io::unformatted_type) that is exclusively used
    !>  to signify the unformatted (binary) file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  For example usage, see the documentation of the target procedure requiring this object.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{unformatted}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(unformatted_type), parameter :: unformatted = unformatted_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: unformatted
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a concrete derived type whose instances are exclusively used
    !>  to signify the formatted file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  Objects instantiated from this derived type are exclusively used to differentiate
    !>  the procedures within the various generic interfaces of the ParaMonte library.<br>
    !>  As such, this concrete derived type does not contain any attributes.<br>
    !>
    !>  \note
    !>  This concrete derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users should use the specific object parameter instance of this derived type
    !>  (e.g., [formatted](@ref pm_io::formatted)) as directed by the documentation of the specific procedure they intend to use.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{formatted_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, extends(form_type) :: formatted_type
    end type

    !>  \brief
    !>  This is a scalar `parameter` object of type [formatted_type](@ref pm_io::formatted_type) that is exclusively used
    !>  to signify the formatted file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  For example usage, see the documentation of the target procedure requiring this object.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{formatted}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(formatted_type), parameter :: formatted = formatted_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: formatted
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a concrete derived type whose instances are exclusively used
    !>  to signify the CSV file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  Objects instantiated from this derived type are exclusively used to differentiate
    !>  the procedures within the various generic interfaces of the ParaMonte library.<br>
    !>  As such, this concrete derived type does not contain any attributes.<br>
    !>
    !>  \note
    !>  This concrete derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users should use the specific object parameter instance of this derived type
    !>  (e.g., [csv](@ref pm_io::csv)) as directed by the documentation of the specific procedure they intend to use.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{csv_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, extends(formatted_type) :: csv_type
    end type

    !>  \brief
    !>  This is a scalar `parameter` object of type [csv_type](@ref pm_io::csv_type) that is exclusively used
    !>  to signify the CSV file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  For example usage, see the documentation of the target procedure requiring this object.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{csv}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(csv_type), parameter :: csv = csv_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: csv
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a concrete derived type whose instances are exclusively used
    !>  to signify the Fortran-list-directed file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  Objects instantiated from this derived type are exclusively used to differentiate
    !>  the procedures within the various generic interfaces of the ParaMonte library.<br>
    !>  As such, this concrete derived type does not contain any attributes.<br>
    !>
    !>  \note
    !>  This concrete derived type is not meant to be directly accessed by the end users.<br>
    !>  Instead, the end users should use the specific object parameter instance of this derived type
    !>  (e.g., [fld](@ref pm_io::fld)) as directed by the documentation of the specific procedure they intend to use.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{fld_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type, extends(formatted_type) :: fld_type
    end type

    !>  \brief
    !>  This is a scalar `parameter` object of type [fld_type](@ref pm_io::fld_type) that is exclusively used
    !>  to signify the Fortran-list-directed file form within an interface of a procedure of the ParaMonte library.<br>
    !>
    !>  \details
    !>  For example usage, see the documentation of the target procedure requiring this object.<br>
    !>
    !>  \see
    !>  [csv](@ref pm_io::csv)<br>
    !>  [fld](@ref pm_io::fld)<br>
    !>  [unknown](@ref pm_io::unknown)<br>
    !>  [csv_type](@ref pm_io::csv_type)<br>
    !>  [fld_type](@ref pm_io::fld_type)<br>
    !>  [form_type](@ref pm_io::form_type)<br>
    !>  [formatted](@ref pm_io::formatted)<br>
    !>  [unformatted](@ref pm_io::unformatted)<br>
    !>  [unknown_type](@ref pm_io::unknown_type)<br>
    !>  [formatted_type](@ref pm_io::formatted_type)<br>
    !>  [unformatted_type](@ref pm_io::unformatted_type)<br>
    !>
    !>  \final{fld}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(fld_type), parameter :: fld = fld_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: fld
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!   >  \brief
!   >  Generate and return the maximum record length (`recl`) attribute of a `sequential` access file,
!   >  or a user-specified connected file (or unit).
!   >
!   >  \param[in]  file    :   The input scalar of type `character` of default kind \SK representing the
!   >                          path of a file whose `recl` is to be returned, if it is already opened.<br>
!   >                          (**optional**, must not be present if `unit` is present.)
!   >  \param[in]  unit    :   The input scalar of type `integer` of default kind \IK representing the
!   >                          unit of a file whose `recl` is to be returned, if it is already opened.<br>
!   >                          (**optional**, must not be present if `file` is present.)
!   >
!   >  \return
!   >  `recl`              :   The output scalar of type `integer` of default kind \IK representing the maximum record length of
!   >                          the file specified via the input `file` or `unit` arguments. If both `file` and `unit` are missing,
!   >                          then the `recl` of the a temporary `sequential` access file with `status = "scratch"` will be returned.
!   >
!   >  \interface{getRecl}
!   >  \code{.F90}
!   >
!   >      use pm_io, only: getRecl
!   >
!   >      recl = getRecl()
!   >      recl = getRecl(file)
!   >      recl = getRecl(unit)
!   >
!   >  \endcode
!   >
!   >  \remark
!   >  The default `recl` for a `sequential`-access `scratch` file is<br>
!   >      -#  `huge(0)` under the GNU Fortran compiler.
!   >      -#  `132` under the Intel Fortran compiler.
!   >
!   >  \impure
!   >
!   >  \elemental
!   >
!   >  \see
!   >  [getFileUnit](@ref pm_io::getFileUnit)<br>
!   >  [isPreconnected](@ref pm_io::isPreconnected)<br>
!   >
!   >  \example{getRecl}
!   >  \include{lineno} example/pm_io/getRecl/main.F90
!   >  \compile{getRecl}
!   >  \output{getRecl}
!   >  \include{lineno} example/pm_io/getRecl/main.out.F90
!   >  \test
!   >  [test_pm_io](@ref test_pm_io)
!   >
!   >  \final{getRecl}
!   >
!   >  \author
!   >  Amir Shahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
!    interface getRecl
!
!    impure elemental function getRecl() result(recl)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getRecl
!#endif
!        use pm_kind, only: IK
!        integer(IK)                     :: recl
!    end function
!
!    impure elemental function getReclFile(file) result(recl)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getReclFile
!#endif
!        use pm_kind, only: IK
!        character(*, SK), intent(in)    :: file
!        integer(IK)                     :: recl
!    end function
!
!    impure elemental function getReclUnit(unit) result(recl)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getReclUnit
!#endif
!        use pm_kind, only: IK
!        integer(IK)     , intent(in)    :: unit
!        integer(IK)                     :: recl
!    end function
!
!    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the [openArg_type](@ref pm_io::openArg_type) class containing
    !>  arguments that can be passed to the `open()` intrinsic Fortran statement.
    !>
    !>  \details
    !>  This type is merely meant to provide a convenient storage for file attributes that might be needed at the time of opening files for IO.<br>
    !>  This type is overloaded with `openArg_typer()` to verify the consistency of the structure components values.<br>
    !>  The following optional arguments of the `open()` statement are deliberately excluded from this derived type:<br>
    !>  <ol>
    !>      <li>    `newunit`   :   There is no need for a dedicated component with this name since it is only relevant to calling the `open()` statement.<br>
    !>      <li>    `err`       :   There is no need for a dedicated component with this name since it is rarely used in modern Fortran.<br>
    !>  </ol>
    !>
    !>  \interface{openArg_type}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: openArg_type
    !>      type(openArg_type) :: openArg
    !>
    !>      openArg = openArg_type  ( access        = access        &
    !>                              , action        = action        &
    !>                              , asynchronous  = asynchronous  &
    !>                              , blank         = blank         &
    !>                              , decimal       = decimal       &
    !>                              , delim         = delim         &
    !>                              , encoding      = encoding      &
    !>                              , form          = form          &
    !>                              , iostat        = iostat        &
    !>                              , pad           = pad           &
    !>                              , position      = position      &
    !>                              , recl          = recl          &
    !>                              , round         = round         &
    !>                              , sign          = sign          &
    !>                              , status        = status        &
    !>                              , unit          = unit          &
    !>                              , file          = file          &
    !>                              , iostat        = iostat        &
    !>                              , iomsg         = iomsg         &
    !>                              )
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  All ASCII English alphabets in the input `character` arguments to the constructor of the class must be **lower-case**.<br>
    !>  This is critical as the cases of characters are not converted within the constructor before comparisons are made.<br>
    !>  The lower-case version of the input arguments can be obtained by calling [getStrLower](@ref pm_strASCII::getStrLower)
    !>  or [setStrLower](@ref pm_strASCII::setStrLower).<br>
    !>
    !>  \remark
    !>  The default `recl` for a `sequential`-access `scratch` file is<br>
    !>      -#  `huge(0)` under the GNU Fortran compiler.<br>
    !>      -#  `132` under the Intel Fortran compiler.<br>
    !>
    !>  \see
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>
    !>  \example{openArg_type}
    !>  \include{lineno} example/pm_io/openArg_type/main.F90
    !>  \compilef{openArg_type}
    !>  \output{openArg_type}
    !>  \include{lineno} example/pm_io/openArg_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \bug
    !>  \status \unresolved
    !>  \source \ifort{< 2021.10.0 20230609}
    !>  \desc
    !>  The \ifort returns a runtime error in Microsoft WSL,
    !>  \code{.sh}
    !>      forrtl: severe (173): A pointer passed to DEALLOCATE points to an object that cannot be deallocated
    !>  \endcode
    !>  within the submodule procedure `isFalseAssertion()` which also persisted when the procedure was in the module.<br>
    !>  This happens only when the library is built with script flag `--mem heap` enabling heap allocation and only when specified with `--build release`.<br>
    !>  This implies the cause of the error likely has its roots in the compilers optimizations.<br>
    !>  It turns out that the root cause of the runtime error was the `optional` argument `iomsg` with `intent(inout)`.<br>
    !>  \remedy
    !>  The procedure `isFalseAssertion()` is now commented out and all error handlings are done painfully manually.<br>
    !>  However, this did not help as the same error persisted and the root cause was identified to be the `iomsg` argument.<br>
    !>  As such, this optional argument is now removed and the error message, if any, is returned in the output object component `iomsg`.<br>
    !>
    !>  \bug
    !>  \status \unresolved
    !>  \source \gfortran{< 12}
    !>  \desc
    !>  The \gfortran cannot compile interfaces with dummy arguments `character(:), intent(out), allocatable, optional`.<br>
    !>  This has created a redundancy for error handling in this procedure by requiring also to pass `iostat` to control the occurrence of an error.<br>
    !>  Without this bug, the allocation status of `iomsg` could have been used to signal no occurrence of error.<br>
    !>  \remedy
    !>  All `iomsg` arguments are now assumed-length strings.<br>
    !>
    !>  \final{openArg_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type :: openArg_type
        character(10,SK)                :: access       = SK_"sequential"           !<  \public A scalar `character`    of default kind \SK of length `10`  containing the `access`         attribute of the file: `"sequential"` (default), `"direct"`, `"stream"`
        character( 9,SK)                :: action       = SK_"readwrite"            !<  \public A scalar `character`    of default kind \SK of length `9`   containing the `action`         attribute of the file: `"readwrite"` (default), `"read"`, `"write"`
        character( 3,SK)                :: asynchronous = SK_"no"                   !<  \public A scalar `character`    of default kind \SK of length `3`   containing the `asynchronous`   attribute of the file: `"no"` (default), `"yes"`
        character( 4,SK)                :: blank        = SK_"null"                 !<  \public A scalar `character`    of default kind \SK of length `4`   containing the `blank`          attribute of the file: `"null"` (default), `"yes"`
        character( 5,SK)                :: decimal      = SK_"point"                !<  \public A scalar `character`    of default kind \SK of length `5`   containing the `decimal`        attribute of the file: `"point"` (default), `"comma"`
        character(10,SK)                :: delim        = SK_"none"                 !<  \public A scalar `character`    of default kind \SK of length `10`  containing the `delim`          attribute of the file: `"none"` (default), `"apostrophe"`, `"quote"`
        character( 7,SK)                :: encoding     = SK_"default"              !<  \public A scalar `character`    of default kind \SK of length `7`   containing the `encoding`       attribute of the file: `"default"` (default), `"utf-8"`
        character(11,SK)                :: form         = SK_"formatted"            !<  \public A scalar `character`    of default kind \SK of length `11`  containing the `delim`          attribute of the file: `"formatted"` (default), `"unformatted"`
        integer(IK)                     :: iostat       = 0_IK                      !<  \public A scalar `integer`      of default kind \IK                 containing the `iostat`         attribute of the file: default = `0_IK`. The processor sets it to a positive value if a runtime IO error occurs.
        character( 3,SK)                :: pad          = SK_"yes"                  !<  \public A scalar `character`    of default kind \SK of length `3`   containing the `pad`            attribute of the file: `"yes"` (default), `"no"`
        character( 6,SK)                :: position     = SK_"asis"                 !<  \public A scalar `character`    of default kind \SK of length `6`   containing the `position`       attribute of the file: `"asis"` (default), `"rewind"`, `"append"`
        integer(IK)                     :: recl         = huge(0_IK)                !<  \public A scalar `integer`      of default kind \IK                 containing the `recl`           attribute of the file. It is mandatory for direct access files.
        character(17,SK)                :: round        = SK_"processor_defined"    !<  \public A scalar `character`    of default kind \SK of length `17`  containing the `round`          attribute of the file: `"processor_defined"` (default), `"compatible"`, `"nearest"`, `"zero"`, `"down"`, `"up"`
        character(17,SK)                :: sign         = SK_"processor_defined"    !<  \public A scalar `character`    of default kind \SK of length `17`  containing the `sign`           attribute of the file: `"processor_defined"` (default), `"suppress"`, `"plus"`
        character( 7,SK)                :: status       = SK_"unknown"              !<  \public A scalar `character`    of default kind \SK of length `7`   containing the `status`         attribute of the file: `"unkown"` (default), `"scratch"`, `"replace"`, `"new"`, `"old"`
        integer(IK)                     :: unit         = -1_IK                     !<  \public A scalar `integer`      of default kind \IK                 containing the `unit`           attribute of the file. It is a negative number if set by the processor, otherwise it must be positive.
        character(:, SK), allocatable   :: iomsg                                    !<  \public A scalar `character`    of default kind \SK of length `:`   containing the error message if an error occurs.
        character(:, SK), allocatable   :: file                                     !<  \public A scalar `character`    of default kind \SK of length `:`   containing the file path.
    end type


    !>  \brief
    !>  Generate and return an object of class [openArg_type](@ref pm_io::openArg_type)
    !>  containing arguments that can be passed to the `open()` intrinsic Fortran statement.
    !>
    !>  \details
    !>  This is the constructor of the type [openArg_type](@ref pm_io::openArg_type) to verify the consistency of the structure components values.<br>
    !>  The following optional arguments of the `open()` statement are deliberately excluded from this derived type:<br>
    !>  <ol>
    !>      <li>    `newunit`   :   There is no need for a dedicated component with this name since it is only relevant to calling the `open()` statement.<br>
    !>      <li>    `err`       :   There is no need for a dedicated component with this name since it is rarely used in modern Fortran.<br>
    !>  </ol>
    !>
    !>  \param[in]      access          :   The input  scalar `character`   of default kind \SK containing the `access`        attribute of the file: `"sequential"` (default), `"direct"`, `"stream"`.<br>
    !>                                      (**optional**, default = `SK_"sequential"`)
    !>  \param[in]      action          :   The input  scalar `character`   of default kind \SK containing the `action`        attribute of the file: `"readwrite"` (default), `"read"`, `"write"`.<br>
    !>                                      (**optional**, default = `SK_"readwrite"`)
    !>  \param[in]      asynchronous    :   The input  scalar `character`   of default kind \SK containing the `asynchronous`  attribute of the file: `"no"` (default), `"yes"`.<br>
    !>                                      (**optional**, default = `SK_"no"`)
    !>  \param[in]      blank           :   The input  scalar `character`   of default kind \SK containing the `blank`         attribute of the file: `"null"` (default), `"yes"`.<br>
    !>                                      (**optional**, default = `SK_"null"`)
    !>  \param[in]      decimal         :   The input  scalar `character`   of default kind \SK containing the `decimal`       attribute of the file: `"point"` (default), `"comma"`.<br>
    !>                                      (**optional**, default = `SK_"point"`)
    !>  \param[in]      delim           :   The input  scalar `character`   of default kind \SK containing the `delim`         attribute of the file: `"none"` (default), `"apostrophe"`, `"quote"`.<br>
    !>                                      (**optional**, default = `SK_"none"`)
    !>  \param[in]      encoding        :   The input  scalar `character`   of default kind \SK containing the `encoding`      attribute of the file: `"default"` (default), `"utf-8"`.<br>
    !>                                      (**optional**, default = `SK_"default"`)
    !>  \param[in]      form            :   The input  scalar `character`   of default kind \SK containing the `delim`         attribute of the file: `"formatted"` (default), `"unformatted"`.<br>
    !>                                      (**optional**, default = `SK_"formatted"`)
    !>  \param[in]      pad             :   The input  scalar `character`   of default kind \SK containing the `pad`           attribute of the file: `"yes"` (default), `"no"`.<br>
    !>                                      (**optional**, default = `SK_"yes"`)
    !>  \param[in]      position        :   The input  scalar `character`   of default kind \SK containing the `position`      attribute of the file: `"asis"` (default), `"rewind"`, `"append"`.<br>
    !>                                      (**optional**, default = `SK_"asis"`)
    !>  \param[in]      recl            :   The input  scalar `integer`     of default kind \IK containing the `recl`          attribute of the file. It is mandatory for direct access files.<br>
    !>                                      (**optional**, default = ``. It can be specified **if and only if** the condition `access == SK_"sequential"` for the specified input argument `access`.)
    !>  \param[in]      round           :   The input  scalar `character`   of default kind \SK containing the `round`         attribute of the file: `"processor_defined"` (default), `"compatible"`, `"nearest"`, `"zero"`, `"down"`, `"up"`.<br>
    !>                                      (**optional**, default = `SK_"processor_defined"`)
    !>  \param[in]      sign            :   The input  scalar `character`   of default kind \SK containing the `sign`          attribute of the file: `"processor_defined"` (default), `"suppress"`, `"plus"`.<br>
    !>                                      (**optional**, default = `SK_"processor_defined"`)
    !>  \param[in]      status          :   The input  scalar `character`   of default kind \SK containing the `status`        attribute of the file: `"unkown"` (default), `"scratch"`, `"replace"`, `"new"`, `"old"`.<br>
    !>                                      (**optional**, default = `SK_"unknown"`)
    !>  \param[in]      unit            :   The input  scalar `integer`     of default kind \IK containing the `unit`          attribute of the file.<br>
    !>                                      It is a negative number if set by the processor, otherwise it must be positive.<br>
    !>                                      As per the Fortran standard, `-1` is reserved to represent a file that is not connected.<br>
    !>                                      Therefore, if `-1` is specified as input value, it will be overwritten with a random preconnected unit number.<br>
    !>                                      (**optional**, default = [getFileUnit()](@ref pm_io::getFileUnit))
    !>  \param[in]      file            :   The input  scalar `character`   of default kind \SK containing the file path.<br>
    !>                                      (**optional**. If missing, the `file` component of the output object remains unallocated.)
    !>  \param[out]     iostat          :   The output scalar `integer`     of default kind \IK.<br>
    !>                                      <ol>
    !>                                          <li>    If present and no error occurs, it is set to `0` on output.<br>
    !>                                          <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.<br>
    !>                                                  In such a case, the input `optional` argument `iomsg`, or if missing, the component `iomsg` of the output object of type [openArg_type](@ref pm_io::openArg_type)
    !>                                                  will be set to a descriptive message describing the nature of the error that has occurred.<br>
    !>                                          <li>    If missing and an error occurs, then the program halts by calling `error stop`
    !>                                                  followed by the relevant error message.<br>
    !>                                      </ol>
    !>                                      (**optional**.)
    !>  \param[inout]   iomsg           :   The input/output scalar `character` of default kind \SK whose length type parameter and its contents will be used to set that of the corresponding component of the output object.<br>
    !>                                      Additionally, if a runtime error occurs while constructing the output object, `iomsg` will be set to a descriptive message about the nature of the error occurred.<br>
    !>                                      (**optional**, default = `repeat(" ", LEN_IOMSG)` where [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is compile-time constant.)
    !>
    !>  \return
    !>  `openArg`                       :   The output scalar object of type [openArg_type](@ref pm_io::openArg_type) whose components
    !>                                      are set to the corresponding input values or otherwise set to an appropriate default value.
    !>
    !>  \interface{openArg_typer}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: openArg_type
    !>      type(openArg_type) :: openArg
    !>
    !>      openArg = openArg_type  ( access        = access        &
    !>                              , action        = action        &
    !>                              , asynchronous  = asynchronous  &
    !>                              , blank         = blank         &
    !>                              , decimal       = decimal       &
    !>                              , delim         = delim         &
    !>                              , encoding      = encoding      &
    !>                              , form          = form          &
    !>                              , pad           = pad           &
    !>                              , position      = position      &
    !>                              , recl          = recl          &
    !>                              , round         = round         &
    !>                              , sign          = sign          &
    !>                              , status        = status        &
    !>                              , unit          = unit          &
    !>                              , file          = file          &
    !>                              , iostat        = iostat        &
    !>                              , iomsg         = iomsg         &
    !>                              )
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  All ASCII English alphabets in the input `character` arguments to this procedure must be **lower-case**.<br>
    !>  This is critical as the cases of characters are not converted within the constructor before comparisons are made.<br>
    !>  The lower-case version of the input arguments can be obtained by calling [getStrLower](@ref pm_strASCII::getStrLower)
    !>  or [setStrLower](@ref pm_strASCII::setStrLower).<br>
    !>
    !>  \remark
    !>  If the input argument `unit` is missing, then the `unit` component of the output object is set to the unit of the specified `file` if it is present, exists, and is connected.<br>
    !>  Otherwise, the `unit` component is set to a unique positive number that is not already associated with any other connected file.<br>
    !>
    !>  \remark
    !>  The default `recl` for a `sequential`-access `scratch` file is<br>
    !>      -#  `huge(0)` under the GNU Fortran compiler.<br>
    !>      -#  `132` under the Intel Fortran compiler.<br>
    !>
    !>  \impure
    !>
    !>  \elemental
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>
    !>  \example{openArg_typer}
    !>  \include{lineno} example/pm_io/openArg_type/main.F90
    !>  \compilef{openArg_typer}
    !>  \output{openArg_typer}
    !>  \include{lineno} example/pm_io/openArg_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{openArg_typer}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface openArg_type
    impure elemental module function openArg_typer  ( access        &
                                                    , action        &
                                                    , asynchronous  &
                                                    , blank         &
                                                    , decimal       &
                                                    , delim         &
                                                    , encoding      &
                                                    , form          &
                                                    , pad           &
                                                    , position      &
                                                    , recl          &
                                                    , round         &
                                                    , sign          &
                                                    , status        &
                                                    , unit          &
                                                    , file          &
                                                    , iostat        &
                                                    , iomsg         &
                                                    ) result(openArg)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: openArg_typer
#endif
        character(*, SK), intent(in)    , optional  :: access
        character(*, SK), intent(in)    , optional  :: action
        character(*, SK), intent(in)    , optional  :: asynchronous
        character(*, SK), intent(in)    , optional  :: blank
        character(*, SK), intent(in)    , optional  :: decimal
        character(*, SK), intent(in)    , optional  :: delim
        character(*, SK), intent(in)    , optional  :: encoding
        character(*, SK), intent(in)    , optional  :: form
        character(*, SK), intent(in)    , optional  :: pad
        character(*, SK), intent(in)    , optional  :: position
        integer(IK)     , intent(in)    , optional  :: recl
        character(*, SK), intent(in)    , optional  :: round
        character(*, SK), intent(in)    , optional  :: sign
        character(*, SK), intent(in)    , optional  :: status
        integer(IK)     , intent(in)    , optional  :: unit
        character(*, SK), intent(in)    , optional  :: file
        character(*, SK), intent(inout) , optional  :: iomsg
        integer(IK)     , intent(out)   , optional  :: iostat
        type(openArg_type)                          :: openArg
    end function
    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return `.true.` if the input `file` (or `unit`) is connected to a `unit` (or `file`), and `.false.` otherwise.
    !>
    !>  \details
    !>  This generic functional interface is a simple convenience wrapper around the Fortran intrinsic `inquire()` statement.
    !>
    !>  \param[in]  unit    :   The input scalar, or array of arbitrary rank, of type `integer` of default kind \IK representing the file unit whose connection status is to be checked.<br>
    !>                          (**optional**, it must be present <b>if and only if</b> the input argument `file` is missing.)
    !>  \param[in]  file    :   The input scalar, or array of arbitrary rank, of type `character` of default kind \SK representing the file path whose connection status is to be checked.<br>
    !>                          (**optional**, it must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>
    !>  \return
    !>  `opened`            :   The output scalar, or array of same rank, shape, and size as the input array-like argument, of type `logical` of default kind \LK.<br>
    !>                          It is `.true.` <b>if and only if</b> the input `unit` or `file` is already connected (opened).<br>
    !>                          Otherwise, it is `.false.`.<br>
    !>
    !>  \interface{isOpen}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: isOpen
    !>      use pm_kind, only: LK
    !>      logical(LK) :: opened
    !>
    !>      opened = isOpen(unit)
    !>      opened = isOpen(file)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  This procedure does not gracefully handle unexpected runtime errors.<br>
    !>  If error handling is needed, use the Fortran intrinsic `inquire()` with arguments `iostat` and `iomsg` present.<br>
    !>
    !>  \impure
    !>
    !>  \elemental
    !>
    !>  \see
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>
    !>  \example{isOpen}
    !>  \include{lineno} example/pm_io/isOpen/main.F90
    !>  \compilef{isOpen}
    !>  \output{isOpen}
    !>  \include{lineno} example/pm_io/isOpen/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{isOpen}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface isOpen

    impure elemental module function isOpenUnit(unit) result(opened)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isOpenUnit
#endif
        integer(IK)     , intent(in)    :: unit
        logical(LK)                     :: opened
    end function

    impure elemental module function isOpenFile(file) result(opened)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isOpenFile
#endif
        character(*, SK), intent(in)    :: file
        logical(LK)                     :: opened
    end function

!    impure elemental module function isOpenUnitII(unit, iostat, iomsg) result(opened)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: isOpenUnitII
!#endif
!        integer(IK)     , intent(in)    :: unit
!        integer(IK)     , intent(out)   :: iostat
!        character(*, SK), intent(inout) :: iomsg
!        logical(LK)                     :: opened
!    end function
!
!    impure elemental module function isOpenFileII(file, iostat, iomsg) result(opened)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: isOpenFileII
!#endif
!        character(*, SK), intent(in)    :: file
!        integer(IK)     , intent(out)   :: iostat
!        character(*, SK), intent(inout) :: iomsg
!        logical(LK)                     :: opened
!    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the `action` attribute of the input `file` or `unit`.
    !>
    !>  \details
    !>  The `action` attribute of a connected `file` or `unit` is returned by the Fortran intrinsic `inquire()` statement.<br>
    !>  Possible values are, `"READ"`, `"WRITE"`, `"READWRITE"`. If there is no connection, the value returned is `"UNDEFINED"`.<br>
    !>
    !>  \param[in]  unit    :   The input scalar, or array of arbitrary rank, of type `integer` of default kind \IK representing the file unit whose `action` attribute is to be returned.<br>
    !>                          (**optional**, it must be present <b>if and only if</b> the input argument `file` is missing.)
    !>  \param[in]  file    :   The input scalar, or array of arbitrary rank, of type `character` of default kind \SK representing the file path whose `action` attribute is to be returned.<br>
    !>                          (**optional**, it must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>
    !>  \return
    !>  `action`            :   The output scalar, or array of same rank, shape, and size as the input array-like argument,
    !>                          of type `character` of default kind \SK of length type parameter `9`, containing the `action` attribute of the input `file` or `unit`.<br>
    !>                          If the length of the output value is less than `9`, it is left-adjusted and padded with blanks.<br>
    !>
    !>  \interface{getAction}
    !>  \code{.F90}
    !>
    !>      use pm_kind, only: SK
    !>      use pm_io, only: getAction
    !>      character(9, SK) :: action
    !>
    !>      action = getAction(unit)
    !>      action = getAction(file)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  This procedure does not gracefully handle unexpected runtime errors.<br>
    !>  If error handling is needed, use the Fortran intrinsic `inquire()` with arguments `iostat` and `iomsg` present.<br>
    !>
    !>  \impure
    !>
    !>  \elemental
    !>
    !>  \see
    !>  [isOpen](@ref pm_io::isOpen)<br>
    !>
    !>  \example{getAction}
    !>  \include{lineno} example/pm_io/getAction/main.F90
    !>  \compilef{getAction}
    !>  \output{getAction}
    !>  \include{lineno} example/pm_io/getAction/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{getAction}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface getAction

    impure elemental module function getActionUnit(unit) result(action)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getActionUnit
#endif
        integer(IK)     , intent(in)                :: unit
        character(9, SK)                            :: action
    end function

    impure elemental module function getActionFile(file) result(action)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getActionFile
#endif
        character(*, SK), intent(in)                :: file
        character(9, SK)                            :: action
    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the number of records in the <i>entire</i> **record-oriented** input file.
    !>
    !>  \details
    !>  If any error occurs during the IO and the output `iostat` argument is missing, the program will halt by calling `error stop`.<br>
    !>  Within the procedures,<br>
    !>  <ol>
    !>      <li>    If the input argument `file` is present, the file will be opened on input and closed before returning the control.<br>
    !>      <li>    If the input argument `unit` is present, the file is assumed to opened already, **will be rewound to the file beginning**,
    !>              and will be positioned after the last record in file **without being closed** on return.<br>
    !>  </ol>
    !>
    !>  See [getCountRecordLeft](@ref pm_io::getCountRecordLeft) for counting the number of records **left** in an already-opened file.<br>
    !>
    !>  \param[in]      file        :   The input scalar `character` of default kind \SK containing the file path, whose number of records will be returned.<br>
    !>                                  The input `file` <b>must not be connected</b> prior to calling this procedure.<br>
    !>                                  If the file is already connected, specify the file unit as input `unit` argument.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>  \param[in]      unit        :   The input scalar `integer` of default kind \IK containing the connected file unit, whose number of records will be returned.<br>
    !>                                  The input `unit` <b>must be connected</b> prior to calling this procedure.<br>
    !>                                  If the unit is not already connected, specify the file path as the input `file` argument.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>  \param          isCountable :   The `external` user-specified function that takes one input **scalar** `character` of default kind \SK of arbitrary length type parameter
    !>                                  containing the most recent record that has been read from the input file.<br>
    !>                                  It returns a scalar `logical` of default kind \LK that is `.true.` <b>if and only if</b> the input `record` should be included in counting.<br>
    !>                                  The following illustrates the generic interface of `isCountable`,
    !>                                  \code{.F90}
    !>                                      function isCountable(record) result(countable)
    !>                                          use pm_kind, only: LK, SK
    !>                                          character(*, SK), intent(in)    :: record
    !>                                          logical(LK)                     :: countable
    !>                                      end function
    !>                                  \endcode
    !>                                  This user-defined countability check is extremely useful where certain records in the file ought to be
    !>                                  excluded from counting or only records with specific patterns should be included (for example, excluding
    !>                                  or including only records that are empty or begin with or end with or have specific patterns).<br>
    !>                                  (**optional**. If missing, all records are included in counting.)
    !>  \param[in]      del         :   The input scalar `logical` of default kind \LK.<br>
    !>                                  <ol>
    !>                                      <li>    If `.true.`, the file will be deleted upon return.<br>
    !>                                      <li>    If `.false.`, the file will only be closed (without deletion) upon return.<br>
    !>                                  </ol>
    !>                                  (**optional**, default = `.false.`)
    !>  \param[out]     iostat      :   The **optional** output scalar `integer` of default kind \IK.<br>
    !>                                  <ol>
    !>                                      <li>    If present and no error occurs, it is set to `0` on output.<br>
    !>                                      <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.<br>
    !>                                      <li>    If missing and an error occurs, then the program halts by calling `error stop` followed by the relevant error message.<br>
    !>                                  </ol>
    !>                                  (**optional**.)
    !>  \param[inout]   iomsg       :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. Its presence is relevant only if the `iostat` output argument is also present.)
    !>
    !>  \return
    !>  `nrecord`                   :   The output scalar `integer` of default kind \IK, representing the number of records in the input file.
    !>
    !>  \interface{getCountRecord}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getCountRecord
    !>
    !>      nrecord = getCountRecord(file, isCountable = isCountable, del = del, iostat = iostat, iomsg = iomsg) ! file must not be connected.
    !>      nrecord = getCountRecord(unit, isCountable = isCountable, del = del, iostat = iostat, iomsg = iomsg) ! unit must be already connected. `rewind(unit)` will occur.
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The input `file` <b>must not be connected</b> prior to calling this procedure.<br>
    !>  The input `unit` <b>must be already connected</b> prior to calling this procedure.<br>
    !>  \vericons
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getCountRecordLeft](@ref pm_io::getCountRecordLeft)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{getCountRecord}
    !>  \include{lineno} example/pm_io/getCountRecord/main.F90
    !>  \compilef{getCountRecord}
    !>  \output{getCountRecord}
    !>  \include{lineno} example/pm_io/getCountRecord/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \todo
    !>  This procedure can be converted to a generic interface to add the optional `iseq()`
    !>  external comparison procedures for custom exclusion or inclusion of lines in the count.
    !>
    !>  \final{getCountRecord}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface getCountRecord

    module function getCountRecordFile(file, isCountable, del, iostat, iomsg) result(nrecord)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCountRecordFile
#endif
        use iso_fortran_env, only: iostat_end
        character(*, SK), intent(in)                    :: file
        procedure(logical(LK))          , optional      :: isCountable
        logical(LK)     , intent(in)    , optional      :: del
        integer(IK)     , intent(out)   , optional      :: iostat
        character(*, SK), intent(inout) , optional      :: iomsg
        integer(IK)                                     :: nrecord
    end function

    module function getCountRecordUnit(unit, isCountable, del, iostat, iomsg) result(nrecord)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCountRecordUnit
#endif
        use iso_fortran_env, only: iostat_end
        integer(IK)     , intent(in)                    :: unit
        procedure(logical(LK))          , optional      :: isCountable
        logical(LK)     , intent(in)    , optional      :: del
        integer(IK)     , intent(out)   , optional      :: iostat
        character(*, SK), intent(inout) , optional      :: iomsg
        integer(IK)                                     :: nrecord
    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the entire contents of the input unconnected `file` or the (remaining) contents of an already-connected file associated with the input `unit`.<br>
    !>
    !>  \param[in]  unit    :   The input scalar `integer` of default kind \IK containing the `unit` of an already-connected (opened) file whose (partial) contents will be returned.<br>
    !>                          (**optional**. It must be present <b>if and only if</b> the input argument `file` is missing.)
    !>  \param[in]  file    :   The input scalar `character` of default kind \SK containing the path of an unconnected (unopened) file whose entire contents will be returned.<br>
    !>                          (**optional**. It must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>  \param[in]  del     :   See the documentation for the corresponding argument of [setContentsFrom()](@ref pm_io::setContentsFrom).<br>
    !>                          (**optional**. The default behavior is set by [setContentsFrom()](@ref pm_io::setContentsFrom))
    !>
    !>  \return
    !>  `contents`          :   The output `allocatable` scalar `character` of default kind \SK that will contain the file contents.<br>
    !>                          The `allocation` status of `contents` or its value remain undefined if an error occurs.<br>
    !>
    !>  \interface{getContentsFrom}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getContentsFrom
    !>      character(:, SK), allocatable :: contents
    !>
    !>      contents = getContentsFrom(unit, del = del)
    !>      contents = getContentsFrom(file, del = del)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  All warnings associated with [setContentsFrom](@ref pm_io::setContentsFrom) also apply to the procedures under this generic interface.<br>
    !>
    !>  \warning
    !>  If the procedure fails to fetch the contents of the file, the program may stop by signaling the occurrence of an error.<br>
    !>  Use [setContentsFrom](@ref pm_io::setContentsFrom) for graceful error handling.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>
    !>  \example{getContentsFrom}
    !>  \include{lineno} example/pm_io/getContentsFrom/main.F90
    !>  \compilef{getContentsFrom}
    !>  \output{getContentsFrom}
    !>  \include{lineno} example/pm_io/getContentsFrom/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{getContentsFrom}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface getContentsFrom

    module function getContentsFromUnit_SK(unit, del) result(contents)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getContentsFromUnit_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        logical(LK)     , intent(in)    , optional      :: del
        character(:,SKG), allocatable                   :: contents
    end function

    module function getContentsFromFile_SK(file, del) result(contents)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getContentsFromFile_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK), intent(in)                    :: file
        logical(LK)     , intent(in)    , optional      :: del
        character(:,SKG), allocatable                   :: contents
    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Return the entire contents of the input unconnected `file` or the (remaining) contents of an already-connected file associated with the input `unit`.<br>
    !>
    !>  \param[in]      unit            :   The input scalar `integer` of default kind \IK containing the `unit` of an already-connected (opened) file whose (partial) contents will be returned.<br>
    !>                                      (**optional**. It must be present <b>if and only if</b> the input argument `file` is missing.)
    !>  \param[in]      file            :   The input scalar `character` of default kind \SK containing the path of an unconnected (unopened) file whose entire contents will be returned.<br>
    !>                                      (**optional**. It must be present <b>if and only if</b> the input argument `unit` is missing.)
    !>  \param[out]     contents        :   The output `allocatable` scalar `character` of default kind \SK that will contain the file contents.<br>
    !>                                      The `allocation` status of `contents` or its value remain undefined if an error occurs.<br>
    !>                                      **If `iostat` is present, always check the value of `iostat` before using `contents`.**
    !>  \param[in]      del             :   The input scalar `logical` of default kind \LK.
    !>                                      <ol>
    !>                                          <li>    If `.true.`, the file will be deleted upon return. This is guaranteed only **if no runtime error occurs**.
    !>                                          <li>    If `.false.`, the file will only be closed (without deletion) upon return.
    !>                                      </ol>
    !>                                      (**optional**, default = `.false.`)
    !>  \param[out]     iostat          :   The output scalar `integer` of default kind \IK.<br>
    !>                                      <ol>
    !>                                          <li>    If present and no error occurs, it is set to `0` on output.
    !>                                          <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.
    !>                                          <li>    If missing and an error occurs, then the program halts by calling `error stop` followed by the relevant error message.
    !>                                      </ol>
    !>                                      (**optional**. It must be present <b>if and only if</b> the output argument `iomsg` is also present.)
    !>  \param[inout]   iomsg           :   The input/output scalar `character` of default kind \SK of arbitrary length type parameter, containing the error message.<br>
    !>                                      A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages in full.<br>
    !>                                      (**optional**. It must be present <b>if and only if</b> the output argument `iostat` is also present.)
    !>
    !>  \interface{setContentsFrom}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: setContentsFrom
    !>      character(:, SK), allocatable :: contents
    !>
    !>      call setContentsFrom(unit, contents, del = del)
    !>      call setContentsFrom(file, contents, del = del)
    !>      call setContentsFrom(unit, contents, iostat, iomsg, del = del)
    !>      call setContentsFrom(file, contents, iostat, iomsg, del = del)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition [isOpen(unit)](@ref pm_io::isOpen) must hold for the corresponding input arguments.<br>
    !>  The condition [.not. isOpen(file)](@ref pm_io::isOpen) must hold for the corresponding input arguments.<br>
    !>  The condition `0 < index(getAction(unit), "READ")` must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>
    !>  \example{setContentsFrom}
    !>  \include{lineno} example/pm_io/setContentsFrom/main.F90
    !>  \compilef{setContentsFrom}
    !>  \output{setContentsFrom}
    !>  \include{lineno} example/pm_io/setContentsFrom/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{setContentsFrom}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface setContentsFrom

    module subroutine setContentsFromUnitCDD_SK(unit, contents, del)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsFromUnitCDD_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        character(:,SKG), intent(out)   , allocatable   :: contents
        logical(LK)     , intent(in)    , optional      :: del
    end subroutine

    module subroutine setContentsFromUnitCII_SK(unit, contents, iostat, iomsg, del)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsFromUnitCII_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        character(:,SKG), intent(out)   , allocatable   :: contents
        integer(IK)     , intent(out)                   :: iostat
        character(*, SK), intent(inout)                 :: iomsg
        logical(LK)     , intent(in)    , optional      :: del
    end subroutine

    module subroutine setContentsFromFileCDD_SK(file, contents, del)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsFromFileCDD_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK), intent(in)                    :: file
        character(:,SKG), intent(out)   , allocatable   :: contents
        logical(LK)     , intent(in)    , optional      :: del
    end subroutine

    module subroutine setContentsFromFileCII_SK(file, contents, iostat, iomsg, del)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsFromFileCII_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK), intent(in)                    :: file
        character(:,SKG), intent(out)   , allocatable   :: contents
        integer(IK)     , intent(out)                   :: iostat
        character(*, SK), intent(inout)                 :: iomsg
        logical(LK)     , intent(in)    , optional      :: del
    end subroutine

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Write the input string `contents` to the input unconnected `file`.<br>
    !>
    !>  \details
    !>  This generic interface in its current form is a simple wrapper around
    !>  the `open()` and `write()` intrinsic statements to simplify writing to output files.<br>
    !>
    !>  \param[in]      file            :   The input scalar `character` of default kind \SK containing the path of an unconnected (unopened) file.<br>
    !>  \param[in]      contents        :   The input scalar `character` of default kind \SK that containing the contents to write to the target external file.<br>
    !>  \param[out]     iostat          :   The output scalar `integer` of default kind \IK.<br>
    !>                                      <ol>
    !>                                          <li>    If present and no error occurs, it is set to `0` on output.
    !>                                          <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.
    !>                                          <li>    If missing and an error occurs, then the program halts by calling `error stop` followed by the relevant error message.
    !>                                      </ol>
    !>                                      (**optional**. It must be present <b>if and only if</b> the output argument `iomsg` is also present.)
    !>  \param[inout]   iomsg           :   The input/output scalar `character` of default kind \SK of arbitrary length type parameter, containing the error message.<br>
    !>                                      A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages in full.<br>
    !>                                      (**optional**. It must be present <b>if and only if</b> the output argument `iostat` is also present.)
    !>
    !>  \interface{setContentsTo}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: setContentsTo
    !>      character(:, SK), allocatable :: contents
    !>
    !>      call setContentsTo(file, contents = del)
    !>      call setContentsTo(file, contents, iostat, iomsg = del)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition [.not. isOpen(file)](@ref pm_io::isOpen) must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [getErrTableRead](@ref pm_io::getErrTableRead)<br>
    !>  [getErrTableWrite](@ref pm_io::getErrTableWrite)<br>
    !>
    !>  \example{setContentsTo}
    !>  \include{lineno} example/pm_io/setContentsTo/main.F90
    !>  \compilef{setContentsTo}
    !>  \output{setContentsTo}
    !>  \include{lineno} example/pm_io/setContentsTo/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \todo
    !>  \pmed
    !>  This generic interface must be expanded to input `unit` in place of an input `file`.<br>
    !>  There are potential complexities associated with an input `unit` that need `inquire` statement such as `access`, `form`, etc.<br>
    !>
    !>  \final{setContentsTo}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface setContentsTo

!    module subroutine setContentsToUnitCDD_SK(unit, contents)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsToUnitCDD_SK
!#endif
!        use pm_kind, only: SKG => SK
!        integer(IK)     , intent(in)                    :: unit
!        character(*,SKG), intent(in)                    :: contents
!    end subroutine
!
!    module subroutine setContentsToUnitCII_SK(unit, contents, iostat, iomsg)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsToUnitCII_SK
!#endif
!        use pm_kind, only: SKG => SK
!        integer(IK)     , intent(in)                    :: unit
!        character(*,SKG), intent(in)                    :: contents
!        integer(IK)     , intent(out)                   :: iostat
!        character(*, SK), intent(inout)                 :: iomsg
!    end subroutine

    module subroutine setContentsToFileCDD_SK(file, contents)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsToFileCDD_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK), intent(in)                    :: file
        character(*,SKG), intent(in)                    :: contents
    end subroutine

    module subroutine setContentsToFileCII_SK(file, contents, iostat, iomsg)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setContentsToFileCII_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK), intent(in)                    :: file
        character(*,SKG), intent(in)                    :: contents
        integer(IK)     , intent(out)                   :: iostat
        character(*, SK), intent(inout)                 :: iomsg
    end subroutine

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Open the given input file, fetch the entire contents return it as a single `allocatable` string, and close the file.
    !>
    !>  \param[out]     unit    :   The input scalar `integer` of default kind \IK containing the file unit number to close.<br>
    !>  \param[in]      del     :   The input scalar `logical` of default kind \LK.<br>
    !>                              <ol>
    !>                                  <li>    If `.true.`, the file will be deleted upon return.<br>
    !>                                  <li>    If `.false.`, the file will only be closed (without deletion) upon return.<br>
    !>                              </ol>
    !>                              (**optional**, default = `.false.`)
    !>  \param[out]     iostat  :   The output scalar `integer` of default kind \IK.<br>
    !>                              <ol>
    !>                                  <li>    If present and no error occurs, it is set to `0` on output.
    !>                                  <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.
    !>                                  <li>    If missing and an error occurs, then the program halts by calling `error stop` followed by the relevant error message.
    !>                              </ol>
    !>                              (**optional**.)
    !>  \param[inout]   iomsg   :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                              A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                              (**optional**. Its presence is relevant only if the `iostat` output argument is also present.)
    !>
    !>  \interface{setFileClosed}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: setFileClosed
    !>
    !>      call setFileClosed(unit, del = del, iostat = iostat, iomsg = iomsg)
    !>
    !>  \endcode
    !>
    !>  \note
    !>  As per the Fortran standard rules,
    !>      -#  if the specified file `unit` a non-existing or unconnected unit, then the `close()` statement acts as a *do nothing* statement (no error occurs).
    !>      -#  If the file connected to the `unit` has `scratch` status, then it will be automartically deleted regardless of the specified value for `del`.
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>
    !>  \example{setFileClosed}
    !>  \include{lineno} example/pm_io/setFileClosed/main.F90
    !>  \compilef{setFileClosed}
    !>  \output{setFileClosed}
    !>  \include{lineno} example/pm_io/setFileClosed/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{setFileClosed}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface setFileClosed
    module subroutine setFileClosed_IK(unit, del, iostat, iomsg)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setFileClosed_IK
#endif
        integer(IK)     , intent(in)                :: unit
        logical(LK)     , intent(in)    , optional  :: del
        integer(IK)     , intent(out)   , optional  :: iostat
        character(*, SK), intent(inout) , optional  :: iomsg
    end subroutine
    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return a full record (line) of arbitrary length as a string from the current
    !>  position of the **record-oriented** and **formatted** file connected to the specified input `unit`.
    !>
    !>  \param[in]      unit        :   The input scalar `integer` of default kind \IK representing the unit of the **connected file** to read the line from.<br>
    !>  \param[out]     iostat      :   The output scalar `integer` of default kind \IK.<br>
    !>                                  <ol>
    !>                                      <li>    If present and no error occurs, it is set to `0` on output.
    !>                                      <li>    If present and an end-of-file condition occurs, it is set to `iostat_end` from Fortran intrinsic module `iso_fortran_env`.<br>
    !>                                      <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.<br>
    !>                                      <li>    If missing and an error occurs (including end-of-file condition), then the program halts by calling `error stop` followed by the relevant error message.<br>
    !>                                  </ol>
    !>                                  (**optional**.)
    !>  \param[inout]   iomsg       :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. Its presence is relevant only if `iostat` is also present.)
    !>  \param[in]      linefed     :   The input scalar `logical` of default kind \LK.<br>
    !>                                  If `.true.`, then the output `record` will end with the new line character(s) as specified by the Fortran intrinsic `new_line("a")`.<br>
    !>                                  If `.false.`, then the output `record` will **not** end with the new line character(s).<br>
    !>                                  In either case, **only one record will be read** from the specified unit, but will or will
    !>                                  not end with a new line character if `linefed` is `.true.` or `.false.` respectively.<br>
    !>                                  This behavior is extremely useful for,
    !>                                  <ol>
    !>                                      <li>    reading records from a CSV file potentially containing new line characters in its fields.<br>
    !>                                      <li>    consecutively reading a series of lines of a `unit` into a single string by repeated calls to
    !>                                              this generic interface while preserving the linefeed characters as record separators.<br>
    !>                                  </ol>
    !>                                  (**optional**, default = `.false.`)
    !>
    !>  \return
    !>  `record`                    :   The output `allocatable` scalar `character` of default kind \SK that will contain the requested line in full.<br>
    !>                                  <b>If you suspect an end-of-file condition may occur, always specify and check the output value of `iostat` before using the contents of `record`</b>.<br>
    !>
    !>  \interface{getRecordFrom}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getRecordFrom
    !>      character(:, SK), allocatable :: record
    !>
    !>      record = getRecordFrom(unit, iostat = iostat, iomsg = iomsg, linefed = linefed)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  All warnings associated with [setRecordFrom](@ref pm_io::setRecordFrom) also apply to the procedures under this generic interface.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [setRecordFrom](@ref pm_io::setRecordFrom)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{getRecordFrom}
    !>  \include{lineno} example/pm_io/getRecordFrom/main.F90
    !>  \compilef{getRecordFrom}
    !>  \output{getRecordFrom}
    !>  \include{lineno} example/pm_io/getRecordFrom/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{getRecordFrom}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface getRecordFrom

    module function getRecordFromUnit_SK(unit, iostat, iomsg, linefed) result(record)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getRecordFromUnit_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        integer(IK)     , intent(out)   , optional      :: iostat
        character(*, SK), intent(inout) , optional      :: iomsg
        logical(LK)     , intent(in)    , optional      :: linefed
        character(:,SKG), allocatable                   :: record
    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Read a full record (line) of arbitrary length as a string from the current position of
    !>  the **record-oriented** and **formatted** file connected to the specified input `unit`.
    !>
    !>  \param[in]          unit    :   The input scalar `integer` of default kind \IK representing the unit of the **connected file** to read the line from.<br>
    !>  \param[inout]       record  :   The input/output `allocatable` scalar `character` of default kind \SK that will contain the requested line in full.<br>
    !>                                  On input,<br>
    !>                                  <ol>
    !>                                      <li>    The argument `record` can be preallocated to the best-guess length for the record to be read.<br>
    !>                                              Preallocating `record` to the right size can improve the runtime performance of the procedure.<br>
    !>                                              <ol>
    !>                                                  <li>    If the optional input argument `lb` is specified, any old contents `record(1 : lb - 1)` will remain intact on return.<br>
    !>                                              </ol>
    !>                                      <li>    The argument `record` can be unallocated, in which case, it will be allocated to the proper size within the algorithm.<br>
    !>                                  </ol>
    !>                                  On output,<br>
    !>                                  <ol>
    !>                                      <li>    The argument `record` will potentially be [resized](@ref pm_arrayResize::setResized) to contain the full record from the specified unit.<br>
    !>                                              <ol>
    !>                                                  <li>    If the optional output argument `ub` is specified, then the output `record` will **not** be trimmed (i.e., reallocated) on return.<br>
    !>                                                          Specifying `ub` will eliminate one redundant final reallocation and copy action, which can in return boost the runtime performance.<br>
    !>                                              </ol>
    !>                                  </ol>
    !>  \param[out]         iostat  :   The output scalar `integer` of default kind \IK.<br>
    !>                                  <ol>
    !>                                      <li>    If present and no error occurs, it is set to `0` on output.
    !>                                      <li>    If present and an end-of-file condition occurs, it is set to `iostat_end` from Fortran intrinsic module `iso_fortran_env`.<br>
    !>                                      <li>    If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.<br>
    !>                                      <li>    If missing and an error occurs (including end-of-file condition), then the program halts by calling `error stop` followed by the relevant error message.<br>
    !>                                  </ol>
    !>                                  (**optional**. It must be present <b>if and only if</b> the output argument `iomsg` is also present.)
    !>  \param[inout]       iomsg   :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> the output argument `iostat` is also present.)
    !>  \param[in]          lb      :   The **input** scalar `integer` of default kind \IK,
    !>                                  containing the lower starting bound (index) of `record` from which the writing must begin.<br>
    !>                                  Specifying this argument will keep the segment `record(1 : lb - 1)` intact on return.<br>
    !>                                  This behavior is extremely useful for consecutively reading a series of lines of a `unit`.<br>
    !>                                  (**optional**, default = `1`)
    !>  \param[out]         ub      :   The **output** scalar `integer` of default kind \IK,
    !>                                  containing the upper bound (index) of `record` up to which the record from the specified `unit` was read.<br>
    !>                                  Specifying this argument leads to faster runtime performance since it prevents an extra final reallocation and string copy.<br>
    !>                                  By definition, if the line in the file is empty, `ub` is set to `0`, unless `linefed` is set to `.true.`, in which case `ub` is the length of the linefeed character(s).<br>
    !>                                  (**optional**. If missing, `record` will be reallocated to size `record(1 : ub)`, otherwise, record will not be trimmed.)
    !>  \param[in]          linefed :   The input scalar `logical` of default kind \LK.<br>
    !>                                  If `.true.`, then the output `record` will end with the new line character(s) as specified by the Fortran intrinsic `new_line("a")`.<br>
    !>                                  If `.false.`, then the output `record` will **not** end with the new line character(s).<br>
    !>                                  In either case, **only one record will be read** from the specified unit, but will or will
    !>                                  not end with a new line character if `linefed` is `.true.` or `.false.` respectively.<br>
    !>                                  This behavior is extremely useful for,
    !>                                  <ol>
    !>                                      <li>    reading records from a CSV file potentially containing new line characters in its fields.<br>
    !>                                      <li>    consecutively reading a series of lines of a `unit` into a single string by repeated calls to
    !>                                              this generic interface while preserving the linefeed characters as record separators.<br>
    !>                                  </ol>
    !>                                  (**optional**, default = `.false.`)
    !>
    !>  \interface{setRecordFrom}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: setRecordFrom
    !>
    !>      call setRecordFrom(unit, record, lb = lb, ub = ub, linefed = linefed)
    !>      call setRecordFrom(unit, record, iostat, iomsg, lb = lb, ub = ub, linefed = linefed)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `0 < lb` must hold for the corresponding input arguments.
    !>  \vericon
    !>
    !>  \remark
    !>  Allowing the input `record` to be preallocated with `intent(inout)` particularly
    !>  helps with minimizing the number of reallocations of `record` within the procedure.<br>
    !>
    !>  \remark
    !>  Specifying the output argument `ub` particularly helps with the runtime performance
    !>  by removing a redundant reallocation and data copy.<br>
    !>
    !>  \note
    !>  This generic interface can be readily used to read a certain number or all of the lines of a specified `unit`.<br>
    !>  For example, the following code snippet,<br>
    !>  \code{.F90}
    !>
    !>      use iso_fortran_env, only: iostat_end
    !>      open(unit, file, status = "old")
    !>      lb = 1_IK
    !>      do
    !>          call setRecordFrom(unit, record, iostat, iomsg, lb, ub, linefed = .true._LK)
    !>          if (iostat /= iostat_end) exit
    !>          if (iostat /= 0_IK) error stop trim(iomsg)
    !>          lb = ub + 1_IK
    !>      end do
    !>      close(unit)
    !>      record = record(1:ub)
    !>
    !>  \endcode
    !>  will store the entire contents of the specified `file` associated with `unit` in the `allocatable` string `record`,
    !>  within which lines are separated by `new_line("a")` instances.<br>
    !>
    !>  \note
    !>  Note that setting `linefed = .true.` leads to each record being padded with a newline character, including the last line in the file.<br>
    !>  As such, reading an entire file using the above code snippet will lead to a final output that an has extra final newline character compared
    !>  to the output of [getContentsFrom()](@ref pm_io::getContentsFrom) or [setContentsFrom()](@ref pm_io::setContentsFrom).<br>
    !>
    !>  \see
    !>  [getRecordFrom](@ref pm_io::getRecordFrom)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{setRecordFrom}
    !>  \include{lineno} example/pm_io/setRecordFrom/main.F90
    !>  \compilef{setRecordFrom}
    !>  \output{setRecordFrom}
    !>  \include{lineno} example/pm_io/setRecordFrom/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{setRecordFrom}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface setRecordFrom

    module subroutine setRecordFromUR_SK(unit, record, lb, ub, linefed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setRecordFromUR_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        character(:,SKG), intent(inout) , allocatable   :: record
        integer(IK)     , intent(in)    , optional      :: lb
        integer(IK)     , intent(out)   , optional      :: ub
        logical(LK)     , intent(in)    , optional      :: linefed
    end subroutine

    module subroutine setRecordFromURII_SK(unit, record, iostat, iomsg, lb, ub, linefed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setRecordFromURII_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)     , intent(in)                    :: unit
        character(:,SKG), intent(inout) , allocatable   :: record
        integer(IK)     , intent(out)                   :: iostat
        character(*, SK), intent(inout)                 :: iomsg
        integer(IK)     , intent(in)    , optional      :: lb
        integer(IK)     , intent(out)   , optional      :: ub
        logical(LK)     , intent(in)    , optional      :: linefed
    end subroutine

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the number of records **left** (starting immediately after the last accessed record) in the **record-oriented** input file.
    !>
    !>  \details
    !>  If any error occurs during the IO and the output `iostat` argument is missing, the program will halt by calling `error stop`.
    !>
    !>  \param[in]      unit        :   The input scalar `integer` of default kind \IK containing the unit of the connected file whose number of record **left** is to be returned.
    !>  \param          isCountable :   The `external` user-specified function that takes one input **scalar** `character` of default kind \SK of arbitrary length type parameter,
    !>                                  containing the most recent record that has been read from the input file.<br>
    !>                                  It returns a scalar `logical` of default kind \LK that is `.true.` <b>if and only if</b> the input `record` should be included in counting.<br>
    !>                                  The following illustrates the generic interface of `isCountable`,
    !>                                  \code{.F90}
    !>                                      function isCountable(record) result(countable)
    !>                                          use pm_kind, only: LK, SK
    !>                                          character(*, SK), intent(in)    :: record
    !>                                          logical(LK)                     :: countable
    !>                                      end function
    !>                                  \endcode
    !>                                  This user-defined countability check is extremely useful where certain records in the file ought to be
    !>                                  excluded from counting or only records with specific patterns should be included (for example, excluding
    !>                                  or including only records that are empty or begin with or end with or have specific patterns).<br>
    !>                                  (**optional**. If missing, all records are included in counting).
    !>  \param[in]      reset       :   The input scalar `logical` of default kind \LK.
    !>                                  <ol>
    !>                                      <li>    If `.true.`, the record position in the file will be reset to where it was upon entering the procedure.
    !>                                      <li>    If `.false.`, the record position will be the end of the file.
    !>                                  </ol>
    !>                                  This option is useful for scenarios where a file has been partially read (e.g., fixed header),
    !>                                  but the number of remaining file records is required to read the rest of the file.<br>
    !>                                  This is done by calling the Fortran intrinsic `backspace` for `nrecord` number of times.<br>
    !>                                  Note that the `backspace` statement is often very costly in computer resources.<br>
    !>                                  Therefore this use of this optional argument should be minimized in performance critical routines.<br>
    !>                                  (**optional**, default = `.false.`)
    !>  \param[out]     iostat      :   The **optional** output scalar `integer` of default kind \IK.<br>
    !>                                      -#  If present and no error occurs, it is set to `0` on output.
    !>                                      -#  If present and an error occurs (e.g., if the input argument values are wrong or inconsistent), it is set to a positive non-zero value.
    !>                                      -#  If missing and an error occurs, then the program halts by calling `error stop` followed by the relevant error message.
    !>  \param[inout]   iomsg       :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. Its presence is relevant only if the `iostat` output argument is also present.)
    !>
    !>  \return
    !>  `nrecord`                   :   The output scalar `integer` of default kind \IK, representing the number of records in the input file.
    !>
    !>  \interface{getCountRecordLeft}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getCountRecordLeft
    !>
    !>      nrecord = getCountRecordLeft(file, isCountable = isCountable, reset = reset, iostat = iostat, iomsg = iomsg)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The input `unit` must be connected to a file prior to calling this procedure.<br>
    !>  Additionally, this procedure will **not** close the file upon return.<br>
    !>
    !>  \see
    !>  [getCountRecord](@ref pm_io::getCountRecord)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [setRecordFrom](@ref pm_io::setRecordFrom)<br>
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{getCountRecordLeft}
    !>  \include{lineno} example/pm_io/getCountRecordLeft/main.F90
    !>  \compilef{getCountRecordLeft}
    !>  \output{getCountRecordLeft}
    !>  \include{lineno} example/pm_io/getCountRecordLeft/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \todo
    !>  This procedure can be converted to a generic interface to add the optional `iseq()`
    !>  external comparison procedures for custom exclusion or inclusion of lines in the count.
    !>
    !>  \final{getCountRecordLeft}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface getCountRecordLeft
    module function getCountRecordLeft_IK(unit, isCountable, reset, iostat, iomsg) result(nrecord)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getCountRecordLeft_IK
#endif
        integer(IK)             , intent(in)                :: unit
        procedure(logical(LK))                  , optional  :: isCountable
        logical(LK)             , intent(in)    , optional  :: reset
        integer(IK)             , intent(out)   , optional  :: iostat
        character(*, SK)        , intent(inout) , optional  :: iomsg
        integer(IK)                                         :: nrecord
    end function
    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the `iostat` code resulting from reading the contents of the specified `file` or `unit` into an output `table`.<br>
    !>
    !>  \param[in]      file        :   The input scalar `character` of default kind \SK representing the path to the external file to which the `table` must be read.<br>
    !>                                  If the specified `file` does not exist, it will be created.<br>
    !>                                  If it exists or is already connected, it will repositioned before the beginning of its first record.<br>
    !>                                  (**optional**. It can be present **only if** the input argument `unit` is missing.)
    !>  \param[in]      unit        :   The input scalar `integer` of default kind \IK representing the preconnected (opened) file unit to which the table must be read.<br>
    !>                                  The writing will begin from the current file position plus the input `roff`.<br>
    !>                                  (**optional**. It can be present **only if** the input argument `file` is missing.)
    !>  \param[out]     table       :   The output `allocatable` array of shape `(:)` or `(:,:)` of either <br>
    !>                                  <ol>
    !>                                      <li>    type `character` of kind \SKALL of predefined length type parameter (not deferred-length), or <br>
    !>                                      <li>    type `integer` of kind \IKALL, or <br>
    !>                                      <li>    type `logical` of kind \LKALL, or <br>
    !>                                      <li>    type `complex` of kind \CKALL, or <br>
    !>                                      <li>    type `real` of kind \RKALL, <br>
    !>                                  </ol>
    !>                                  representing the data `table` to be read from the specified input.<br>
    !>                                  By default a `table` of rank `1` is considered to be a single column unless
    !>                                  the input optional argument `operation` is set to [trans](@ref pm_matrixTrans::trans) in which case `table` is considered as a row of fields.<br>
    !>                                  See the tips in the note below for reading tables of `complex` values written in the Fortran list-directed format.<br>
    !>                                  By default, if the input argument `operation` is missing, each column of `table` corresponds to each column of data in the file.<br>
    !>  \param[in]      operation   :   The input scalar constant that can be:<br>
    !>                                  <ol>
    !>                                      <li>    the scalar constant [trans](@ref pm_matrixTrans::trans) or a scalar object of type [trans_type](@ref pm_matrixTrans::trans_type),
    !>                                              implying that the input `table` must be transposed before being written to the output file.<br>
    !>                                              This option is particularly useful for inputting rows of `table` in Fortran column-major
    !>                                              storage mode, that is, rows of table occupy the first dimension of the matrix table
    !>                                              such that rows of data in the output file are stored contiguously in memory.<br>
    !>                                              Use this option if you intend to work with rows more so than with individual columns.<br>
    !>                                  </ol>
    !>                                  (**optional**, default = [nothing](@ref pm_array::nothing), implying that the `table` must be output as is.)
    !>  \param[out]     header      :   The output `allocatable` scalar `character` of default kind \SK of arbitrary length type parameter containing the table header.<br>
    !>                                  The output table `header` can be subsequently split into fields by passing `header` and `sep` to the generic interface [setSplit](@ref pm_arraySplit).<br>
    !>                                  If the table in file contains a header, but `header` argument is missing, then `roff` must be set to at least `1` to gracefully skip the header line.<br>
    !>                                  (**optional**, If missing, no header will be read from the specified input.<br>
    !>                                  The generic interface [getStr()](@ref pm_val2str::getStr) can be used to readily join a list of header fields with the appropriate separator.)
    !>  \param[in]      sep         :   The input scalar `character` of default kind \SK of arbitrary length type parameter
    !>                                  containing the separator of the fields of each of row of the `table` in the input file.<br>
    !>                                  An empty input `sep` implies that there is only a single column in the file.<br>
    !>                                  (**optional**, default = `,` or ` ` (blank).)
    !>  \param[in]      roff        :   The input scalar `integer` of default kind \IK representing the row offset, that is, the number of rows
    !>                                  in the external `file` or `unit` to skip before beginning to read the output variables `header` and `table`.<br>
    !>                                  (**optional**. default = `0`)
    !>  \param[inout]   iomsg       :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. If missing, no information other than the output error code `err` will be returned.)
    !>
    !>  \return
    !>  `err`                       :   The output scalar `integer` of default kind \IK containing the `iostat`
    !>                                  error code returned by the Fortran intrinsic `write()` statement.<br>
    !>                                  On return, `err` is set to `0` **if and only if** the `table` is successfully read from the input.<br>
    !>                                  See the Fortran standard and specific compiler documentations for the possible meanings of the output `err`.<br>
    !>
    !>  \interface{getErrTableRead}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getErrTableRead
    !>      use pm_kind, only: IK
    !>      integer(IK) :: err
    !>
    !>      err = getErrTableRead(unit, table, header = header, sep = sep, roff = roff, iomsg = iomsg)
    !>      err = getErrTableRead(file, table, header = header, sep = sep, roff = roff, iomsg = iomsg)
    !>
    !>      err = getErrTableRead(unit, table, operation, header = header, sep = sep, roff = roff, iomsg = iomsg)
    !>      err = getErrTableRead(file, table, operation, header = header, sep = sep, roff = roff, iomsg = iomsg)
    !>      !
    !>  \endcode
    !>
    !>  \impure
    !>
    !>  \note
    !>  For `table` of type `complex`, it is best to either<br>
    !>  <ol>
    !>      <li>    have the `complex` table fields in the file in Fortran list-directed format `(.,.)` and drop
    !>              the `sep` input argument to activate the default intrinsic [Fortran list-directed parser, or<br>
    !>      <li>    have the `complex` table fields in the file written as if `real` and `imaginary` components are
    !>              independent table fields and specify the `sep` argument to activate the customized parser to read the table.<br>
    !>  </ol>
    !>  Otherwise,<br>
    !>  <ol>
    !>      <li>    if the file is in [Fortran list-directed format](@ref pm_io::fld_type) and `sep` is present or,
    !>      <li>    if the file is in [csv format or similar](@ref pm_io::csv_type) and `sep` is missing,
    !>  </ol>
    !>  The table read action will fail.<br>
    !>  If so, the algorithm will try to read the `table` again by reading it with the
    !>  alternative parser before completely failing and returning a non-zero code.<br>
    !>
    !>  \devnote
    !>  The naming choice `sep` over `delim` or similar is deliberate.<br>
    !>  While many resources consider *separator* and *delimiter* identical, it is more sensible to consider *delimiter* as a character
    !>  set that determines what belong to a field, and *separator* as a character set that separates different fields from each other.<br>
    !>  This convention is also consistent with the Fortran standard terminology where delimiters are referred to as delimiters.<br>
    !>
    !>  \see
    !>  [getRecordFrom](@ref pm_io::getRecordFrom)<br>
    !>  [setRecordFrom](@ref pm_io::setRecordFrom)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [getErrTableRead](@ref pm_io::getErrTableRead)<br>
    !>  [getErrTableWrite](@ref pm_io::getErrTableWrite)<br>
    !>
    !>  \example{getErrTableRead}
    !>  \include{lineno} example/pm_io/getErrTableRead/main.F90
    !>  \compilef{getErrTableRead}
    !>  \output{getErrTableRead}
    !>  \include{lineno} example/pm_io/getErrTableRead/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \todo
    !>  \phigh
    !>  When the user-specified `sep` contains a value other than `" "` or `,`, the current implementation cannot handle
    !>  the presence of new line characters within string single or double quote delimited fields in output tables of type `character`.<br>
    !>  This limitation can be fixed by tracking the delimiters while reading the contents of `table`.<br>
    !>
    !>  \todo
    !>  \phigh
    !>  The `optional` input arguments `deliml` `delimr` must be added to allow parsing arbitrarily-delimited fields.<br>
    !>
    !>  \todo
    !>  \pmed
    !>  The behavior of this generic interface for empty tables is currently undefined, although the `err` code is non-zero.<br>
    !>  This should be fixed.<br>
    !>
    !>  \todo
    !>  \pmed
    !>  The non-intrinsic values for the output error code `err` must be standardized.<br>
    !>  Currently, the `err` is set to `-1` if an error occurs other than what is diagnosed by the compiler.<br>
    !>
    !>  \todo
    !>  \pmed
    !>  An `optional` input argument `del` must be added to optionally delete the input `file` or `unit` upon **successful** reading of the `table`.<br>
    !>
    !>  \todo
    !>  \pvhigh
    !>  In the current implementation, the behavior under an empty `sep` with `trans` option present is vague and untested.<br>
    !>  This must be clarified via testing and further improvements.<br>
    !>
    !>  \final{getErrTableRead}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin

    ! D1 file NO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadFile_NO_D1_SK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadFile_NO_D1_SK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadFile_NO_D1_SK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadFile_NO_D1_SK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadFile_NO_D1_SK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadFile_NO_D1_IK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadFile_NO_D1_IK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadFile_NO_D1_IK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadFile_NO_D1_IK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadFile_NO_D1_IK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadFile_NO_D1_LK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadFile_NO_D1_LK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadFile_NO_D1_LK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadFile_NO_D1_LK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadFile_NO_D1_LK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadFile_NO_D1_CK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadFile_NO_D1_CK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadFile_NO_D1_CK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadFile_NO_D1_CK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadFile_NO_D1_CK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadFile_NO_D1_RK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadFile_NO_D1_RK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadFile_NO_D1_RK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadFile_NO_D1_RK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadFile_NO_D1_RK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 file NO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadFile_NO_D2_SK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadFile_NO_D2_SK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadFile_NO_D2_SK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadFile_NO_D2_SK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadFile_NO_D2_SK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadFile_NO_D2_IK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadFile_NO_D2_IK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadFile_NO_D2_IK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadFile_NO_D2_IK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadFile_NO_D2_IK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadFile_NO_D2_LK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadFile_NO_D2_LK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadFile_NO_D2_LK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadFile_NO_D2_LK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadFile_NO_D2_LK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadFile_NO_D2_CK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadFile_NO_D2_CK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadFile_NO_D2_CK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadFile_NO_D2_CK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadFile_NO_D2_CK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadFile_NO_D2_RK5(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadFile_NO_D2_RK4(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadFile_NO_D2_RK3(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadFile_NO_D2_RK2(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadFile_NO_D2_RK1(file, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_NO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 unit NO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadUnit_NO_D1_SK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadUnit_NO_D1_SK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadUnit_NO_D1_SK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadUnit_NO_D1_SK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadUnit_NO_D1_SK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadUnit_NO_D1_IK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadUnit_NO_D1_IK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadUnit_NO_D1_IK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadUnit_NO_D1_IK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadUnit_NO_D1_IK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadUnit_NO_D1_LK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadUnit_NO_D1_LK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadUnit_NO_D1_LK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadUnit_NO_D1_LK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadUnit_NO_D1_LK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadUnit_NO_D1_CK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadUnit_NO_D1_CK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadUnit_NO_D1_CK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadUnit_NO_D1_CK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadUnit_NO_D1_CK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadUnit_NO_D1_RK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadUnit_NO_D1_RK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadUnit_NO_D1_RK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadUnit_NO_D1_RK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadUnit_NO_D1_RK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 unit NO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadUnit_NO_D2_SK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadUnit_NO_D2_SK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadUnit_NO_D2_SK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadUnit_NO_D2_SK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadUnit_NO_D2_SK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadUnit_NO_D2_IK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadUnit_NO_D2_IK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadUnit_NO_D2_IK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadUnit_NO_D2_IK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadUnit_NO_D2_IK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadUnit_NO_D2_LK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadUnit_NO_D2_LK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadUnit_NO_D2_LK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadUnit_NO_D2_LK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadUnit_NO_D2_LK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadUnit_NO_D2_CK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadUnit_NO_D2_CK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadUnit_NO_D2_CK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadUnit_NO_D2_CK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadUnit_NO_D2_CK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadUnit_NO_D2_RK5(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadUnit_NO_D2_RK4(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadUnit_NO_D2_RK3(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadUnit_NO_D2_RK2(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadUnit_NO_D2_RK1(unit, table, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_NO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 file TO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadFile_TO_D1_SK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadFile_TO_D1_SK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadFile_TO_D1_SK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadFile_TO_D1_SK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadFile_TO_D1_SK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadFile_TO_D1_IK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadFile_TO_D1_IK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadFile_TO_D1_IK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadFile_TO_D1_IK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadFile_TO_D1_IK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadFile_TO_D1_LK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadFile_TO_D1_LK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadFile_TO_D1_LK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadFile_TO_D1_LK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadFile_TO_D1_LK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadFile_TO_D1_CK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadFile_TO_D1_CK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadFile_TO_D1_CK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadFile_TO_D1_CK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadFile_TO_D1_CK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadFile_TO_D1_RK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadFile_TO_D1_RK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadFile_TO_D1_RK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadFile_TO_D1_RK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadFile_TO_D1_RK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 unit TO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadUnit_TO_D1_SK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadUnit_TO_D1_SK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadUnit_TO_D1_SK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadUnit_TO_D1_SK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadUnit_TO_D1_SK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadUnit_TO_D1_IK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadUnit_TO_D1_IK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadUnit_TO_D1_IK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadUnit_TO_D1_IK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadUnit_TO_D1_IK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadUnit_TO_D1_LK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadUnit_TO_D1_LK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadUnit_TO_D1_LK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadUnit_TO_D1_LK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadUnit_TO_D1_LK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadUnit_TO_D1_CK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadUnit_TO_D1_CK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadUnit_TO_D1_CK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadUnit_TO_D1_CK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadUnit_TO_D1_CK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadUnit_TO_D1_RK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadUnit_TO_D1_RK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadUnit_TO_D1_RK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadUnit_TO_D1_RK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadUnit_TO_D1_RK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 file TO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadFile_TO_D2_SK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadFile_TO_D2_SK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadFile_TO_D2_SK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadFile_TO_D2_SK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadFile_TO_D2_SK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadFile_TO_D2_IK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadFile_TO_D2_IK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadFile_TO_D2_IK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadFile_TO_D2_IK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadFile_TO_D2_IK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadFile_TO_D2_LK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadFile_TO_D2_LK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadFile_TO_D2_LK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadFile_TO_D2_LK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadFile_TO_D2_LK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadFile_TO_D2_CK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadFile_TO_D2_CK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadFile_TO_D2_CK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadFile_TO_D2_CK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadFile_TO_D2_CK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadFile_TO_D2_RK5(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadFile_TO_D2_RK4(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadFile_TO_D2_RK3(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadFile_TO_D2_RK2(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadFile_TO_D2_RK1(file, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadFile_TO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                                :: file
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 unit TO

    interface getErrTableRead

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableReadUnit_TO_D2_SK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableReadUnit_TO_D2_SK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableReadUnit_TO_D2_SK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableReadUnit_TO_D2_SK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableReadUnit_TO_D2_SK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableReadUnit_TO_D2_IK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableReadUnit_TO_D2_IK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableReadUnit_TO_D2_IK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableReadUnit_TO_D2_IK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableReadUnit_TO_D2_IK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableReadUnit_TO_D2_LK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableReadUnit_TO_D2_LK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableReadUnit_TO_D2_LK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableReadUnit_TO_D2_LK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableReadUnit_TO_D2_LK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableReadUnit_TO_D2_CK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableReadUnit_TO_D2_CK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableReadUnit_TO_D2_CK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableReadUnit_TO_D2_CK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableReadUnit_TO_D2_CK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableReadUnit_TO_D2_RK5(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableReadUnit_TO_D2_RK4(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableReadUnit_TO_D2_RK3(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableReadUnit_TO_D2_RK2(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableReadUnit_TO_D2_RK1(unit, table, operation, header, sep, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableReadUnit_TO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(out)   , allocatable               :: table(:,:)
        character(:, SK)            , intent(out)   , allocatable   , optional  :: header
        character(*, SK)            , intent(in)                    , optional  :: sep
        character(*, SK)            , intent(inout)                 , optional  :: iomsg
        type(trans_type)            , intent(in)                                :: operation
        integer(IK)                 , intent(in)                    , optional  :: roff
        integer(IK)                 , intent(in)                                :: unit
        integer(IK)                                                             :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the `iostat` code resulting from writing the input `table` of rank `1` or `2` to the specified output.<br>
    !>
    !>  \param[in]      file        :   The input scalar `character` of default kind \SK representing the path to the external file to which the `table` must be written.<br>
    !>                                  If the specified `file` does not exist, it will be created.<br>
    !>                                  If it exists or is already connected, it will repositioned before the beginning of its first record.<br>
    !>                                  (**optional**. It must be present **only if** the input argument `unit` is missing.)
    !>  \param[in]      unit        :   The input scalar `integer` of default kind \IK representing the preconnected (opened) file unit to which the table must be written.<br>
    !>                                  The writing will begin from the current file position plus the input `roff`.<br>
    !>                                  To write to stdout, `use iso_fortran_env, only: unit => output_unit`.<br>
    !>                                  (**optional**. It must be present **only if** the input argument `file` is missing.)
    !>  \param[in]      table       :   The input array of shape `(:)` or `(:,:)` of either <br>
    !>                                  <ol>
    !>                                      <li>    type `character` of kind \SKALL, or <br>
    !>                                      <li>    type `integer` of kind \IKALL, or <br>
    !>                                      <li>    type `logical` of kind \LKALL, or <br>
    !>                                      <li>    type `complex` of kind \CKALL, or <br>
    !>                                      <li>    type `real` of kind \RKALL, <br>
    !>                                  </ol>
    !>                                  representing the data `table` to write to the specified output.<br>
    !>                                  By default a `table` of rank `1` is considered to be a single column unless
    !>                                  the input optional argument `operation` is set to [trans](@ref pm_matrixTrans::trans) in which case `table` is considered as a row of fields.<br>
    !>                                  By default, if the input argument `operation` is missing, each column of `table` corresponds to each column of data in the file.<br>
    !>  \param[in]      operation   :   The input scalar constant that can be:<br>
    !>                                  <ol>
    !>                                      <li>    the scalar constant [trans](@ref pm_matrixTrans::trans) or a scalar object of type [trans_type](@ref pm_matrixTrans::trans_type),
    !>                                              implying that the input `table` must be transposed before being written to the output file.<br>
    !>                                              This option is particularly useful for outputting `table` that is in Fortran column-major
    !>                                              storage mode but has to be written in regular row-major format to the output.<br>
    !>                                  </ol>
    !>                                  (**optional**, default = [nothing](@ref pm_array::nothing), implying that the `table` must be output as is.)
    !>  \param[in]      header      :   The input scalar `character` of default kind \SK of arbitrary length type parameter containing the table header.<br>
    !>                                  It is recommended to delimit the header fields with the same input separator `sep`
    !>                                  to this generic interface to minimize difficulties with reading the table in the future.<br>
    !>                                  (**optional**, If missing, no header will be written to the specified output.
    !>                                  The generic interface [setSplit()](@ref pm_arraySplit::setSplit) can be used to readily generate a array of header field containers split at by the user-specified separator.)
    !>  \param[in]      sep         :   The input scalar `character` of default kind \SK of arbitrary length type parameter
    !>                                  containing the separator of the fields of each of row of the `table` in the output file.<br>
    !>                                  (**optional**, default = `,` corresponding to an output CSV file.)
    !>  \param[in]      deliml      :   The input scalar of type `character` of default kind \SK, of arbitrary length type parameter,
    !>                                  containing the left-delimiter to be used for delimiting (quoting) the left-side of the elements of `table` in the output file.<br>
    !>                                  The symbols \f$\texttt{"}\f$ and \f$\texttt{'}\f$ are the two most popular quotation mark choices that are recognized by both CSV and Fortran list-directed output forms.<br>
    !>                                  Unless there is a good reason, the use of delimiters for `table` of type other than `character` is not advised.<br>
    !>                                  (**optional**. default = `delimr` or if missing, no left-delimiter will be used.)
    !>  \param[in]      delimr      :   The input scalar of type `character` of default kind \SK, of arbitrary length type parameter,
    !>                                  containing the right-delimiter to be used for delimiting (quoting) the right-side of the elements of `table` in the output file.<br>
    !>                                  The symbols \f$\texttt{"}\f$ and \f$\texttt{'}\f$ are the two most popular quotation mark choices that are recognized by both CSV and Fortran list-directed output forms.<br>
    !>                                  Unless there is a good reason, the use of delimiters for `table` of type other than `character` is not advised.<br>
    !>                                  (**optional**. default = `deliml` or if missing, no right-delimiter will be used.)
    !>  \param[in]      roff        :   The input scalar `integer` of default kind \IK representing the row offset, that is, the number of rows
    !>                                  in the external `file` or `unit` to skip before beginning to read the output variables `header` and `table`.<br>
    !>                                  (**optional**. default = `0`)
    !>  \param[inout]   iomsg       :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                                  A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                                  (**optional**. If missing, no information other than the output error code `err` will be returned.)
    !>
    !>  \return
    !>  `err`                       :   The output scalar `integer` of default kind \IK containing the `iostat`
    !>                                  error code returned by the Fortran intrinsic `write()` statement.<br>
    !>                                  On return, `err` is set to `0` **if and only if** the `table` is successfully written to the output.<br>
    !>                                  See the Fortran standard and specific compiler documentations for the possible meanings of the output `err`.<br>
    !>
    !>  \interface{getErrTableWrite}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getErrTableWrite
    !>      use pm_kind, only: IK
    !>      integer(IK) :: err
    !>
    !>      err = getErrTableWrite(unit, table(1..2)           , header = header, sep = sep, deliml, delimr = deliml, delimr = delimr, roff = roff, iomsg = iomsg)
    !>      err = getErrTableWrite(file, table(1..2)           , header = header, sep = sep, deliml, delimr = deliml, delimr = delimr, roff = roff, iomsg = iomsg)
    !>      err = getErrTableWrite(unit, table(1..2), operation, header = header, sep = sep, deliml, delimr = deliml, delimr = delimr, roff = roff, iomsg = iomsg)
    !>      err = getErrTableWrite(file, table(1..2), operation, header = header, sep = sep, deliml, delimr = deliml, delimr = delimr, roff = roff, iomsg = iomsg)
    !>      !
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `isOpen(unit)` must hold for the corresponding input arguments.<br>
    !>  \vericon
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getRecordFrom](@ref pm_io::getRecordFrom)<br>
    !>  [setRecordFrom](@ref pm_io::setRecordFrom)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [getErrTableRead](@ref pm_io::getErrTableRead)<br>
    !>  [getErrTableWrite](@ref pm_io::getErrTableWrite)<br>
    !>
    !>  \example{getErrTableWrite}
    !>  \include{lineno} example/pm_io/getErrTableWrite/main.F90
    !>  \compilef{getErrTableWrite}
    !>  \output{getErrTableWrite}
    !>  \include{lineno} example/pm_io/getErrTableWrite/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{getErrTableWrite}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin

    ! D1 file NO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteFile_NO_D1_SK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteFile_NO_D1_SK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteFile_NO_D1_SK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteFile_NO_D1_SK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteFile_NO_D1_SK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteFile_NO_D1_IK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteFile_NO_D1_IK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteFile_NO_D1_IK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteFile_NO_D1_IK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteFile_NO_D1_IK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteFile_NO_D1_LK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteFile_NO_D1_LK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteFile_NO_D1_LK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteFile_NO_D1_LK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteFile_NO_D1_LK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteFile_NO_D1_CK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteFile_NO_D1_CK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteFile_NO_D1_CK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteFile_NO_D1_CK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteFile_NO_D1_CK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteFile_NO_D1_RK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteFile_NO_D1_RK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteFile_NO_D1_RK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteFile_NO_D1_RK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteFile_NO_D1_RK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 unit NO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteUnit_NO_D1_SK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteUnit_NO_D1_SK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteUnit_NO_D1_SK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteUnit_NO_D1_SK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteUnit_NO_D1_SK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteUnit_NO_D1_IK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteUnit_NO_D1_IK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteUnit_NO_D1_IK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteUnit_NO_D1_IK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteUnit_NO_D1_IK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteUnit_NO_D1_LK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteUnit_NO_D1_LK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteUnit_NO_D1_LK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteUnit_NO_D1_LK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteUnit_NO_D1_LK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteUnit_NO_D1_CK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteUnit_NO_D1_CK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteUnit_NO_D1_CK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteUnit_NO_D1_CK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteUnit_NO_D1_CK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteUnit_NO_D1_RK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteUnit_NO_D1_RK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteUnit_NO_D1_RK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteUnit_NO_D1_RK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteUnit_NO_D1_RK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 file NO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteFile_NO_D2_SK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteFile_NO_D2_SK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteFile_NO_D2_SK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteFile_NO_D2_SK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteFile_NO_D2_SK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteFile_NO_D2_IK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteFile_NO_D2_IK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteFile_NO_D2_IK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteFile_NO_D2_IK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteFile_NO_D2_IK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteFile_NO_D2_LK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteFile_NO_D2_LK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteFile_NO_D2_LK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteFile_NO_D2_LK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteFile_NO_D2_LK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteFile_NO_D2_CK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteFile_NO_D2_CK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteFile_NO_D2_CK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteFile_NO_D2_CK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteFile_NO_D2_CK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteFile_NO_D2_RK5(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteFile_NO_D2_RK4(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteFile_NO_D2_RK3(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteFile_NO_D2_RK2(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteFile_NO_D2_RK1(file, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_NO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 unit NO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteUnit_NO_D2_SK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteUnit_NO_D2_SK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteUnit_NO_D2_SK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteUnit_NO_D2_SK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteUnit_NO_D2_SK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteUnit_NO_D2_IK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteUnit_NO_D2_IK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteUnit_NO_D2_IK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteUnit_NO_D2_IK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteUnit_NO_D2_IK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteUnit_NO_D2_LK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteUnit_NO_D2_LK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteUnit_NO_D2_LK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteUnit_NO_D2_LK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteUnit_NO_D2_LK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteUnit_NO_D2_CK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteUnit_NO_D2_CK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteUnit_NO_D2_CK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteUnit_NO_D2_CK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteUnit_NO_D2_CK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteUnit_NO_D2_RK5(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteUnit_NO_D2_RK4(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteUnit_NO_D2_RK3(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteUnit_NO_D2_RK2(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteUnit_NO_D2_RK1(unit, table, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_NO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 file TO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteFile_TO_D1_SK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteFile_TO_D1_SK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteFile_TO_D1_SK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteFile_TO_D1_SK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteFile_TO_D1_SK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteFile_TO_D1_IK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteFile_TO_D1_IK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteFile_TO_D1_IK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteFile_TO_D1_IK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteFile_TO_D1_IK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteFile_TO_D1_LK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteFile_TO_D1_LK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteFile_TO_D1_LK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteFile_TO_D1_LK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteFile_TO_D1_LK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteFile_TO_D1_CK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteFile_TO_D1_CK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteFile_TO_D1_CK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteFile_TO_D1_CK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteFile_TO_D1_CK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteFile_TO_D1_RK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteFile_TO_D1_RK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteFile_TO_D1_RK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteFile_TO_D1_RK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteFile_TO_D1_RK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D1 unit TO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteUnit_TO_D1_SK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteUnit_TO_D1_SK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteUnit_TO_D1_SK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteUnit_TO_D1_SK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteUnit_TO_D1_SK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteUnit_TO_D1_IK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteUnit_TO_D1_IK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteUnit_TO_D1_IK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteUnit_TO_D1_IK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteUnit_TO_D1_IK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteUnit_TO_D1_LK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteUnit_TO_D1_LK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteUnit_TO_D1_LK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteUnit_TO_D1_LK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteUnit_TO_D1_LK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteUnit_TO_D1_CK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteUnit_TO_D1_CK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteUnit_TO_D1_CK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteUnit_TO_D1_CK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteUnit_TO_D1_CK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteUnit_TO_D1_RK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteUnit_TO_D1_RK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteUnit_TO_D1_RK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteUnit_TO_D1_RK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteUnit_TO_D1_RK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 file TO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteFile_TO_D2_SK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteFile_TO_D2_SK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteFile_TO_D2_SK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteFile_TO_D2_SK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteFile_TO_D2_SK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteFile_TO_D2_IK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteFile_TO_D2_IK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteFile_TO_D2_IK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteFile_TO_D2_IK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteFile_TO_D2_IK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteFile_TO_D2_LK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteFile_TO_D2_LK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteFile_TO_D2_LK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteFile_TO_D2_LK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteFile_TO_D2_LK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteFile_TO_D2_CK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteFile_TO_D2_CK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteFile_TO_D2_CK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteFile_TO_D2_CK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteFile_TO_D2_CK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteFile_TO_D2_RK5(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteFile_TO_D2_RK4(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteFile_TO_D2_RK3(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteFile_TO_D2_RK2(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteFile_TO_D2_RK1(file, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteFile_TO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: file, header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! D2 unit TO

    interface getErrTableWrite

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module function getErrTableWriteUnit_TO_D2_SK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK4_ENABLED
    module function getErrTableWriteUnit_TO_D2_SK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK3_ENABLED
    module function getErrTableWriteUnit_TO_D2_SK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK2_ENABLED
    module function getErrTableWriteUnit_TO_D2_SK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if SK1_ENABLED
    module function getErrTableWriteUnit_TO_D2_SK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)            , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module function getErrTableWriteUnit_TO_D2_IK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK4_ENABLED
    module function getErrTableWriteUnit_TO_D2_IK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK3_ENABLED
    module function getErrTableWriteUnit_TO_D2_IK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK2_ENABLED
    module function getErrTableWriteUnit_TO_D2_IK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if IK1_ENABLED
    module function getErrTableWriteUnit_TO_D2_IK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module function getErrTableWriteUnit_TO_D2_LK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK4_ENABLED
    module function getErrTableWriteUnit_TO_D2_LK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK3_ENABLED
    module function getErrTableWriteUnit_TO_D2_LK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK2_ENABLED
    module function getErrTableWriteUnit_TO_D2_LK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if LK1_ENABLED
    module function getErrTableWriteUnit_TO_D2_LK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module function getErrTableWriteUnit_TO_D2_CK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK4_ENABLED
    module function getErrTableWriteUnit_TO_D2_CK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK3_ENABLED
    module function getErrTableWriteUnit_TO_D2_CK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK2_ENABLED
    module function getErrTableWriteUnit_TO_D2_CK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if CK1_ENABLED
    module function getErrTableWriteUnit_TO_D2_CK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)                , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getErrTableWriteUnit_TO_D2_RK5(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK4_ENABLED
    module function getErrTableWriteUnit_TO_D2_RK4(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK3_ENABLED
    module function getErrTableWriteUnit_TO_D2_RK3(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK2_ENABLED
    module function getErrTableWriteUnit_TO_D2_RK2(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

#if RK1_ENABLED
    module function getErrTableWriteUnit_TO_D2_RK1(unit, table, operation, header, sep, deliml, delimr, roff, iomsg) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getErrTableWriteUnit_TO_D2_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)                   , intent(in)    , contiguous    :: table(:,:)
        character(*, SK)            , intent(in)    , optional      :: header, sep
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
        character(*, SK)            , intent(inout) , optional      :: iomsg
        type(trans_type)            , intent(in)                    :: operation
        integer(IK)                 , intent(in)    , optional      :: roff
        integer(IK)                 , intent(in)                    :: unit
        integer(IK)                                                 :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return the best-guess field separator of a (sequential-access) file stored in the input `file`.
    !>
    !>  \details
    !>  The current algorithm takes an input string from the user containing the set of best-guess single-character separators.<br>
    !>  It then counts the frequency of the separators in the **first two lines** from the current file position.<br>
    !>  If the file format is list-directed or [CSV](@ref pm_io::csv_type), the searcher will skip singly or doubly quoted strings in each line.<br>
    !>  The search will be also skipped into the next line if an opening quotation does not close within the same line (characteristic of CSV files).<br>
    !>  Finally, the first input separator whose frequency is the same in both lines is returned as the potential field separator of the file.<br>
    !>  At the end of the search, the file position is returned to the original point at entry to the file.
    !>
    !>  \param[in]      file    :   The input scalar `character` of default kind \SK containing the path to the file whose separator is to be inferred.<br>
    !>                              On input, the file position will be rewound to the starting point in the file and the file is closed upon return.<br>
    !>                              If search from a particular point in the file is desirable, open the file first and pass the file `unit` as input to this generic interface.<br>
    !>                              (**optional**. It must be present **if and only if** the input argument `unit` is missing.)
    !>  \param[in]      unit    :   The input scalar `integer` of default kind \IK containing the unit of the connected file whose separator is to be inferred.<br>
    !>                              (**optional**. It must be present **if and only if** the input argument `file` is missing.)
    !>  \param[in]      seps    :   The input object that can be,<br>
    !>                              <ol>
    !>                                  <li>    a scalar of type `character` of default kind \SK of arbitrary length type parameter,
    !>                                          **each character** of which will be considered as a potential field separator in the file records.<br>
    !>                                          This form of inputting `seps` is useful when all potential separators are single characters.<br>
    !>                                  <li>    a vector of type [css_type](@ref pm_container::css_type) container of arbitrary size,
    !>                                          **each element** of which will be considered as a potential field separator in the file records.<br>
    !>                                          This form of inputting `seps` is useful when the potential separators have differing length type parameters.<br>
    !>                                          If there is only one separator candidate, simply wrap the scalar container in
    !>                                          the Fortran intrinsic vector notation `[seps]` and pass it to the interface.<br>
    !>                                          In such a case, the output `sep` is either
    !>                                          <ol>
    !>                                              <li>    the input `seps` implying that `sep` is the potential separator in the file record, or
    !>                                              <li>    is an empty string implying that the input `seps` is not the record separator,
    !>                                                      or otherwise, an error occurred.<br>
    !>                              </ol>
    !>  \param[in]      form    :   The input scalar constant that can be any of the following:<br>
    !>                              <ol>
    !>                                  <li>    the constant [csv](@ref pm_io::csv) or an object of type [csv_type](@ref pm_io::csv_type),
    !>                                          implying that the contents quoted strings must be excluded from the search for the field separators.<br>
    !>                                  <li>    the constant [fld](@ref pm_io::fld) or an object of type [fld_type](@ref pm_io::fld_type),
    !>                                          implying that the contents quoted strings must be excluded from the search for the field separators.<br>
    !>                                          Additionally, any multiple adjacent appearances of (unquoted) blank characters will be counted as one separator instance.<br>
    !>                              </ol>
    !>                              (**optional**. default = [unknown](@ref pm_io::unknown))
    !>  \param[out]     nfield  :   The input scalar `integer` of default kind \IK containing the number of **fields**
    !>                              (i.e., the number of output `sep` instances per file record plus `1`) identified in each row of file, separated by the output separator.<br>
    !>                              If no separator is identified (i.e., the output `sep` is empty) and no runtime IO error occurs, the output value for `nfield` is `1`
    !>                              implying that there is only one field in the file record.<br>
    !>                              (**optional**.)
    !>  \param[inout]   iomsg   :   The input/output scalar `character` of default kind \SK containing the error message, if any error occurs.<br>
    !>                              A length type parameter value of [LEN_IOMSG](@ref pm_io::LEN_IOMSG) is generally sufficient for `iomsg` to contain the output error messages.<br>
    !>                              (**optional**. If missing, no information other than an empty output `sep` will be given if the algorithm fails.)
    !>
    !>  \return
    !>  `sep`                   :   The output `allocatable` scalar `character` of default kind \SK that will contain the inferred separator if the algorithm returns successfully.<br>
    !>                              Otherwise, the output `sep` will be set to an empty string if,<br>
    !>                              <ol>
    !>                                  <li>    the target file does not exist,
    !>                                  <li>    an IO error occurs while reading the file,
    !>                                  <li>    the algorithm fails to detect the separator.
    !>                              </ol>
    !>
    !>  \interface{getFieldSep}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getFieldSep
    !>      character(:, SK), allocatable :: sep
    !>
    !>      ! read from the current position in unit.
    !>
    !>      sep = getFieldSep(unit, seps, iomsg = iomsg)
    !>      sep = getFieldSep(unit, seps, form, iomsg = iomsg)
    !>      sep = getFieldSep(unit, seps, nfield, iomsg = iomsg)
    !>      sep = getFieldSep(unit, seps, form, nfield, iomsg = iomsg)
    !>
    !>      ! read from the starting position in file.
    !>
    !>      sep = getFieldSep(file, seps, iomsg = iomsg)
    !>      sep = getFieldSep(file, seps, form, iomsg = iomsg)
    !>      sep = getFieldSep(file, seps, nfield, iomsg = iomsg)
    !>      sep = getFieldSep(file, seps, form, nfield, iomsg = iomsg)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `0 < len(seps)` must hold for the corresponding input arguments.<br>
    !>  The condition `0 < size(seps)` must hold for the corresponding input arguments.<br>
    !>  The condition `all(0 < [(len(seps(i)%val), i = 1, size(seps))]` must hold for the corresponding input arguments.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [setRecordFrom](@ref pm_io::setRecordFrom)<br>
    !>  [getContentsFrom](@ref pm_io::getContentsFrom)<br>
    !>  [setContentsFrom](@ref pm_io::setContentsFrom)<br>
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{getFieldSep}
    !>  \include{lineno} example/pm_io/getFieldSep/main.F90
    !>  \compilef{getFieldSep}
    !>  \output{getFieldSep}
    !>  \include{lineno} example/pm_io/getFieldSep/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \todo
    !>  \pmed
    !>  An `optional` input argument `maxlenfield` must be added to return the maximum inferred length of a field in all records of the table.<br>
    !>  This option is potentially useful for parsing tables of string fields, where the proper field lengths is unknown a priori.<br>
    !>  Without this option, the `read` action may fail or otherwise, long fields would be truncated to fit the fixed length of `table` fields.<br>
    !>
    !>  \todo
    !>  \pmed
    !>  The `optional` input arguments `deliml` and `delimr` of rank `1` of type [css_type](@ref pm_container::css_type)
    !>  must be added to allow field recognition with arbitrary left/right delimiters within a record.<br>
    !>
    !>  \final{getFieldSep}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin

    ! seps scalar character scalar nfield missing XX

    interface getFieldSep

    module function getFieldSepFile_ID0_FDEF_XX_SK(file, seps, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FDEF_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_ID0_FDEF_XX_SK(unit, seps, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FDEF_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepFile_ID0_FCSV_XX_SK(file, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FCSV_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_ID0_FCSV_XX_SK(unit, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FCSV_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepFile_ID0_FFLD_XX_SK(file, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FFLD_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_ID0_FFLD_XX_SK(unit, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FFLD_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    end interface

    ! seps scalar character nfield present NF

    interface getFieldSep

    module function getFieldSepFile_ID0_FDEF_NF_SK(file, seps, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FDEF_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_ID0_FDEF_NF_SK(unit, seps, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FDEF_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepFile_ID0_FCSV_NF_SK(file, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FCSV_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_ID0_FCSV_NF_SK(unit, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FCSV_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepFile_ID0_FFLD_NF_SK(file, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_ID0_FFLD_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        character(*,SKG)    , intent(in)                :: seps
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_ID0_FFLD_NF_SK(unit, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_ID0_FFLD_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        character(*,SKG)    , intent(in)                :: seps
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    end interface

    ! seps scalar container scalar nfield missing XX

    interface getFieldSep

    module function getFieldSepFile_CD1_FDEF_XX_SK(file, seps, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FDEF_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_CD1_FDEF_XX_SK(unit, seps, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FDEF_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepFile_CD1_FCSV_XX_SK(file, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FCSV_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_CD1_FCSV_XX_SK(unit, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FCSV_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepFile_CD1_FFLD_XX_SK(file, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FFLD_XX_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    module function getFieldSepUnit_CD1_FFLD_XX_SK(unit, seps, form, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FFLD_XX_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
    end function

    end interface

    ! seps scalar container nfield present NF

    interface getFieldSep

    module function getFieldSepFile_CD1_FDEF_NF_SK(file, seps, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FDEF_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_CD1_FDEF_NF_SK(unit, seps, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FDEF_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepFile_CD1_FCSV_NF_SK(file, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FCSV_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_CD1_FCSV_NF_SK(unit, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FCSV_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        type(csv_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepFile_CD1_FFLD_NF_SK(file, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepFile_CD1_FFLD_NF_SK
#endif
        use pm_kind, only: SKG => SK
        character(*, SK)    , intent(in)                :: file
        type(css_type)      , intent(in)                :: seps(:)
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    module function getFieldSepUnit_CD1_FFLD_NF_SK(unit, seps, form, nfield, iomsg) result(sep)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFieldSepUnit_CD1_FFLD_NF_SK
#endif
        use pm_kind, only: SKG => SK
        integer(IK)         , intent(in)                :: unit
        type(css_type)      , intent(in)                :: seps(:)
        type(fld_type)      , intent(in)                :: form
        character(*,SKG)    , intent(inout) , optional  :: iomsg
        character(:,SKG)    , allocatable               :: sep
        integer(IK)         , intent(out)               :: nfield
    end function

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the derived type for constructing objects that contain the specifications of the [getStrWrapped](@ref pm_str::getStrWrapped)
    !>  dynamic method of objects of derived type [wrap_type](@ref pm_io::wrap_type).<br>
    !>
    !>  \details
    !>  See the documentation of [display_type](@ref pm_io::display_type) for further details and example usage.<br>
    !>
    !>  \param[in]  newline     :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  fill        :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  lwfill      :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  rwfill      :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  twfill      :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  bwfill      :   The input scalar of type `character` of default kind \SK of arbitrary length type parameter.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  lwsize      :   The input scalar `integer` of default kind \IK.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  rwsize      :   The input scalar `integer` of default kind \IK.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  twsize      :   The input scalar `integer` of default kind \IK.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  bwsize      :   The input scalar `integer` of default kind \IK.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  tmsize      :   The input scalar `integer` of default kind \IK representing the number of rows in the display to skip before printing the wrapped `str`.<br>
    !>                              (**optional**, default = `0_IK`)
    !>  \param[in]  bmsize      :   The input scalar `integer` of default kind \IK representing the number of rows in the display to skip after printing the wrapped `str`.<br>
    !>                              (**optional**, default = `0_IK`)
    !>  \param[in]  width       :   The input scalar `integer` of default kind \IK.<br>
    !>                              For details, see the description of the corresponding argument of the [wrap_type%%wrap](@ref pm_io::wrap) dynamic method of the derived type [display_type](@ref pm_io::display_type).<br>
    !>                              (**optional**. The default value is set as described in the documentation of the corresponding argument of [wrap_type%%wrap](@ref pm_io::wrap).)
    !>  \param[in]  unit        :   The input scalar `integer` of default kind \IK representing the output display unit number where the text will be displayed.<br>
    !>                              (**optional**, default = `output_unit` from `iso_fortran_env` intrinsic module.)
    !>  \param[in]  sticky      :   The input scalar of type `logical` of default kind \LK.<br>
    !>                              If `.true.`, the global properties (i.e., components) of the object of class [wrap_type](@ref pm_io::wrap_type)
    !>                              can be overridden by the corresponding arguments passed to the dynamic methods of the object.<br>
    !>                              (**optional**, default = `.false.`)
    !>
    !>  \interface{wrap_type}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: wrap_type
    !>      type(wrap_type) :: wrap
    !>
    !>      wrap = wrap_type( newline = newline   &
    !>                      , fill = fill         &
    !>                      , lwfill = lwfill     &
    !>                      , rwfill = rwfill     &
    !>                      , twfill = twfill     &
    !>                      , bwfill = bwfill     &
    !>                      , lwsize = lwsize     &
    !>                      , rwsize = rwsize     &
    !>                      , twsize = twsize     &
    !>                      , bwsize = bwsize     &
    !>                      , tmsize = tmsize     &
    !>                      , bmsize = bmsize     &
    !>                      , width = width       &
    !>                      , sticky = sticky     &
    !>                      )
    !>
    !>  \endcode
    !>
    !>  \devnote
    !>  The allocation status of the components is used as the actual argument presence within the derived type methods.<br>
    !>
    !>  \see
    !>  [wrap_type](@ref pm_io::wrap_type)<br>
    !>  [mark_type](@ref pm_err::mark_type)<br>
    !>  [note_type](@ref pm_err::note_type)<br>
    !>  [warn_type](@ref pm_err::warn_type)<br>
    !>  [stop_type](@ref pm_err::stop_type)<br>
    !>  [wrap_type%%wrap()](@ref pm_io::wrap)<br>
    !>  [display_type%%show()](@ref pm_io::show)<br>
    !>  [display_type%%skip()](@ref pm_io::skip)<br>
    !>  [display_type%%text](@ref pm_io::wrap_type)<br>
    !>  [getStrWrapped](@ref pm_str::getStrWrapped)<br>
    !>  [getCentered](@ref pm_arrayCenter::getCentered)<br>
    !>  [setCentered](@ref pm_arrayCenter::setCentered)<br>
    !>  [isFailedGetShellWidth](@ref pm_sysShell::isFailedGetShellWidth)<br>
    !>  [isFailedGetShellHeight](@ref pm_sysShell::isFailedGetShellHeight)<br>
    !>
    !>  \example{wrap_type}
    !>  \include{lineno} example/pm_io/wrap_type/main.F90
    !>  \compilef{wrap_type}
    !>  \output{wrap_type}
    !>  \include{lineno} example/pm_io/wrap_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{wrap_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type :: wrap_type
        character(:, SK), allocatable   , public    :: newline              !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        character(:, SK), allocatable   , public    :: fill                 !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        character(:, SK), allocatable   , public    :: lwfill               !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        character(:, SK), allocatable   , public    :: rwfill               !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        character(:, SK), allocatable   , public    :: twfill               !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        character(:, SK), allocatable   , public    :: bwfill               !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: lwsize = 2_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: rwsize = 2_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: twsize = 1_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: bwsize = 1_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: tmsize = 0_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: bmsize = 0_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: width = 96_IK        !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        integer(IK)                     , public    :: unit = output_unit   !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        logical(LK)                     , private   :: sticky = .false._LK  !<  \public See the description of the corresponding argument in the default constructor of [wrap_type](@ref pm_io::wrap_type).
        logical(LK)                     , private   :: uninit = .true._LK   !<  \public The scalar of type `logical` of default kind \LK that is `.true.` if and only if the object has not been initialized for the first time.
    contains
        !>  \cond excluded
#if     SK5_ENABLED
        procedure, pass, private                ::          wrap_D0_SK5
        generic                                 :: wrap =>  wrap_D0_SK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          wrap_D0_SK4
        generic                                 :: wrap =>  wrap_D0_SK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          wrap_D0_SK3
        generic                                 :: wrap =>  wrap_D0_SK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          wrap_D0_SK2
        generic                                 :: wrap =>  wrap_D0_SK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          wrap_D0_SK1
        generic                                 :: wrap =>  wrap_D0_SK1
#endif
        !>  \endcond excluded
    end type

    !>  \brief
    !>  This is a generic method of the derived type [display_type](@ref pm_io::display_type) with `pass` attribute.<br>
    !>
    !>  \details
    !>  This method centers the input string `str` within the specified `width`, adds margins as requested on all sides, then displays the wrapped string in the output display.<br>
    !>
    !>  \note
    !>  <ul>
    !>      <li>    The procedures under this generic interface **do not perform any wrapping** of the input text as done by [getStrWrapped](@ref pm_str::getStrWrapped).<br>
    !>      <li>    If needed, the input `str` must have been already wrapped via [getStrWrapped](@ref pm_str::getStrWrapped) with the desired input `newline`.<br>
    !>      <li>    The procedures under this generic interface only **sandwich each line** in the input `str` with the specified left and right margins, then display the wrapped (sandwiched) lines.<br>
    !>      <li>    If there are multiple lines within the input `str`, then they are all lef/right sandwiched in order, then displayed.<br>
    !>      <li>    If top/bottom margins are also specified, then the entire set of output sandwiched lines is also collectively sandwiched by a top and a bottom margin, then displayed.<br>
    !>  </ul>
    !>
    !>  \param[in]  str         :   The input scalar of type `character` of kind \SKALL that is to be wrapped (sandwiched).
    !>  \param[in]  newline     :   The input scalar of the same type and kind as the input `str` of arbitrary length type parameter,
    !>                              whose contents represent the dividing point between separate lines in the input `str` to display.<br>
    !>                              For example, if the string contains the C-style newline character \f$\ms{\n}\f$, then set \f$\ms{newline = '\\n'}\f$.<br>
    !>                              See also the documentation of the corresponding argument in [getStrWrapped](@ref pm_str::getStrWrapped).<br>
    !>                              (**optional**, default = `new_line(SKG_"a")` where `SKG` refers to the kind of `str`.)
    !>  \param[in]  fill        :   The input scalar of the same type and kind as the input `str` of length type parameter `len = 1`,
    !>                              containing the value to fill the area between the content and left/right wrap margin in each line of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `SKG_" "` where `SKG` is the kind of the input argument `str`.)
    !>  \param[in]  lwfill      :   The input scalar of the same type and kind as the input `str` of length type parameter `len = 1`,
    !>                              containing the value to fill the left wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = [MFILL](@ref pm_io::MFILL))
    !>  \param[in]  rwfill      :   The input scalar of the same type and kind as the input `str` of length type parameter `len = 1`,
    !>                              containing the value to fill the right wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = [MFILL](@ref pm_io::MFILL))
    !>  \param[in]  twfill      :   The input scalar of the same type and kind as the input `str` of length type parameter `len = 1`,
    !>                              containing the value to fill the top wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              (**optional**, default = [MFILL](@ref pm_io::MFILL))
    !>  \param[in]  bwfill      :   The input scalar of the same type and kind as the input `str` of length type parameter `len = 1`,
    !>                              containing the value to fill the bottom wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              (**optional**, default = [MFILL](@ref pm_io::MFILL))
    !>  \param[in]  lwsize      :   The input scalar `integer` of default kind \IK representing the size of the left wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `2_IK`)
    !>  \param[in]  rwsize      :   The input scalar `integer` of default kind \IK representing the size of the right wrap margin of each line of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `2_IK`)
    !>  \param[in]  twsize      :   The input scalar `integer` of default kind \IK representing the size of the top wrap margin of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `1_IK`)
    !>  \param[in]  bwsize      :   The input scalar `integer` of default kind \IK representing the size of the bottom wrap margin of the wrapped `str` in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `1_IK`)
    !>  \param[in]  tmsize      :   The input scalar `integer` of default kind \IK representing the number of rows in the display to skip before printing the wrapped `str` (i.e., the top margin).<br>
    !>                              (**optional**, default = `0_IK`)
    !>  \param[in]  bmsize      :   The input scalar `integer` of default kind \IK representing the number of rows in the display to skip after printing the wrapped `str` (i.e., the bottom margin).<br>
    !>                              (**optional**, default = `0_IK`)
    !>  \param[in]  width       :   The input scalar `integer` of default kind \IK representing the width of the contents of each wrapped line in the display.<br>
    !>                              For more details, see the documentation of the `size` argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              Note that the full length of each line in the display is `lwsize + width + rwsize`.
    !>                              (**optional**, default = `92_IK`)
    !>  \param[in]  unit        :   The input scalar `integer` of default kind \IK representing the output display unit number where the text will be displayed.<br>
    !>                              (**optional**, default = `display_type%%unit`)
    !>  \param[in]  sticky      :   The input scalar of type `logical` of default kind \LK.<br>
    !>                              If `.true.`, the global properties (i.e., components) of the object of class [wrap_type](@ref pm_io::wrap_type)
    !>                              can be overridden by the corresponding arguments passed to the dynamic methods of the object.<br>
    !>                              (**optional**, default = `.false.`)
    !>
    !>  \interface{wrap}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: wrap_type
    !>      type(wrap_type) :: text
    !>
    !>      call text%wrap( str                 &
    !>                    , newline = newline   &
    !>                    , fill = fill         &
    !>                    , lwfill = lwfill     &
    !>                    , rwfill = rwfill     &
    !>                    , twfill = twfill     &
    !>                    , bwfill = bwfill     &
    !>                    , lwsize = lwsize     &
    !>                    , rwsize = rwsize     &
    !>                    , twsize = twsize     &
    !>                    , bwsize = bwsize     &
    !>                    , tmsize = tmsize     &
    !>                    , bmsize = bmsize     &
    !>                    , width = width       &
    !>                    , unit = unit         &
    !>                    , sticky = sticky     &
    !>                    )
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  Any overflow of a single line beyond the specified `width` is handled as described in the documentation of [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>
    !>  \impure
    !>
    !>  \note
    !>  If the input `str` is potentially longer than the specified `width`, the overflowed text will be symmetrically cut from the beginning and the end of the `str`.<br>
    !>  To avoid this behavior, `str` can be first passed to [getStrWrapped](@ref pm_str::getStrWrapped) to wrap it within the desired `width`.<br>
    !>  The resulting `strWrapped` can be then passed to the procedures under this generic interface for centering, sandwiching, and displaying it.<br>
    !>  This avoids the usually unnecessary and costly wrapping of the input `str` with the specified `width` by this interface.
    !>
    !>  \see
    !>  [getStrWrapped](@ref pm_str::getStrWrapped)<br>
    !>  [getCentered](@ref pm_arrayCenter::getCentered)<br>
    !>  [setCentered](@ref pm_arrayCenter::setCentered)<br>
    !>  [isFailedGetShellWidth](@ref pm_sysShell::isFailedGetShellWidth)<br>
    !>  [isFailedGetShellHeight](@ref pm_sysShell::isFailedGetShellHeight)<br>
    !>
    !>  \example{wrap}
    !>  \include{lineno} example/pm_io/wrap_type/main.F90
    !>  \compilef{wrap}
    !>  \output{wrap}
    !>  \include{lineno} example/pm_io/wrap_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface wrap

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    impure module subroutine wrap_D0_SK5(self, str, newline, fill, lwfill, rwfill, twfill, bwfill, lwsize, rwsize, twsize, bwsize, tmsize, bmsize, width, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wrap_D0_SK5
#endif
        use pm_kind, only: SKG => SK5
        class(wrap_type)            , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: str
        character(*,SKG)            , intent(in)    , optional      :: newline
        character(1,SKG)            , intent(in)    , optional      :: fill, lwfill, rwfill, twfill, bwfill
        integer(IK)                 , intent(in)    , optional      :: lwsize, twsize, rwsize, bwsize
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize
        integer(IK)                 , intent(in)    , optional      :: width, unit
        logical(LK)                 , intent(in)    , optional      :: sticky
    end subroutine
#endif

#if SK4_ENABLED
    impure module subroutine wrap_D0_SK4(self, str, newline, fill, lwfill, rwfill, twfill, bwfill, lwsize, rwsize, twsize, bwsize, tmsize, bmsize, width, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wrap_D0_SK4
#endif
        use pm_kind, only: SKG => SK4
        class(wrap_type)            , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: str
        character(*,SKG)            , intent(in)    , optional      :: newline
        character(1,SKG)            , intent(in)    , optional      :: fill, lwfill, rwfill, twfill, bwfill
        integer(IK)                 , intent(in)    , optional      :: lwsize, twsize, rwsize, bwsize
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize
        integer(IK)                 , intent(in)    , optional      :: width, unit
        logical(LK)                 , intent(in)    , optional      :: sticky
    end subroutine
#endif

#if SK3_ENABLED
    impure module subroutine wrap_D0_SK3(self, str, newline, fill, lwfill, rwfill, twfill, bwfill, lwsize, rwsize, twsize, bwsize, tmsize, bmsize, width, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wrap_D0_SK3
#endif
        use pm_kind, only: SKG => SK3
        class(wrap_type)            , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: str
        character(*,SKG)            , intent(in)    , optional      :: newline
        character(1,SKG)            , intent(in)    , optional      :: fill, lwfill, rwfill, twfill, bwfill
        integer(IK)                 , intent(in)    , optional      :: lwsize, twsize, rwsize, bwsize
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize
        integer(IK)                 , intent(in)    , optional      :: width, unit
        logical(LK)                 , intent(in)    , optional      :: sticky
    end subroutine
#endif

#if SK2_ENABLED
    impure module subroutine wrap_D0_SK2(self, str, newline, fill, lwfill, rwfill, twfill, bwfill, lwsize, rwsize, twsize, bwsize, tmsize, bmsize, width, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wrap_D0_SK2
#endif
        use pm_kind, only: SKG => SK2
        class(wrap_type)            , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: str
        character(*,SKG)            , intent(in)    , optional      :: newline
        character(1,SKG)            , intent(in)    , optional      :: fill, lwfill, rwfill, twfill, bwfill
        integer(IK)                 , intent(in)    , optional      :: lwsize, twsize, rwsize, bwsize
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize
        integer(IK)                 , intent(in)    , optional      :: width, unit
        logical(LK)                 , intent(in)    , optional      :: sticky
    end subroutine
#endif

#if SK1_ENABLED
    impure module subroutine wrap_D0_SK1(self, str, newline, fill, lwfill, rwfill, twfill, bwfill, lwsize, rwsize, twsize, bwsize, tmsize, bmsize, width, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wrap_D0_SK1
#endif
        use pm_kind, only: SKG => SK1
        class(wrap_type)            , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: str
        character(*,SKG)            , intent(in)    , optional      :: newline
        character(1,SKG)            , intent(in)    , optional      :: fill, lwfill, rwfill, twfill, bwfill
        integer(IK)                 , intent(in)    , optional      :: lwsize, twsize, rwsize, bwsize
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize
        integer(IK)                 , intent(in)    , optional      :: width, unit
        logical(LK)                 , intent(in)    , optional      :: sticky
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return an object of type [display_type](@ref pm_io::display_type).
    !>
    !>  \details
    !>  The generated object can be used to show decorated string or other string
    !>  values on the standard output or an optionally-specified external file.
    !>
    !>  \param[in]  file        :   The input scalar of type `character` of default kind \SK, containing the path to the <b>un</b>connected external file to be opened and used as the display.<br>
    !>                              <ol>
    !>                                  <li>    If the `file` does not exist, it will be created, unless other behavior is dictated by the input `optional` argument `status`.<br>
    !>                                  <li>    If it exists, it will be closed and reopened and the file position will be set to the input `position` argument.<br>
    !>                              </ol>
    !>                              If present, the `unit` component of the output display object will be set to the unit of the connected `file`.<br>
    !>                              (**optional**. It can be present only if the input argument `unit` is missing.)
    !>  \param[in]  unit        :   The input scalar `integer` of default kind \IK representing the output display unit number where contents will be displayed.<br>
    !>                              If the specified `unit` is not connected, it will be connected to a temporary file with `status = "scratch"`.<br>
    !>                              (**optional**, default = `output_unit`. It can be present <b>only if</b> the input argument `file` is missing.)
    !>  \param[in]  status      :   The input scalar of type `character` of default kind \SK, whose contents represent the `status` of the input `file`.<br>
    !>                              It can take any value acceptable by the same argument to the Fortran intrinsic `open()` statement: `"old"`, `"replace"`, `"new"`, `"unknown"`, etc.<br>
    !>                              (**optional**, default = `SK_"old"` if the input `file` is already opened, otherwise `SK_"unknown"`. It can be present only if the input argument `file` is also present.)
    !>  \param[in]  position    :   The input scalar of type `character` of default kind \SK, whose contents represent the `position` of the input connected `file`.<br>
    !>                              It can take any value acceptable by the same argument to the Fortran intrinsic `open()` statement: `"asis"`, `"rewind"`, `"append"`, etc.<br>
    !>                              (**optional**, default = `SK_"append"` if the input `file` is already opened, otherwise `SK_"asis"`. It can be present only if the input argument `file` is also present.)
    !>  \param[in]  advance     :   The input scalar of type `character` of default kind \SK, whose contents represent the default `advance` mode of the IO.<br>
    !>                              The contents of `advance` are directly passed to the corresponding `advance` argument of the Fortran intrinsic `read()` or `write` procedures.<br>
    !>                              (**optional**, default = \f$\ms{SK_"YES"}\f$.)
    !>  \param[in]  format      :   The input scalar of type [field_type](@ref pm_io::field_type),
    !>                              whose components represent the **formats** to be used for the output records of various intrinsic types.<br>
    !>                              Note that the components of the input `format` are applied to each output `record`, that is, one output row.<br>
    !>                              The components of `format` are directly used as the `format` argument of the Fortran intrinsic `read()` and `write()` statements.<br>
    !>                              To simply the specification of mathematical display formats for complex values as in \f$u + v\up{i}\f$, the `complex` component of the input object of type [field_type](@ref pm_io::field_type) can be also set to `SK_"math"`.<br>
    !>                              In such a case, the math-style complex format [FORMAT_GENERIC_DISPLAY_COMPLEX_MATH](@ref pm_io::FORMAT_GENERIC_DISPLAY_COMPLEX_MATH) will be used for displaying `complex` valued objects.<br>
    !>                              See also the generic interface [getFormat](@ref pm_io::getFormat) for creating custom formats for objects of specific type and kind.<br>
    !>                              (**optional**, default = \f$\ms{"(sp,*(deliml,g0,', ',g0,delimr,:,', '))"}\f$ for `complex` fields and \f$\ms{"(sp,*(deliml,g0,delimr,:,', '))"}\f$ for all other field types,
    !>                              where `deliml` and `delimr` refer to the corresponding left and right fields delimiter components of the input arguments `deliml` and `delimr`.)
    !>  \param[in]  deliml      :   The input scalar of type [field_type](@ref pm_io::field_type),
    !>                              whose components represent the left-delimiters to be used for left-delimiting (wrapping) fields of various intrinsic types.<br>
    !>                              The two most common left-delimiters for strings are the single \f$\texttt{'}\f$ and double \f$\texttt{"}\f$ quotation marks.<br>
    !>                              The common Fortran-style left-delimiter for `complex` values is the left-parenthesis \f$\texttt{(}\f$.<br>
    !>                              The left-delimiter can be also set directly individually for objects of specific intrinsic types as an input argument to the relevant methods for displaying objects (e.g., [show()](@ref pm_io::show)).<br>
    !>                              Initializing the left-delimiters here, however, defines it globally for all relevant methods throughout the life of the current object of type [display_type](@ref pm_io::display_type).<br>
    !>                              Any component of the input `deliml` will be ignored in constructing the generic field formats, if the input argument `format` is present and its corresponding component is allocated.<br>
    !>                              (**optional**, default = `delimr` or if missing or any component is unallocated, `"("` for `field` of type `complex` and \f$\ms{""}\f$ (i.e., no left-delimiter) for all other `field` types.)
    !>  \param[in]  delimr      :   The input scalar of type [field_type](@ref pm_io::field_type),
    !>                              whose components represent the right-delimiters to be used for right-delimiting (wrapping) fields of various intrinsic types.<br>
    !>                              The two most common right-delimiters for strings are the single \f$\texttt{'}\f$ and double \f$\texttt{"}\f$ quotation marks.<br>
    !>                              The common Fortran-style right-delimiter for `complex` values is the right-parenthesis \f$\texttt{)}\f$.<br>
    !>                              The right-delimiter can be also set directly individually for objects of specific intrinsic types as an input argument to the relevant methods for displaying objects (e.g., [show()](@ref pm_io::show)).<br>
    !>                              Initializing the right-delimiters here, however, defines it globally for all relevant methods throughout the life of the current object of type [display_type](@ref pm_io::display_type).<br>
    !>                              Any component of the input `delimr` will be ignored in constructing the generic field formats, if the input argument `format` is present and its corresponding component is allocated.<br>
    !>                              (**optional**, default = `deliml` or if missing or any component is unallocated, `")"` for `field` of type `complex` and \f$\ms{""}\f$ (i.e., no right-delimiter) for all other `field` types.)
    !>  \param[in]  tmsize      :   The input scalar `integer` of default kind \IK representing the size of the top margin of any value that will be shown in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `0`)
    !>  \param[in]  bmsize      :   The input scalar `integer` of default kind \IK representing the size of the bottom margin of value that will be shown in the display.<br>
    !>                              For more details, see the documentation of the corresponding argument in [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>                              (**optional**, default = `0`)
    !>  \param[in]  count       :   The input scalar `integer` of default kind \IK representing the number of times each input value has to be displayed.
    !>                              (**optional**, default = `1`. It can be present <b>if and only if</b> the `optional` input argument `file` is missing.)
    !>  \param[in]  sticky      :   The input scalar of type `logical` of default kind \LK.<br>
    !>                              If `.true.`, the global properties (i.e., components) of the object of class [display_type](@ref pm_io::display_type)
    !>                              can be overridden by the corresponding arguments passed to the dynamic methods of the object.<br>
    !>                              (**optional**, default = `.false.`)
    !>  \param[in]  text        :   The input scalar of type [wrap_type](@ref pm_io::wrap_type) containing the runtime settings and a method to wrap strings within a fixed width.<br>
    !>                              (**optional**, default = `wrap_type(tmsize = disp%%tmsize, bmsize = disp%%bmsize, width = disp%%width, unit = disp%%unit, sticky = disp%%sticky)`)
    !>  \param[in]  mark        :   The input scalar of type [mark_type](@ref pm_err::mark_type) containing the runtime settings and a method to display remarks.<br>
    !>                              (**optional**, default = `mark_type(tmsize = disp%%tmsize, bmsize = disp%%bmsize, width = disp%%width, unit = disp%%unit, sticky = disp%%sticky)`)
    !>  \param[in]  note        :   The input scalar of type [note_type](@ref pm_err::note_type) containing the runtime settings and a method to display notification messages.<br>
    !>                              (**optional**, default = `note_type(tmsize = disp%%tmsize, bmsize = disp%%bmsize, width = disp%%width, unit = disp%%unit, sticky = disp%%sticky)`)
    !>  \param[in]  warn        :   The input scalar of type [warn_type](@ref pm_err::warn_type) containing the runtime settings and a method to display warning messages.<br>
    !>                              (**optional**, default = `warn_type(tmsize = disp%%tmsize, bmsize = disp%%bmsize, width = disp%%width, unit = disp%%unit, sticky = disp%%sticky)`)
    !>  \param[in]  stop        :   The input scalar of type [stop_type](@ref pm_err::stop_type) containing the runtime settings and a method to and stop the program and display program abortion messages.<br>
    !>                              (**optional**, default = `stop_type(tmsize = disp%%tmsize, bmsize = disp%%bmsize, width = disp%%width, unit = disp%%unit, sticky = disp%%sticky)`)
    !>
    !>  \interface{display_type}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: display_type
    !>      type(display_type) :: disp
    !>
    !>      disp = display_type( format = format        &
    !>                         , advance = advance      &
    !>                         , deliml = deliml        &
    !>                         , delimr = delimr        &
    !>                         , tmsize = tmsize        &
    !>                         , bmsize = bmsize        &
    !>                         , count = count          &
    !>                         , sticky = sticky        &
    !>                         , text = text            &
    !>                         , mark = mark            &
    !>                         , note = note            &
    !>                         , warn = warn            &
    !>                         , stop = stop            &
    !>                         )
    !>
    !>      ! The `unit` of an already opened (connected file). If not connected, will be connected to a `scratch` file.
    !>
    !>      disp = display_type( unit                   &
    !>                         , format = format        &
    !>                         , advance = advance      &
    !>                         , format = format        &
    !>                         , deliml = deliml        &
    !>                         , delimr = delimr        &
    !>                         , tmsize = tmsize        &
    !>                         , bmsize = bmsize        &
    !>                         , count = count          &
    !>                         , sticky = sticky        &
    !>                         , text = text            &
    !>                         , mark = mark            &
    !>                         , note = note            &
    !>                         , warn = warn            &
    !>                         , stop = stop            &
    !>                         )
    !>
    !>      ! The path to an external old or new `file`. If `file` is connected, it will be closed and reopened.
    !>
    !>      disp = display_type( file                   &
    !>                         , status = status        &
    !>                         , position = position    &
    !>                         , advance = advance      &
    !>                         , format = format        &
    !>                         , deliml = deliml        &
    !>                         , delimr = delimr        &
    !>                         , tmsize = tmsize        &
    !>                         , bmsize = bmsize        &
    !>                         , count = count          &
    !>                         , sticky = sticky        &
    !>                         , text = text            &
    !>                         , mark = mark            &
    !>                         , note = note            &
    !>                         , warn = warn            &
    !>                         , stop = stop            &
    !>                         )
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition [isValidStatus(status)](@ref pm_io::isValidStatus) must hold for the corresponding input arguments.<br>
    !>  The condition [isValidPosition(position)](@ref pm_io::isValidPosition) must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \warning
    !>  Any overflow of a single line beyond the specified `width` is handled as
    !>  described in the documentation of [getCentered](@ref pm_arrayCenter::getCentered).<br>
    !>
    !>  \warning
    !>  All components of this derived type are `protected` and **read-only**.<br>
    !>  However, all components are currently `public` until the `protected` attribute of Fortran 2023 is implemented by the compiler vendors.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [wrap_type%%wrap()](@ref pm_io::wrap)<br>
    !>  [display_type%%show()](@ref pm_io::show)<br>
    !>  [display_type%%skip()](@ref pm_io::skip)<br>
    !>  [getStrWrapped](@ref pm_str::getStrWrapped)<br>
    !>  [getCentered](@ref pm_arrayCenter::getCentered)<br>
    !>  [setCentered](@ref pm_arrayCenter::setCentered)<br>
    !>  [isFailedGetShellWidth](@ref pm_sysShell::isFailedGetShellWidth)<br>
    !>  [isFailedGetShellHeight](@ref pm_sysShell::isFailedGetShellHeight)<br>
    !>
    !>  \example{display_type}
    !>  \include{lineno} example/pm_io/display_type/main.F90
    !>  \compilef{display_type}
    !>  \output{display_type}
    !>  \include{lineno} example/pm_io/display_type/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \bug
    !>  \status \unresolved
    !>  \source \ifx{2024.0.0}
    !>  \desc
    !>  The \ifx{2024.0.0} memory sanitizer in debug compilation (with heap memory, serial shared library generation)
    !>  reports an uninitialized heap memory allocation usage where the constructor opens the specified input file.<br>
    !>  \code{.F90}
    !>      open(newunit = disp%unit, file = file, status = status_def, position = position_def)
    !>  \endcode
    !>  The cause of this error could not be identified, although the error can be bypassed by compiling in `release` mode.
    !>  \remedy
    !>  Currently none. This may need the attention of the Intel LLVM compiler developer team.
    !>
    !>  \todo
    !>  \pvhigh
    !>  The `public` attributes of all components of this derived type must be converted to `protected`
    !>  once the `protected` attribute of Fortran 2023 is supported by the Fortran compilers supported by the ParaMonte library.<br>
    !>
    !>  \final{display_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type                                            :: display_type
        logical(LK)                     , private   :: sticky = .false._LK  !<  \private    The scalar `logical` of default kind \LK. If `.true.` the relevant properties of the current object can be later changed by its methods.
        logical(LK)                     , private   :: uninit = .true._LK   !<  \private    The scalar `logical` of default kind \LK that is internally set to `.false.` once the object is constructed.<br>
                                                                            !!              The presence of this variable is to ensure seamless functioning of objects of [display_type](@ref pm_io::display_type)
                                                                            !!              when the user forgets to call the type constructor.<br>
                                                                            !!              The constructor call is critical for setting the allocatable components.<br>
        integer(IK)                     , public    :: width = -huge(0_IK)  !<  \public     The scalar `integer` of default kind \IK containing the width of the runtime Shell screen or `-huge(0_IK)` if the inference fails or the display is not the standard output `output_unit`.
        integer(IK)                     , public    :: height = -huge(0_IK) !<  \public     The scalar `integer` of default kind \IK containing the height of the runtime Shell screen or `-huge(0_IK)` if the inference fails or the display is not the standard output `output_unit`.
        integer(IK)                     , public    :: tmsize = 0_IK        !<  \public     The scalar `integer` of default kind \IK containing the number of records to skip on top of the current record.
        integer(IK)                     , public    :: count = 1_IK         !<  \public     The scalar `integer` of default kind \IK containing the number of times to repeat the current record.
        integer(IK)                     , public    :: bmsize = 0_IK        !<  \public     The scalar `integer` of default kind \IK containing the number of records to skip on the bottom of the current record.
        integer(IK)                     , public    :: unit = output_unit   !<  \public     The scalar `integer` of default kind \IK containing the unit number of the file to which the record must be written.
        character(3, SK)                , public    :: advance = SK_"YES"   !<  \public     The scalar `character` of default kind \SK containing the default IO `advance` mode for reading/writing actions.
        character(:, SK), allocatable   , public    :: file                 !<  \public     The scalar `character` of default kind \SK containing the file path to which the record must be written.
        type(field_type)                , public    :: format               !<  \public     The scalar `character` of default kind \SK containing the default IO format with which the records should be displayed.
        type(field_type)                , public    :: deliml               !<  \public     The scalar object of type [field_type](@ref pm_io::field_type) containing the left-delimiters for objects of various types.
        type(field_type)                , public    :: delimr               !<  \public     The scalar object of type [field_type](@ref pm_io::field_type) containing the right-delimiters for objects of various types.
        type(wrap_type)                 , public    :: text                 !<  \public     The scalar of type [wrap_type](@ref pm_io::wrap_type) containing the runtime settings and a method to wrap strings within a fixed width.
        type(mark_type)                 , public    :: mark                 !<  \public     The scalar of type [mark_type](@ref pm_err::mark_type) containing the runtime settings and a method to display remarks.
        type(note_type)                 , public    :: note                 !<  \public     The scalar of type [note_type](@ref pm_err::note_type) containing the runtime settings and a method to display notification messages.
        type(warn_type)                 , public    :: warn                 !<  \public     The scalar of type [warn_type](@ref pm_err::warn_type) containing the runtime settings and a method to display warning messages.
        type(stop_type)                 , public    :: stop                 !<  \public     The scalar of type [stop_type](@ref pm_err::stop_type) containing the runtime settings and a method to and stop the program and display program abortion messages.
        !> \cond excluded
    contains
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D0_SK5
        generic                                 :: show =>  show_D0_SK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D0_SK4
        generic                                 :: show =>  show_D0_SK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D0_SK3
        generic                                 :: show =>  show_D0_SK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D0_SK2
        generic                                 :: show =>  show_D0_SK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D0_SK1
        generic                                 :: show =>  show_D0_SK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D0_IK5
        generic                                 :: show =>  show_D0_IK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D0_IK4
        generic                                 :: show =>  show_D0_IK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D0_IK3
        generic                                 :: show =>  show_D0_IK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D0_IK2
        generic                                 :: show =>  show_D0_IK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D0_IK1
        generic                                 :: show =>  show_D0_IK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D0_LK5
        generic                                 :: show =>  show_D0_LK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D0_LK4
        generic                                 :: show =>  show_D0_LK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D0_LK3
        generic                                 :: show =>  show_D0_LK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D0_LK2
        generic                                 :: show =>  show_D0_LK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D0_LK1
        generic                                 :: show =>  show_D0_LK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D0_CK5
        generic                                 :: show =>  show_D0_CK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D0_CK4
        generic                                 :: show =>  show_D0_CK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D0_CK3
        generic                                 :: show =>  show_D0_CK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D0_CK2
        generic                                 :: show =>  show_D0_CK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D0_CK1
        generic                                 :: show =>  show_D0_CK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D0_RK5
        generic                                 :: show =>  show_D0_RK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D0_RK4
        generic                                 :: show =>  show_D0_RK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D0_RK3
        generic                                 :: show =>  show_D0_RK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D0_RK2
        generic                                 :: show =>  show_D0_RK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D0_RK1
        generic                                 :: show =>  show_D0_RK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D1_SK5
        generic                                 :: show =>  show_D1_SK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D1_SK4
        generic                                 :: show =>  show_D1_SK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D1_SK3
        generic                                 :: show =>  show_D1_SK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D1_SK2
        generic                                 :: show =>  show_D1_SK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D1_SK1
        generic                                 :: show =>  show_D1_SK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D1_IK5
        generic                                 :: show =>  show_D1_IK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D1_IK4
        generic                                 :: show =>  show_D1_IK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D1_IK3
        generic                                 :: show =>  show_D1_IK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D1_IK2
        generic                                 :: show =>  show_D1_IK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D1_IK1
        generic                                 :: show =>  show_D1_IK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D1_LK5
        generic                                 :: show =>  show_D1_LK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D1_LK4
        generic                                 :: show =>  show_D1_LK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D1_LK3
        generic                                 :: show =>  show_D1_LK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D1_LK2
        generic                                 :: show =>  show_D1_LK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D1_LK1
        generic                                 :: show =>  show_D1_LK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D1_CK5
        generic                                 :: show =>  show_D1_CK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D1_CK4
        generic                                 :: show =>  show_D1_CK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D1_CK3
        generic                                 :: show =>  show_D1_CK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D1_CK2
        generic                                 :: show =>  show_D1_CK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D1_CK1
        generic                                 :: show =>  show_D1_CK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D1_RK5
        generic                                 :: show =>  show_D1_RK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D1_RK4
        generic                                 :: show =>  show_D1_RK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D1_RK3
        generic                                 :: show =>  show_D1_RK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D1_RK2
        generic                                 :: show =>  show_D1_RK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D1_RK1
        generic                                 :: show =>  show_D1_RK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D2_SK5
        generic                                 :: show =>  show_D2_SK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D2_SK4
        generic                                 :: show =>  show_D2_SK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D2_SK3
        generic                                 :: show =>  show_D2_SK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D2_SK2
        generic                                 :: show =>  show_D2_SK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D2_SK1
        generic                                 :: show =>  show_D2_SK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D2_IK5
        generic                                 :: show =>  show_D2_IK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D2_IK4
        generic                                 :: show =>  show_D2_IK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D2_IK3
        generic                                 :: show =>  show_D2_IK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D2_IK2
        generic                                 :: show =>  show_D2_IK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D2_IK1
        generic                                 :: show =>  show_D2_IK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D2_LK5
        generic                                 :: show =>  show_D2_LK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D2_LK4
        generic                                 :: show =>  show_D2_LK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D2_LK3
        generic                                 :: show =>  show_D2_LK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D2_LK2
        generic                                 :: show =>  show_D2_LK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D2_LK1
        generic                                 :: show =>  show_D2_LK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D2_CK5
        generic                                 :: show =>  show_D2_CK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D2_CK4
        generic                                 :: show =>  show_D2_CK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D2_CK3
        generic                                 :: show =>  show_D2_CK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D2_CK2
        generic                                 :: show =>  show_D2_CK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D2_CK1
        generic                                 :: show =>  show_D2_CK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D2_RK5
        generic                                 :: show =>  show_D2_RK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D2_RK4
        generic                                 :: show =>  show_D2_RK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D2_RK3
        generic                                 :: show =>  show_D2_RK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D2_RK2
        generic                                 :: show =>  show_D2_RK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D2_RK1
        generic                                 :: show =>  show_D2_RK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     FORTRAN_ENABLED

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D3_SK5
        generic                                 :: show =>  show_D3_SK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D3_SK4
        generic                                 :: show =>  show_D3_SK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D3_SK3
        generic                                 :: show =>  show_D3_SK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D3_SK2
        generic                                 :: show =>  show_D3_SK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D3_SK1
        generic                                 :: show =>  show_D3_SK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D3_IK5
        generic                                 :: show =>  show_D3_IK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D3_IK4
        generic                                 :: show =>  show_D3_IK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D3_IK3
        generic                                 :: show =>  show_D3_IK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D3_IK2
        generic                                 :: show =>  show_D3_IK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D3_IK1
        generic                                 :: show =>  show_D3_IK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D3_LK5
        generic                                 :: show =>  show_D3_LK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D3_LK4
        generic                                 :: show =>  show_D3_LK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D3_LK3
        generic                                 :: show =>  show_D3_LK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D3_LK2
        generic                                 :: show =>  show_D3_LK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D3_LK1
        generic                                 :: show =>  show_D3_LK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D3_CK5
        generic                                 :: show =>  show_D3_CK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D3_CK4
        generic                                 :: show =>  show_D3_CK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D3_CK3
        generic                                 :: show =>  show_D3_CK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D3_CK2
        generic                                 :: show =>  show_D3_CK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D3_CK1
        generic                                 :: show =>  show_D3_CK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D3_RK5
        generic                                 :: show =>  show_D3_RK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D3_RK4
        generic                                 :: show =>  show_D3_RK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D3_RK3
        generic                                 :: show =>  show_D3_RK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D3_RK2
        generic                                 :: show =>  show_D3_RK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D3_RK1
        generic                                 :: show =>  show_D3_RK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#endif
!FORTRAN_ENABLED

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     PDT_ENABLED

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D0_PSSK5, show_D1_PSSK5, show_D2_PSSK5, show_D3_PSSK5
        generic                                 :: show =>  show_D0_PSSK5, show_D1_PSSK5, show_D2_PSSK5, show_D3_PSSK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D0_PSSK4, show_D1_PSSK4, show_D2_PSSK4, show_D3_PSSK4
        generic                                 :: show =>  show_D0_PSSK4, show_D1_PSSK4, show_D2_PSSK4, show_D3_PSSK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D0_PSSK3, show_D1_PSSK3, show_D2_PSSK3, show_D3_PSSK3
        generic                                 :: show =>  show_D0_PSSK3, show_D1_PSSK3, show_D2_PSSK3, show_D3_PSSK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D0_PSSK2, show_D1_PSSK2, show_D2_PSSK2, show_D3_PSSK2
        generic                                 :: show =>  show_D0_PSSK2, show_D1_PSSK2, show_D2_PSSK2, show_D3_PSSK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D0_PSSK1, show_D1_PSSK1, show_D2_PSSK1, show_D3_PSSK1
        generic                                 :: show =>  show_D0_PSSK1, show_D1_PSSK1, show_D2_PSSK1, show_D3_PSSK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D0_PSIK5, show_D1_PSIK5, show_D2_PSIK5, show_D3_PSIK5
        generic                                 :: show =>  show_D0_PSIK5, show_D1_PSIK5, show_D2_PSIK5, show_D3_PSIK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D0_PSIK4, show_D1_PSIK4, show_D2_PSIK4, show_D3_PSIK4
        generic                                 :: show =>  show_D0_PSIK4, show_D1_PSIK4, show_D2_PSIK4, show_D3_PSIK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D0_PSIK3, show_D1_PSIK3, show_D2_PSIK3, show_D3_PSIK3
        generic                                 :: show =>  show_D0_PSIK3, show_D1_PSIK3, show_D2_PSIK3, show_D3_PSIK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D0_PSIK2, show_D1_PSIK2, show_D2_PSIK2, show_D3_PSIK2
        generic                                 :: show =>  show_D0_PSIK2, show_D1_PSIK2, show_D2_PSIK2, show_D3_PSIK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D0_PSIK1, show_D1_PSIK1, show_D2_PSIK1, show_D3_PSIK1
        generic                                 :: show =>  show_D0_PSIK1, show_D1_PSIK1, show_D2_PSIK1, show_D3_PSIK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D0_PSLK5, show_D1_PSLK5, show_D2_PSLK5, show_D3_PSLK5
        generic                                 :: show =>  show_D0_PSLK5, show_D1_PSLK5, show_D2_PSLK5, show_D3_PSLK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D0_PSLK4, show_D1_PSLK4, show_D2_PSLK4, show_D3_PSLK4
        generic                                 :: show =>  show_D0_PSLK4, show_D1_PSLK4, show_D2_PSLK4, show_D3_PSLK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D0_PSLK3, show_D1_PSLK3, show_D2_PSLK3, show_D3_PSLK3
        generic                                 :: show =>  show_D0_PSLK3, show_D1_PSLK3, show_D2_PSLK3, show_D3_PSLK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D0_PSLK2, show_D1_PSLK2, show_D2_PSLK2, show_D3_PSLK2
        generic                                 :: show =>  show_D0_PSLK2, show_D1_PSLK2, show_D2_PSLK2, show_D3_PSLK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D0_PSLK1, show_D1_PSLK1, show_D2_PSLK1, show_D3_PSLK1
        generic                                 :: show =>  show_D0_PSLK1, show_D1_PSLK1, show_D2_PSLK1, show_D3_PSLK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D0_PSCK5, show_D1_PSCK5, show_D2_PSCK5, show_D3_PSCK5
        generic                                 :: show =>  show_D0_PSCK5, show_D1_PSCK5, show_D2_PSCK5, show_D3_PSCK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D0_PSCK4, show_D1_PSCK4, show_D2_PSCK4, show_D3_PSCK4
        generic                                 :: show =>  show_D0_PSCK4, show_D1_PSCK4, show_D2_PSCK4, show_D3_PSCK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D0_PSCK3, show_D1_PSCK3, show_D2_PSCK3, show_D3_PSCK3
        generic                                 :: show =>  show_D0_PSCK3, show_D1_PSCK3, show_D2_PSCK3, show_D3_PSCK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D0_PSCK2, show_D1_PSCK2, show_D2_PSCK2, show_D3_PSCK2
        generic                                 :: show =>  show_D0_PSCK2, show_D1_PSCK2, show_D2_PSCK2, show_D3_PSCK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D0_PSCK1, show_D1_PSCK1, show_D2_PSCK1, show_D3_PSCK1
        generic                                 :: show =>  show_D0_PSCK1, show_D1_PSCK1, show_D2_PSCK1, show_D3_PSCK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D0_PSRK5, show_D1_PSRK5, show_D2_PSRK5, show_D3_PSRK5
        generic                                 :: show =>  show_D0_PSRK5, show_D1_PSRK5, show_D2_PSRK5, show_D3_PSRK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D0_PSRK4, show_D1_PSRK4, show_D2_PSRK4, show_D3_PSRK4
        generic                                 :: show =>  show_D0_PSRK4, show_D1_PSRK4, show_D2_PSRK4, show_D3_PSRK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D0_PSRK3, show_D1_PSRK3, show_D2_PSRK3, show_D3_PSRK3
        generic                                 :: show =>  show_D0_PSRK3, show_D1_PSRK3, show_D2_PSRK3, show_D3_PSRK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D0_PSRK2, show_D1_PSRK2, show_D2_PSRK2, show_D3_PSRK2
        generic                                 :: show =>  show_D0_PSRK2, show_D1_PSRK2, show_D2_PSRK2, show_D3_PSRK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D0_PSRK1, show_D1_PSRK1, show_D2_PSRK1, show_D3_PSRK1
        generic                                 :: show =>  show_D0_PSRK1, show_D1_PSRK1, show_D2_PSRK1, show_D3_PSRK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D0_PVSK5, show_D1_PVSK5, show_D2_PVSK5
        generic                                 :: show =>  show_D0_PVSK5, show_D1_PVSK5, show_D2_PVSK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D0_PVSK4, show_D1_PVSK4, show_D2_PVSK4
        generic                                 :: show =>  show_D0_PVSK4, show_D1_PVSK4, show_D2_PVSK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D0_PVSK3, show_D1_PVSK3, show_D2_PVSK3
        generic                                 :: show =>  show_D0_PVSK3, show_D1_PVSK3, show_D2_PVSK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D0_PVSK2, show_D1_PVSK2, show_D2_PVSK2
        generic                                 :: show =>  show_D0_PVSK2, show_D1_PVSK2, show_D2_PVSK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D0_PVSK1, show_D1_PVSK1, show_D2_PVSK1
        generic                                 :: show =>  show_D0_PVSK1, show_D1_PVSK1, show_D2_PVSK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D0_PVIK5, show_D1_PVIK5, show_D2_PVIK5
        generic                                 :: show =>  show_D0_PVIK5, show_D1_PVIK5, show_D2_PVIK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D0_PVIK4, show_D1_PVIK4, show_D2_PVIK4
        generic                                 :: show =>  show_D0_PVIK4, show_D1_PVIK4, show_D2_PVIK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D0_PVIK3, show_D1_PVIK3, show_D2_PVIK3
        generic                                 :: show =>  show_D0_PVIK3, show_D1_PVIK3, show_D2_PVIK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D0_PVIK2, show_D1_PVIK2, show_D2_PVIK2
        generic                                 :: show =>  show_D0_PVIK2, show_D1_PVIK2, show_D2_PVIK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D0_PVIK1, show_D1_PVIK1, show_D2_PVIK1
        generic                                 :: show =>  show_D0_PVIK1, show_D1_PVIK1, show_D2_PVIK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D0_PVLK5, show_D1_PVLK5, show_D2_PVLK5
        generic                                 :: show =>  show_D0_PVLK5, show_D1_PVLK5, show_D2_PVLK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D0_PVLK4, show_D1_PVLK4, show_D2_PVLK4
        generic                                 :: show =>  show_D0_PVLK4, show_D1_PVLK4, show_D2_PVLK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D0_PVLK3, show_D1_PVLK3, show_D2_PVLK3
        generic                                 :: show =>  show_D0_PVLK3, show_D1_PVLK3, show_D2_PVLK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D0_PVLK2, show_D1_PVLK2, show_D2_PVLK2
        generic                                 :: show =>  show_D0_PVLK2, show_D1_PVLK2, show_D2_PVLK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D0_PVLK1, show_D1_PVLK1, show_D2_PVLK1
        generic                                 :: show =>  show_D0_PVLK1, show_D1_PVLK1, show_D2_PVLK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D0_PVCK5, show_D1_PVCK5, show_D2_PVCK5
        generic                                 :: show =>  show_D0_PVCK5, show_D1_PVCK5, show_D2_PVCK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D0_PVCK4, show_D1_PVCK4, show_D2_PVCK4
        generic                                 :: show =>  show_D0_PVCK4, show_D1_PVCK4, show_D2_PVCK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D0_PVCK3, show_D1_PVCK3, show_D2_PVCK3
        generic                                 :: show =>  show_D0_PVCK3, show_D1_PVCK3, show_D2_PVCK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D0_PVCK2, show_D1_PVCK2, show_D2_PVCK2
        generic                                 :: show =>  show_D0_PVCK2, show_D1_PVCK2, show_D2_PVCK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D0_PVCK1, show_D1_PVCK1, show_D2_PVCK1
        generic                                 :: show =>  show_D0_PVCK1, show_D1_PVCK1, show_D2_PVCK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D0_PVRK5, show_D1_PVRK5, show_D2_PVRK5
        generic                                 :: show =>  show_D0_PVRK5, show_D1_PVRK5, show_D2_PVRK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D0_PVRK4, show_D1_PVRK4, show_D2_PVRK4
        generic                                 :: show =>  show_D0_PVRK4, show_D1_PVRK4, show_D2_PVRK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D0_PVRK3, show_D1_PVRK3, show_D2_PVRK3
        generic                                 :: show =>  show_D0_PVRK3, show_D1_PVRK3, show_D2_PVRK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D0_PVRK2, show_D1_PVRK2, show_D2_PVRK2
        generic                                 :: show =>  show_D0_PVRK2, show_D1_PVRK2, show_D2_PVRK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D0_PVRK1, show_D1_PVRK1, show_D2_PVRK1
        generic                                 :: show =>  show_D0_PVRK1, show_D1_PVRK1, show_D2_PVRK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D0_PMSK5, show_D1_PMSK5
        generic                                 :: show =>  show_D0_PMSK5, show_D1_PMSK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D0_PMSK4, show_D1_PMSK4
        generic                                 :: show =>  show_D0_PMSK4, show_D1_PMSK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D0_PMSK3, show_D1_PMSK3
        generic                                 :: show =>  show_D0_PMSK3, show_D1_PMSK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D0_PMSK2, show_D1_PMSK2
        generic                                 :: show =>  show_D0_PMSK2, show_D1_PMSK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D0_PMSK1, show_D1_PMSK1
        generic                                 :: show =>  show_D0_PMSK1, show_D1_PMSK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D0_PMIK5, show_D1_PMIK5
        generic                                 :: show =>  show_D0_PMIK5, show_D1_PMIK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D0_PMIK4, show_D1_PMIK4
        generic                                 :: show =>  show_D0_PMIK4, show_D1_PMIK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D0_PMIK3, show_D1_PMIK3
        generic                                 :: show =>  show_D0_PMIK3, show_D1_PMIK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D0_PMIK2, show_D1_PMIK2
        generic                                 :: show =>  show_D0_PMIK2, show_D1_PMIK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D0_PMIK1, show_D1_PMIK1
        generic                                 :: show =>  show_D0_PMIK1, show_D1_PMIK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D0_PMLK5, show_D1_PMLK5
        generic                                 :: show =>  show_D0_PMLK5, show_D1_PMLK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D0_PMLK4, show_D1_PMLK4
        generic                                 :: show =>  show_D0_PMLK4, show_D1_PMLK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D0_PMLK3, show_D1_PMLK3
        generic                                 :: show =>  show_D0_PMLK3, show_D1_PMLK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D0_PMLK2, show_D1_PMLK2
        generic                                 :: show =>  show_D0_PMLK2, show_D1_PMLK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D0_PMLK1, show_D1_PMLK1
        generic                                 :: show =>  show_D0_PMLK1, show_D1_PMLK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D0_PMCK5, show_D1_PMCK5
        generic                                 :: show =>  show_D0_PMCK5, show_D1_PMCK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D0_PMCK4, show_D1_PMCK4
        generic                                 :: show =>  show_D0_PMCK4, show_D1_PMCK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D0_PMCK3, show_D1_PMCK3
        generic                                 :: show =>  show_D0_PMCK3, show_D1_PMCK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D0_PMCK2, show_D1_PMCK2
        generic                                 :: show =>  show_D0_PMCK2, show_D1_PMCK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D0_PMCK1, show_D1_PMCK1
        generic                                 :: show =>  show_D0_PMCK1, show_D1_PMCK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D0_PMRK5, show_D1_PMRK5
        generic                                 :: show =>  show_D0_PMRK5, show_D1_PMRK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D0_PMRK4, show_D1_PMRK4
        generic                                 :: show =>  show_D0_PMRK4, show_D1_PMRK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D0_PMRK3, show_D1_PMRK3
        generic                                 :: show =>  show_D0_PMRK3, show_D1_PMRK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D0_PMRK2, show_D1_PMRK2
        generic                                 :: show =>  show_D0_PMRK2, show_D1_PMRK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D0_PMRK1, show_D1_PMRK1
        generic                                 :: show =>  show_D0_PMRK1, show_D1_PMRK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     SK5_ENABLED
        procedure, pass, private                ::          show_D0_PCSK5
        generic                                 :: show =>  show_D0_PCSK5
#endif
#if     SK4_ENABLED
        procedure, pass, private                ::          show_D0_PCSK4
        generic                                 :: show =>  show_D0_PCSK4
#endif
#if     SK3_ENABLED
        procedure, pass, private                ::          show_D0_PCSK3
        generic                                 :: show =>  show_D0_PCSK3
#endif
#if     SK2_ENABLED
        procedure, pass, private                ::          show_D0_PCSK2
        generic                                 :: show =>  show_D0_PCSK2
#endif
#if     SK1_ENABLED
        procedure, pass, private                ::          show_D0_PCSK1
        generic                                 :: show =>  show_D0_PCSK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     IK5_ENABLED
        procedure, pass, private                ::          show_D0_PCIK5
        generic                                 :: show =>  show_D0_PCIK5
#endif
#if     IK4_ENABLED
        procedure, pass, private                ::          show_D0_PCIK4
        generic                                 :: show =>  show_D0_PCIK4
#endif
#if     IK3_ENABLED
        procedure, pass, private                ::          show_D0_PCIK3
        generic                                 :: show =>  show_D0_PCIK3
#endif
#if     IK2_ENABLED
        procedure, pass, private                ::          show_D0_PCIK2
        generic                                 :: show =>  show_D0_PCIK2
#endif
#if     IK1_ENABLED
        procedure, pass, private                ::          show_D0_PCIK1
        generic                                 :: show =>  show_D0_PCIK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     LK5_ENABLED
        procedure, pass, private                ::          show_D0_PCLK5
        generic                                 :: show =>  show_D0_PCLK5
#endif
#if     LK4_ENABLED
        procedure, pass, private                ::          show_D0_PCLK4
        generic                                 :: show =>  show_D0_PCLK4
#endif
#if     LK3_ENABLED
        procedure, pass, private                ::          show_D0_PCLK3
        generic                                 :: show =>  show_D0_PCLK3
#endif
#if     LK2_ENABLED
        procedure, pass, private                ::          show_D0_PCLK2
        generic                                 :: show =>  show_D0_PCLK2
#endif
#if     LK1_ENABLED
        procedure, pass, private                ::          show_D0_PCLK1
        generic                                 :: show =>  show_D0_PCLK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     CK5_ENABLED
        procedure, pass, private                ::          show_D0_PCCK5
        generic                                 :: show =>  show_D0_PCCK5
#endif
#if     CK4_ENABLED
        procedure, pass, private                ::          show_D0_PCCK4
        generic                                 :: show =>  show_D0_PCCK4
#endif
#if     CK3_ENABLED
        procedure, pass, private                ::          show_D0_PCCK3
        generic                                 :: show =>  show_D0_PCCK3
#endif
#if     CK2_ENABLED
        procedure, pass, private                ::          show_D0_PCCK2
        generic                                 :: show =>  show_D0_PCCK2
#endif
#if     CK1_ENABLED
        procedure, pass, private                ::          show_D0_PCCK1
        generic                                 :: show =>  show_D0_PCCK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if     RK5_ENABLED
        procedure, pass, private                ::          show_D0_PCRK5
        generic                                 :: show =>  show_D0_PCRK5
#endif
#if     RK4_ENABLED
        procedure, pass, private                ::          show_D0_PCRK4
        generic                                 :: show =>  show_D0_PCRK4
#endif
#if     RK3_ENABLED
        procedure, pass, private                ::          show_D0_PCRK3
        generic                                 :: show =>  show_D0_PCRK3
#endif
#if     RK2_ENABLED
        procedure, pass, private                ::          show_D0_PCRK2
        generic                                 :: show =>  show_D0_PCRK2
#endif
#if     RK1_ENABLED
        procedure, pass, private                ::          show_D0_PCRK1
        generic                                 :: show =>  show_D0_PCRK1
#endif

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#endif
!PDT_ENABLED


        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        procedure, pass, private                ::          show_D0_BSSK, show_D1_BSSK, show_D2_BSSK, show_D3_BSSK
        generic                                 :: show =>  show_D0_BSSK, show_D1_BSSK, show_D2_BSSK, show_D3_BSSK

        procedure, pass, private                ::          show_D0_BSIK, show_D1_BSIK, show_D2_BSIK, show_D3_BSIK
        generic                                 :: show =>  show_D0_BSIK, show_D1_BSIK, show_D2_BSIK, show_D3_BSIK

        procedure, pass, private                ::          show_D0_BSLK, show_D1_BSLK, show_D2_BSLK, show_D3_BSLK
        generic                                 :: show =>  show_D0_BSLK, show_D1_BSLK, show_D2_BSLK, show_D3_BSLK

        procedure, pass, private                ::          show_D0_BSCK, show_D1_BSCK, show_D2_BSCK, show_D3_BSCK
        generic                                 :: show =>  show_D0_BSCK, show_D1_BSCK, show_D2_BSCK, show_D3_BSCK

        procedure, pass, private                ::          show_D0_BSRK, show_D1_BSRK, show_D2_BSRK, show_D3_BSRK
        generic                                 :: show =>  show_D0_BSRK, show_D1_BSRK, show_D2_BSRK, show_D3_BSRK

        procedure, pass, private                ::          show_D0_BVSK, show_D1_BVSK, show_D2_BVSK
        generic                                 :: show =>  show_D0_BVSK, show_D1_BVSK, show_D2_BVSK

        procedure, pass, private                ::          show_D0_BVIK, show_D1_BVIK, show_D2_BVIK
        generic                                 :: show =>  show_D0_BVIK, show_D1_BVIK, show_D2_BVIK

        procedure, pass, private                ::          show_D0_BVLK, show_D1_BVLK, show_D2_BVLK
        generic                                 :: show =>  show_D0_BVLK, show_D1_BVLK, show_D2_BVLK

        procedure, pass, private                ::          show_D0_BVCK, show_D1_BVCK, show_D2_BVCK
        generic                                 :: show =>  show_D0_BVCK, show_D1_BVCK, show_D2_BVCK

        procedure, pass, private                ::          show_D0_BVRK, show_D1_BVRK, show_D2_BVRK
        generic                                 :: show =>  show_D0_BVRK, show_D1_BVRK, show_D2_BVRK

#if     FORTRAN_ENABLED
        procedure, pass, private                ::          show_D0_BMSK, show_D1_BMSK
        generic                                 :: show =>  show_D0_BMSK, show_D1_BMSK

        procedure, pass, private                ::          show_D0_BMIK, show_D1_BMIK
        generic                                 :: show =>  show_D0_BMIK, show_D1_BMIK

        procedure, pass, private                ::          show_D0_BMLK, show_D1_BMLK
        generic                                 :: show =>  show_D0_BMLK, show_D1_BMLK

        procedure, pass, private                ::          show_D0_BMCK, show_D1_BMCK
        generic                                 :: show =>  show_D0_BMCK, show_D1_BMCK

        procedure, pass, private                ::          show_D0_BMRK, show_D1_BMRK
        generic                                 :: show =>  show_D0_BMRK, show_D1_BMRK

        procedure, pass, private                ::          show_D0_BCSK
        generic                                 :: show =>  show_D0_BCSK

        procedure, pass, private                ::          show_D0_BCIK
        generic                                 :: show =>  show_D0_BCIK

        procedure, pass, private                ::          show_D0_BCLK
        generic                                 :: show =>  show_D0_BCLK

        procedure, pass, private                ::          show_D0_BCCK
        generic                                 :: show =>  show_D0_BCCK

        procedure, pass, private                ::          show_D0_BCRK
        generic                                 :: show =>  show_D0_BCRK

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        procedure, pass, private                ::          dump_D0, dump_D1, dump_D2
        generic                                 :: dump =>  dump_D0, dump_D1, dump_D2
#endif
!FORTRAN_ENABLED

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        procedure, pass                         :: skip_IK
        generic                                 :: skip =>  skip_IK

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

       !final                                   :: finalizeDisplay

        !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        !> \endcond excluded

    end type display_type

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a scalar module variable an object of type [display_type](@ref pm_io::display_type) for general display.<br>
    !>
    !>  \details
    !>  The existence of this object is to merely facilitate quick tests and displays of items on the default stdout.<br>
    !>  Given the global nature of this object, its usage is not recommended beyond simple tests and debugging tasks.<br>
    !>
    !>  \final{disp}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    type(display_type) :: disp
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: disp
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \cond excluded
    interface display_type

    module function display_typer_file(file, status, position, advance, format, deliml, delimr, tmsize, bmsize, count, sticky, text, mark, note, warn, stop) result(disp)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: display_typer_file
#endif
        character(*, SK), intent(in)            :: file
        logical(LK)     , intent(in), optional  :: sticky
        integer(IK)     , intent(in), optional  :: count
        integer(IK)     , intent(in), optional  :: tmsize, bmsize
        character(*, SK), intent(in), optional  :: position
        character(*, SK), intent(in), optional  :: advance
        character(*, SK), intent(in), optional  :: status
        type(field_type), intent(in), optional  :: format
        type(field_type), intent(in), optional  :: deliml
        type(field_type), intent(in), optional  :: delimr
        type(mark_type) , intent(in), optional  :: mark
        type(note_type) , intent(in), optional  :: note
        type(warn_type) , intent(in), optional  :: warn
        type(stop_type) , intent(in), optional  :: stop
        type(wrap_type) , intent(in), optional  :: text
        type(display_type) :: disp
    end function

    module function display_typer_unit(unit, advance, format, deliml, delimr, tmsize, bmsize, count, sticky, text, mark, note, warn, stop) result(disp)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: display_typer_unit
#endif
        integer(IK)     , intent(in), optional  :: unit
        logical(LK)     , intent(in), optional  :: sticky
        integer(IK)     , intent(in), optional  :: count
        integer(IK)     , intent(in), optional  :: tmsize, bmsize
        character(*, SK), intent(in), optional  :: advance
        type(field_type), intent(in), optional  :: format
        type(field_type), intent(in), optional  :: deliml
        type(field_type), intent(in), optional  :: delimr
        type(mark_type) , intent(in), optional  :: mark
        type(note_type) , intent(in), optional  :: note
        type(warn_type) , intent(in), optional  :: warn
        type(stop_type) , intent(in), optional  :: stop
        type(wrap_type) , intent(in), optional  :: text
        type(display_type) :: disp
    end function

    end interface
    !>  \endcond excluded

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!    interface
!    module subroutine finalizeDisplay(self)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: finalizeDisplay
!#endif
!        type(display_type), intent(inout)   :: self
!    end subroutine
!    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a generic method of the derived type [display_type](@ref pm_io::display_type) with `pass` attribute.<br>
    !>
    !>  \details
    !>  This method skips a specified number of lines in the output display.<br>
    !>
    !>  \param[in]  count       :   The input scalar `integer` of default kind \IK, containing the number of lines to skip in the display.<br>
    !>                              (**optional**, default = `1_IK`)
    !>  \param[in]  unit        :   The input scalar `integer` of default kind \IK representing the output display unit number where the text will be displayed.<br>
    !>                              (**optional**, default = `display_type%%unit`)
    !>  \param[in]  sticky      :   The input scalar `logical` of default kind \LK. If `.true.` the display `unit` will be stored in `unit`
    !>                              component of the current object of type [display_type](@ref pm_io::display_type) for later usage.<br>
    !>                              (**optional**, default = `.false._LK`)
    !>
    !>  \interface{skip}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: display_type
    !>      type(display_type) :: disp
    !>
    !>      call disp%skip( count = count       &
    !>                    , unit = unit         &
    !>                    , sticky = sticky     &
    !>                    )
    !>
    !>  \endcode
    !>
    !>  \impure
    !>
    !>  \see
    !>  [wrap_type%%wrap()](@ref pm_io::wrap)<br>
    !>  [display_type%%show()](@ref pm_io::show)<br>
    !>  [display_type%%skip()](@ref pm_io::skip)<br>
    !>
    !>  \example{skip}
    !>  \include{lineno} example/pm_io/skip/main.F90
    !>  \compilef{skip}
    !>  \output{skip}
    !>  \include{lineno} example/pm_io/skip/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    interface skip
    module subroutine skip_IK(self, count, unit, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: skip_IK
#endif
        class(display_type) , intent(inout)         :: self
        integer(IK)         , intent(in), optional  :: unit
        integer(IK)         , intent(in), optional  :: count
        logical(LK)         , intent(in), optional  :: sticky
    end subroutine
    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is a generic method of the derived type [display_type](@ref pm_io::display_type) with `pass` attribute.<br>
    !>
    !>  \details
    !>  This method displays the input `object` of supported type and kind and rank in the specified output.<br>
    !>
    !>  \param[in]  object  :   The input object of either,<br>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type `character` of kind \SKALL, or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type `integer` of kind \IKALL, or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type `logical` of kind \LKALL, or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type `complex` of kind \CKALL, or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type `real` of kind \RKALL, or<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [css_type](@ref pm_container::css_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csi_type](@ref pm_container::csi_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csl_type](@ref pm_container::csl_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csc_type](@ref pm_container::csc_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csr_type](@ref pm_container::csr_type), or<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvs_type](@ref pm_container::cvs_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvi_type](@ref pm_container::cvi_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvl_type](@ref pm_container::cvl_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvc_type](@ref pm_container::cvc_type), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvr_type](@ref pm_container::cvr_type), or<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` of type [cms_type](@ref pm_container::cms_type), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmi_type](@ref pm_container::cmi_type), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cml_type](@ref pm_container::cml_type), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmc_type](@ref pm_container::cmc_type), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmr_type](@ref pm_container::cmr_type)<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar of type [ccs_type](@ref pm_container::ccs_type), or<br>
    !>                              <li>    scalar of type [cci_type](@ref pm_container::cci_type), or<br>
    !>                              <li>    scalar of type [ccl_type](@ref pm_container::ccl_type), or<br>
    !>                              <li>    scalar of type [ccc_type](@ref pm_container::ccc_type), or<br>
    !>                              <li>    scalar of type [ccr_type](@ref pm_container::ccr_type)<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [css_pdt](@ref pm_container::css_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csi_pdt](@ref pm_container::csi_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csl_pdt](@ref pm_container::csl_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csc_pdt](@ref pm_container::csc_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` or `3` of type [csr_pdt](@ref pm_container::csr_pdt), or<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvs_pdt](@ref pm_container::cvs_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvi_pdt](@ref pm_container::cvi_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvl_pdt](@ref pm_container::cvl_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvc_pdt](@ref pm_container::cvc_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` or `2` of type [cvr_pdt](@ref pm_container::cvr_pdt), or<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar or array of rank `1` of type [cms_pdt](@ref pm_container::cms_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmi_pdt](@ref pm_container::cmi_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cml_pdt](@ref pm_container::cml_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmc_pdt](@ref pm_container::cmc_pdt), or<br>
    !>                              <li>    scalar or array of rank `1` of type [cmr_pdt](@ref pm_container::cmr_pdt)<br>
    !>                          </ul>
    !>                          <ul>
    !>                              <li>    scalar of type [ccs_pdt](@ref pm_container::ccs_pdt), or<br>
    !>                              <li>    scalar of type [cci_pdt](@ref pm_container::cci_pdt), or<br>
    !>                              <li>    scalar of type [ccl_pdt](@ref pm_container::ccl_pdt), or<br>
    !>                              <li>    scalar of type [ccc_pdt](@ref pm_container::ccc_pdt), or<br>
    !>                              <li>    scalar of type [ccr_pdt](@ref pm_container::ccr_pdt)<br>
    !>                          </ul>
    !>                          containing the content to display.
    !>  \param[in]  tmsize  :   The input scalar of `integer` of default kind \IK representing the number of empty lines preceding the object in the display.<br>
    !>                          (**optional**, default = `0_IK`)
    !>  \param[in]  bmsize  :   The input scalar of `integer` of default kind \IK representing the number of empty lines succeeding the object in the display.<br>
    !>                          (**optional**, default = `0_IK`)
    !>  \param[in]  count   :   The input scalar of `integer` of default kind \IK representing the number of times the object will have to be sequentially displayed in separate lines.<br>
    !>                          (**optional**, default = `1_IK`)
    !>  \param[in]  unit    :   The input scalar `integer` of default kind \IK representing the output display unit number where the text will be displayed.<br>
    !>                          (**optional**, default = `display_type%%unit`)
    !>  \param[in]  advance :   The input scalar `character` of default kind \SK that must be either `NO` or `YES`.<br>
    !>                          It has the same functionality and meaning as the `advance` argument in the Fortran intrinsic IO statement `read()`.<br>
    !>                          (**optional**, default = `YES`)
    !>  \param[in]  format  :   The input scalar `character` of default kind \SK containing the format with which the `object` should be displayed.<br>
    !>                          If present, the input value is directly passed to the Fortran `write()` statement for a formatted display.<br>
    !>                          (**optional**, default = `YES`)
    !>  \param[in]  deliml  :   The input scalar of type `character` of default kind default kind \SK,
    !>                          whose contents represent the left-delimiter to be used for left-wrapping fields of the input object.<br>
    !>                          The common Fortran-style left-delimiter for `complex` fields is the left-parenthesis \f$\texttt{(}\f$.<br>
    !>                          The two most common left-delimiters string fields are the single \f$\texttt{'}\f$ and double \f$\texttt{"}\f$ quotation marks.<br>
    !>                          The left-delimiter is particularly relevant to string and `complex` objects that are passed to the methods of [display_type](@ref pm_io::display_type).<br>
    !>                          The input `deliml` will be used for constructing the field format only if the input argument `format` is missing.<br>
    !>                          (**optional**. default = `delimr` or if missing, the corresponding value from the `deliml` component of the parent `disp` object of this method.)
    !>  \param[in]  delimr  :   The input scalar of type `character` of default kind default kind \SK,
    !>                          whose contents represent the right-delimiter to be used for right-wrapping fields of the input object.<br>
    !>                          The common Fortran-style right-delimiter for `complex` fields is the right-parenthesis \f$\texttt{)}\f$.<br>
    !>                          The two most common right-delimiters string fields are the single \f$\texttt{'}\f$ and double \f$\texttt{"}\f$ quotation marks.<br>
    !>                          The right-delimiter is particularly relevant to string and `complex` objects that are passed to the methods of [display_type](@ref pm_io::display_type).<br>
    !>                          The input `delimr` will be used for constructing the field format only if the input argument `format` is missing.<br>
    !>                          (**optional**. default = `deliml` or if missing, the corresponding value from the `delimr` component of the parent `disp` object of this method.)
    !>  \param[in]  sticky  :   The input scalar `logical` of default kind \LK.<br>
    !>                          If `.true.` the input arguments will update the corresponding components of
    !>                          the parent object of type [display_type](@ref pm_io::display_type) for later usage.<br>
    !>                          (**optional**, default = `.false._LK`)
    !>
    !>  \interface{show}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: display_type
    !>      type(display_type) :: disp
    !>
    !>      call disp%show( object &
    !>                    , tmsize = tmsize &
    !>                    , bmsize = bmsize &
    !>                    , count = count &
    !>                    , unit = unit &
    !>                    , advance = advance &
    !>                    , format = format &
    !>                    , deliml = deliml &
    !>                    , delimr = delimr &
    !>                    , sticky = sticky &
    !>                    )
    !>
    !>  \endcode
    !>
    !>  \impure
    !>
    !>  \see
    !>  [wrap_type%wrap()](@ref pm_io::wrap)<br>
    !>  [display_type%show()](@ref pm_io::show)<br>
    !>  [display_type%skip()](@ref pm_io::skip)<br>
    !>
    !>  \example{show}
    !>  \include{lineno} example/pm_io/show/main.F90
    !>  \compilef{show}
    !>  \output{show}
    !>  \include{lineno} example/pm_io/show/main.out.F90
    !>
    !>  \bug
    !>  \status \unresolved
    !>  \source \ifort{2021.5}
    !>  \desc
    !>  The \ifort{2021.5} cannot not compile the following interface specification for the procedures, yielding "ambiguous interface" error.<br>
    !>  \code{.F90}
    !>
    !>      module container_module
    !>
    !>          use iso_fortran_env
    !>
    !>          integer, parameter :: lkc = logical_kinds(1)
    !>          integer, parameter :: ikc = integer_kinds(1)
    !>
    !>          type :: container_ik(kind)
    !>              integer         , kind  :: kind = integer_kinds(1)
    !>              integer(kind)           :: value
    !>          end type
    !>
    !>          type :: container_lk(kind)
    !>              integer         , kind  :: kind = logical_kinds(1)
    !>              logical(kind)           :: value
    !>          end type
    !>
    !>      end module
    !>
    !>      module disp_module
    !>
    !>          use container_module
    !>
    !>          type :: disp_type
    !>          end type
    !>
    !>          interface show
    !>          module subroutine show_logical(self, object)
    !>              use container_module, only: container => container_lk
    !>              class(disp_type)        , intent(inout)               :: self
    !>             !type(container_lk(lkc)) , intent(in)                  :: object
    !>              type(container(lkc))    , intent(in)                  :: object
    !>          end subroutine
    !>          module subroutine show_integer(self, object)
    !>              use container_module, only: container => container_ik
    !>              class(disp_type)        , intent(inout)               :: self
    !>             !type(container_ik(ikc)) , intent(in)                  :: object
    !>              type(container(ikc))    , intent(in)                  :: object
    !>          end subroutine
    !>          end interface
    !>
    !>      end module
    !>
    !>      end
    !>
    !>  \endcode
    !>  Note that the issue is with the aliasing of the pm_container module entities `use container_module, only: container => container_ik`.
    !>  \remedy
    !>  For now, all interfaces were painfully converted to explicit type names (instead of aliases).
    !>
    !>  \todo
    !>  \pvhigh
    !>  The syntax of the procedure interfaces must be fixed and reverted to the original aliasing style, as soon as the \ifort{2021.5} bug is resolved.
    !>  Note that \gfortran{10-11} has no problem compiling the code.
    !>
    !>  \final
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan

    interface show

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D0_SK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_SK5
#endif
        use pm_kind, only: SKG => SK5
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D0_SK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_SK4
#endif
        use pm_kind, only: SKG => SK4
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D0_SK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_SK3
#endif
        use pm_kind, only: SKG => SK3
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D0_SK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_SK2
#endif
        use pm_kind, only: SKG => SK2
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D0_SK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_SK1
#endif
        use pm_kind, only: SKG => SK1
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D0_IK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_IK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D0_IK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_IK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D0_IK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_IK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D0_IK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_IK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D0_IK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_IK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D0_LK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_LK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D0_LK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_LK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D0_LK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_LK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D0_LK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_LK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D0_LK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_LK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D0_CK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_CK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D0_CK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_CK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D0_CK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_CK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D0_CK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_CK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D0_CK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_CK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D0_RK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_RK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D0_RK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_RK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D0_RK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_RK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D0_RK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_RK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D0_RK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_RK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D1_SK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D1_SK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D1_SK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D1_SK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D1_SK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D1_IK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_IK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D1_IK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_IK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D1_IK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_IK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D1_IK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_IK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D1_IK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_IK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D1_LK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_LK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D1_LK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_LK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D1_LK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_LK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D1_LK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_LK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D1_LK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_LK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D1_CK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_CK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D1_CK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_CK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D1_CK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_CK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D1_CK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_CK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D1_CK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_CK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D1_RK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_RK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D1_RK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_RK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D1_RK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_RK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D1_RK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_RK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D1_RK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_RK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D2_SK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_SK5
#endif
        use pm_kind, only: SKG => SK5
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D2_SK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_SK4
#endif
        use pm_kind, only: SKG => SK4
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D2_SK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_SK3
#endif
        use pm_kind, only: SKG => SK3
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D2_SK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_SK2
#endif
        use pm_kind, only: SKG => SK2
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D2_SK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_SK1
#endif
        use pm_kind, only: SKG => SK1
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D2_IK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_IK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D2_IK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_IK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D2_IK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_IK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D2_IK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_IK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D2_IK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_IK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D2_LK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_LK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D2_LK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_LK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D2_LK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_LK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D2_LK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_LK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D2_LK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_LK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D2_CK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_CK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D2_CK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_CK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D2_CK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_CK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D2_CK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_CK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D2_CK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_CK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D2_RK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_RK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D2_RK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_RK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D2_RK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_RK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D2_RK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_RK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D2_RK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_RK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D3_SK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_SK5
#endif
        use pm_kind, only: SKG => SK5
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D3_SK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_SK4
#endif
        use pm_kind, only: SKG => SK4
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D3_SK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_SK3
#endif
        use pm_kind, only: SKG => SK3
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D3_SK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_SK2
#endif
        use pm_kind, only: SKG => SK2
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D3_SK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_SK1
#endif
        use pm_kind, only: SKG => SK1
        class(display_type)         , intent(inout)                 :: self
        character(*,SKG)            , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D3_IK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_IK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D3_IK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_IK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D3_IK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_IK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D3_IK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_IK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D3_IK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_IK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        class(display_type)         , intent(inout)                 :: self
        integer(IKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D3_LK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_LK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D3_LK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_LK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D3_LK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_LK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D3_LK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_LK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D3_LK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_LK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        class(display_type)         , intent(inout)                 :: self
        logical(LKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D3_CK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_CK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D3_CK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_CK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D3_CK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_CK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D3_CK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_CK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D3_CK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_CK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        class(display_type)         , intent(inout)                 :: self
        complex(CKG)                , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D3_RK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_RK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D3_RK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_RK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D3_RK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_RK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D3_RK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_RK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D3_RK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_RK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        class(display_type)         , intent(inout)                 :: self
        real(RKG)                   , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if PDT_ENABLED

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D0_PSSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D0_PSSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D0_PSSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D0_PSSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D0_PSSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D0_PSIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D0_PSIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D0_PSIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D0_PSIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D0_PSIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D0_PSLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D0_PSLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D0_PSLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D0_PSLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D0_PSLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D0_PSCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D0_PSCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D0_PSCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D0_PSCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D0_PSCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D0_PSRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D0_PSRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D0_PSRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D0_PSRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D0_PSRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PSRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D1_PSSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D1_PSSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D1_PSSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D1_PSSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D1_PSSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D1_PSIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D1_PSIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D1_PSIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D1_PSIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D1_PSIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D1_PSLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D1_PSLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D1_PSLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D1_PSLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D1_PSLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D1_PSCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D1_PSCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D1_PSCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D1_PSCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D1_PSCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D1_PSRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D1_PSRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D1_PSRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D1_PSRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D1_PSRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PSRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D2_PSSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D2_PSSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D2_PSSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D2_PSSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D2_PSSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D2_PSIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D2_PSIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D2_PSIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D2_PSIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D2_PSIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D2_PSLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D2_PSLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D2_PSLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D2_PSLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D2_PSLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D2_PSCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D2_PSCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D2_PSCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D2_PSCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D2_PSCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D2_PSRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D2_PSRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D2_PSRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D2_PSRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D2_PSRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PSRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D3_PSSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D3_PSSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D3_PSSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D3_PSSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D3_PSSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: css_pdt
        class(display_type)         , intent(inout)                 :: self
        type(css_pdt(SKG))             , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D3_PSIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D3_PSIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D3_PSIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D3_PSIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D3_PSIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: csi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D3_PSLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D3_PSLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D3_PSLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D3_PSLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D3_PSLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: csl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D3_PSCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D3_PSCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D3_PSCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D3_PSCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D3_PSCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: csc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D3_PSRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D3_PSRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D3_PSRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D3_PSRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D3_PSRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_PSRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: csr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(csr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D0_PVSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D0_PVSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D0_PVSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D0_PVSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D0_PVSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D0_PVIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D0_PVIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D0_PVIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D0_PVIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D0_PVIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D0_PVLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D0_PVLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D0_PVLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D0_PVLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D0_PVLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D0_PVCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D0_PVCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D0_PVCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D0_PVCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D0_PVCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D0_PVRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D0_PVRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D0_PVRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D0_PVRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D0_PVRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PVRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D1_PVSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D1_PVSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D1_PVSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D1_PVSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D1_PVSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D1_PVIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D1_PVIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D1_PVIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D1_PVIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D1_PVIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D1_PVLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D1_PVLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D1_PVLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D1_PVLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D1_PVLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D1_PVCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D1_PVCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D1_PVCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D1_PVCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D1_PVCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D1_PVRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D1_PVRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D1_PVRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D1_PVRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D1_PVRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PVRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D2_PVSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D2_PVSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D2_PVSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D2_PVSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D2_PVSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: cvs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvs_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D2_PVIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D2_PVIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D2_PVIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D2_PVIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D2_PVIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cvi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D2_PVLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D2_PVLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D2_PVLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D2_PVLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D2_PVLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: cvl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvl_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D2_PVCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D2_PVCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D2_PVCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D2_PVCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D2_PVCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: cvc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D2_PVRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D2_PVRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D2_PVRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D2_PVRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D2_PVRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_PVRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: cvr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cvr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D0_PMSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D0_PMSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D0_PMSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D0_PMSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D0_PMSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D0_PMIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D0_PMIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D0_PMIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D0_PMIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D0_PMIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D0_PMLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D0_PMLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D0_PMLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D0_PMLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D0_PMLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D0_PMCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D0_PMCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D0_PMCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D0_PMCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D0_PMCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D0_PMRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D0_PMRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D0_PMRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D0_PMRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D0_PMRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PMRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D1_PMSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D1_PMSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D1_PMSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D1_PMSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D1_PMSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: cms_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cms_pdt(SKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D1_PMIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D1_PMIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D1_PMIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D1_PMIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D1_PMIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cmi_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmi_pdt(IKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D1_PMLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D1_PMLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D1_PMLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D1_PMLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D1_PMLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: cml_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cml_pdt(LKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D1_PMCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D1_PMCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D1_PMCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D1_PMCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D1_PMCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: cmc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmc_pdt(CKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D1_PMRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D1_PMRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D1_PMRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D1_PMRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D1_PMRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_PMRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: cmr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cmr_pdt(RKG))          , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    module subroutine show_D0_PCSK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCSK5
#endif
        use pm_kind, only: SKG => SK5
        use pm_container, only: ccs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK4_ENABLED
    module subroutine show_D0_PCSK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCSK4
#endif
        use pm_kind, only: SKG => SK4
        use pm_container, only: ccs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK3_ENABLED
    module subroutine show_D0_PCSK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCSK3
#endif
        use pm_kind, only: SKG => SK3
        use pm_container, only: ccs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK2_ENABLED
    module subroutine show_D0_PCSK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCSK2
#endif
        use pm_kind, only: SKG => SK2
        use pm_container, only: ccs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if SK1_ENABLED
    module subroutine show_D0_PCSK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCSK1
#endif
        use pm_kind, only: SKG => SK1
        use pm_container, only: ccs_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccs_pdt(SKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    module subroutine show_D0_PCIK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCIK5
#endif
        use pm_kind, only: SKG => SK, IKG => IK5
        use pm_container, only: cci_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cci_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK4_ENABLED
    module subroutine show_D0_PCIK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCIK4
#endif
        use pm_kind, only: SKG => SK, IKG => IK4
        use pm_container, only: cci_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cci_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK3_ENABLED
    module subroutine show_D0_PCIK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCIK3
#endif
        use pm_kind, only: SKG => SK, IKG => IK3
        use pm_container, only: cci_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cci_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK2_ENABLED
    module subroutine show_D0_PCIK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCIK2
#endif
        use pm_kind, only: SKG => SK, IKG => IK2
        use pm_container, only: cci_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cci_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if IK1_ENABLED
    module subroutine show_D0_PCIK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCIK1
#endif
        use pm_kind, only: SKG => SK, IKG => IK1
        use pm_container, only: cci_pdt
        class(display_type)         , intent(inout)                 :: self
        type(cci_pdt(IKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    module subroutine show_D0_PCLK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCLK5
#endif
        use pm_kind, only: SKG => SK, LKG => LK5
        use pm_container, only: ccl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK4_ENABLED
    module subroutine show_D0_PCLK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCLK4
#endif
        use pm_kind, only: SKG => SK, LKG => LK4
        use pm_container, only: ccl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK3_ENABLED
    module subroutine show_D0_PCLK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCLK3
#endif
        use pm_kind, only: SKG => SK, LKG => LK3
        use pm_container, only: ccl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK2_ENABLED
    module subroutine show_D0_PCLK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCLK2
#endif
        use pm_kind, only: SKG => SK, LKG => LK2
        use pm_container, only: ccl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if LK1_ENABLED
    module subroutine show_D0_PCLK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCLK1
#endif
        use pm_kind, only: SKG => SK, LKG => LK1
        use pm_container, only: ccl_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccl_pdt(LKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    module subroutine show_D0_PCCK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCCK5
#endif
        use pm_kind, only: SKG => SK, CKG => CK5
        use pm_container, only: ccc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK4_ENABLED
    module subroutine show_D0_PCCK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCCK4
#endif
        use pm_kind, only: SKG => SK, CKG => CK4
        use pm_container, only: ccc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK3_ENABLED
    module subroutine show_D0_PCCK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCCK3
#endif
        use pm_kind, only: SKG => SK, CKG => CK3
        use pm_container, only: ccc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK2_ENABLED
    module subroutine show_D0_PCCK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCCK2
#endif
        use pm_kind, only: SKG => SK, CKG => CK2
        use pm_container, only: ccc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if CK1_ENABLED
    module subroutine show_D0_PCCK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCCK1
#endif
        use pm_kind, only: SKG => SK, CKG => CK1
        use pm_container, only: ccc_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccc_pdt(CKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module subroutine show_D0_PCRK5(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCRK5
#endif
        use pm_kind, only: SKG => SK, RKG => RK5
        use pm_container, only: ccr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK4_ENABLED
    module subroutine show_D0_PCRK4(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCRK4
#endif
        use pm_kind, only: SKG => SK, RKG => RK4
        use pm_container, only: ccr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK3_ENABLED
    module subroutine show_D0_PCRK3(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCRK3
#endif
        use pm_kind, only: SKG => SK, RKG => RK3
        use pm_container, only: ccr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK2_ENABLED
    module subroutine show_D0_PCRK2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCRK2
#endif
        use pm_kind, only: SKG => SK, RKG => RK2
        use pm_container, only: ccr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

#if RK1_ENABLED
    module subroutine show_D0_PCRK1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_PCRK1
#endif
        use pm_kind, only: SKG => SK, RKG => RK1
        use pm_container, only: ccr_pdt
        class(display_type)         , intent(inout)                 :: self
        type(ccr_pdt(RKG))          , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#endif
!PDT_ENABLED

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D0_BSSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BSSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: css_type
        class(display_type)         , intent(inout)                 :: self
        type(css_type)        , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BSIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BSIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csi_type
        class(display_type)         , intent(inout)                 :: self
        type(csi_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BSLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BSLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csl_type
        class(display_type)         , intent(inout)                 :: self
        type(csl_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BSCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BSCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csc_type
        class(display_type)         , intent(inout)                 :: self
        type(csc_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BSRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BSRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csr_type
        class(display_type)         , intent(inout)                 :: self
        type(csr_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D1_BSSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BSSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: css_type
        class(display_type)         , intent(inout)                 :: self
        type(css_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BSIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BSIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csi_type
        class(display_type)         , intent(inout)                 :: self
        type(csi_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BSLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BSLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csl_type
        class(display_type)         , intent(inout)                 :: self
        type(csl_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BSCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BSCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csc_type
        class(display_type)         , intent(inout)                 :: self
        type(csc_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BSRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BSRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csr_type
        class(display_type)         , intent(inout)                 :: self
        type(csr_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D2_BSSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BSSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: css_type
        class(display_type)         , intent(inout)                 :: self
        type(css_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BSIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BSIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csi_type
        class(display_type)         , intent(inout)                 :: self
        type(csi_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BSLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BSLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csl_type
        class(display_type)         , intent(inout)                 :: self
        type(csl_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BSCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BSCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csc_type
        class(display_type)         , intent(inout)                 :: self
        type(csc_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BSRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BSRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csr_type
        class(display_type)         , intent(inout)                 :: self
        type(csr_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D3_BSSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_BSSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: css_type
        class(display_type)         , intent(inout)                 :: self
        type(css_type)              , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D3_BSIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_BSIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csi_type
        class(display_type)         , intent(inout)                 :: self
        type(csi_type)              , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D3_BSLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_BSLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csl_type
        class(display_type)         , intent(inout)                 :: self
        type(csl_type)              , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D3_BSCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_BSCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csc_type
        class(display_type)         , intent(inout)                 :: self
        type(csc_type)              , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D3_BSRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D3_BSRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: csr_type
        class(display_type)         , intent(inout)                 :: self
        type(csr_type)              , intent(in)    __CONTIGUOUS    :: object(:,:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D0_BVSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BVSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvs_type
        class(display_type)         , intent(inout)                 :: self
        type(cvs_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BVIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BVIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvi_type
        class(display_type)         , intent(inout)                 :: self
        type(cvi_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BVLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BVLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvl_type
        class(display_type)         , intent(inout)                 :: self
        type(cvl_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BVCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BVCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvc_type
        class(display_type)         , intent(inout)                 :: self
        type(cvc_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BVRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BVRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvr_type
        class(display_type)         , intent(inout)                 :: self
        type(cvr_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D1_BVSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BVSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvs_type
        class(display_type)         , intent(inout)                 :: self
        type(cvs_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BVIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BVIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvi_type
        class(display_type)         , intent(inout)                 :: self
        type(cvi_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BVLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BVLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvl_type
        class(display_type)         , intent(inout)                 :: self
        type(cvl_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BVCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BVCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvc_type
        class(display_type)         , intent(inout)                 :: self
        type(cvc_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BVRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BVRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvr_type
        class(display_type)         , intent(inout)                 :: self
        type(cvr_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D2_BVSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BVSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvs_type
        class(display_type)         , intent(inout)                 :: self
        type(cvs_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BVIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BVIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvi_type
        class(display_type)         , intent(inout)                 :: self
        type(cvi_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BVLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BVLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvl_type
        class(display_type)         , intent(inout)                 :: self
        type(cvl_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BVCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BVCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvc_type
        class(display_type)         , intent(inout)                 :: self
        type(cvc_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D2_BVRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D2_BVRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cvr_type
        class(display_type)         , intent(inout)                 :: self
        type(cvr_type)              , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D0_BMSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BMSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cms_type
        class(display_type)         , intent(inout)                 :: self
        type(cms_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BMIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BMIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmi_type
        class(display_type)         , intent(inout)                 :: self
        type(cmi_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BMLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BMLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cml_type
        class(display_type)         , intent(inout)                 :: self
        type(cml_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BMCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BMCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmc_type
        class(display_type)         , intent(inout)                 :: self
        type(cmc_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BMRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BMRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmr_type
        class(display_type)         , intent(inout)                 :: self
        type(cmr_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D1_BMSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BMSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cms_type
        class(display_type)         , intent(inout)                 :: self
        type(cms_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BMIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BMIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmi_type
        class(display_type)         , intent(inout)                 :: self
        type(cmi_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BMLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BMLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cml_type
        class(display_type)         , intent(inout)                 :: self
        type(cml_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BMCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BMCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmc_type
        class(display_type)         , intent(inout)                 :: self
        type(cmc_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D1_BMRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D1_BMRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cmr_type
        class(display_type)         , intent(inout)                 :: self
        type(cmr_type)              , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine show_D0_BCSK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BCSK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: ccs_type
        class(display_type)         , intent(inout)                 :: self
        type(ccs_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BCIK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BCIK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: cci_type
        class(display_type)         , intent(inout)                 :: self
        type(cci_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BCLK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BCLK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: ccl_type
        class(display_type)         , intent(inout)                 :: self
        type(ccl_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BCCK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BCCK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: ccc_type
        class(display_type)         , intent(inout)                 :: self
        type(ccc_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    module subroutine show_D0_BCRK(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: show_D0_BCRK
#endif
        use pm_kind, only: SKG => SK
        use pm_container, only: ccr_type
        class(display_type)         , intent(inout)                 :: self
        type(ccr_type)              , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \cond excluded
    interface dump

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine dump_D0(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: dump_D0
#endif
        use pm_kind, only: SKG => SK
        class(display_type)         , intent(inout)                 :: self
        class(*)                    , intent(in)                    :: object
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine dump_D1(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: dump_D1
#endif
        use pm_kind, only: SKG => SK
        class(display_type)         , intent(inout)                 :: self
        class(*)                    , intent(in)    __CONTIGUOUS    :: object(:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    module subroutine dump_D2(self, object, tmsize, bmsize, count, unit, advance, format, deliml, delimr, sticky)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: dump_D2
#endif
        use pm_kind, only: SKG => SK
        class(display_type)         , intent(inout)                 :: self
        class(*)                    , intent(in)    __CONTIGUOUS    :: object(:,:)
        integer(IK)                 , intent(in)    , optional      :: tmsize, bmsize, count, unit
        character(*, SK)            , intent(in)    , optional      :: format, advance
        logical(LK)                 , intent(in)    , optional      :: sticky
        character(*, SK)            , intent(in)    , optional      :: deliml, delimr
    end subroutine

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface
    !>  \endcond excluded

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return a generic or type/kind-specific IO format with the requested
    !>  specifications that can be use to read or write individual records in IO actions.
    !>
    !>  \param[in]  mold        :   The input vector of arbitrary size `(:)` of,<br>
    !>                              <ol>
    !>                                  <li>    type `character` of kind \SKALL,
    !>                                  <li>    type `integer` of kind \IKALL,
    !>                                  <li>    type `logical` of kind \LKALL,
    !>                                  <li>    type `complex` of kind \CKALL,
    !>                                  <li>    type `real` of kind \RKALL,
    !>                              </ol>
    !>                              whose kind type parameter determines the characteristics of the record fields for which the format is being constructed.<br>
    !>                              This argument offers an easy way of defining `format` for fields of specific intrinsic type in a record, particularly, fields of type `character` or `complex`.<br>
    !>                              For example, specifying a `complex` scalar for `mold` will automatically use the default left/right Fortran delimiters `()` for `complex` fields in the output `format`.<br>
    !>                              If any other input argument is also present, its value will override the default behavior dictated by the presence of the input argument `mold`.<br>
    !>                              The specific value and size of `mold` is completely ignored within the procedure.<br>
    !>                              For more possibilities, see the examples below.<br>
    !>                              (**optional**. If missing, the output `format` will be constructed for as generic as possible field records.)
    !>  \param[in]  prefix      :   The input scalar of type `character` of default kind \SK,
    !>                              containing the prefix to be added to the output `format`.<br>
    !>                              The prefix appears at the beginning of the record to be written via the output `format`.<br>
    !>                              (**optional**, default = `""`)
    !>  \param[in]  ed          :   The input scalar of type `character` of default kind \SK,
    !>                              containing the edit descriptor to be used for formatting each (sub)field.<br>
    !>                              Possible values include but are not limited to `A`, `I`, `E`, `EN`, `ES`, `F`, `G`.<br>
    !>                              (**optional**, default = `G`)
    !>  \param[in]  sep         :   The input scalar of type `character` of default kind \SK,
    !>                              containing the *repeat* field separator to be used in the output `format`.<br>
    !>                              (**optional**, default = `", "`)
    !>  \param[in]  deliml      :   The input scalar of type `character` of default kind \SK,
    !>                              containing the set of characters that serve as the **left-delimiter** for a group of subfields (for example, the real and imaginary components of fields of type `complex`).<br>
    !>                              For example,
    !>                              <ol>
    !>                                  <li> The input arguments `deliml = "(", subsep = ",", delimr = ")"` corresponds to the common Fortran format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$(\ms{x}, \ms{y})\f$.
    !>                                  <li> The input arguments `deliml = "", subsep = "", delimr = "i", signed = .true._LK` corresponds to the common mathematical format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$\ms{x} + \ms{y}i\f$.
    !>                              </ol>
    !>                              (**optional**, default = `"("` if `mold` is of type `complex`, \f$\ms{"}\f$ if `mold` is of type `character`, and nothing otherwise.)
    !>  \param[in]  subsep      :   The input scalar of type `character` of default kind \SK,
    !>                              containing the <i>sub</i>-field separator to be used in the output `format`.<br>
    !>                              An example of subfields are the two real and imaginary components of `complex` fields.<br>
    !>                              For example,
    !>                              <ol>
    !>                                  <li> The input arguments `deliml = "(", subsep = ",", delimr = ")"` corresponds to the common Fortran format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$(\ms{x}, \ms{y})\f$.
    !>                                  <li> The input arguments `deliml = "", subsep = "", delimr = "i", signed = .true._LK` corresponds to the common mathematical format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$\ms{x} + \ms{y}i\f$.
    !>                              </ol>
    !>                              However, the use of subfields is not necessarily limited to `complex` values and can be applied to any fixed-size group of fields in a record.<br>
    !>                              It is however, important to specify the number of subfields within a field of a record by setting the value of the input argument `subcount`.<br>
    !>                              (**optional**, default = the value of the input argument `sep`.)
    !>  \param[in]  delimr      :   The input scalar of type `character` of default kind \SK,
    !>                              containing the set of characters that serve as the **right-delimiter** for a group of subfields (for example, the real and imaginary components of fields of type `complex`).<br>
    !>                              For example,
    !>                              <ol>
    !>                                  <li> The input arguments `deliml = "(", subsep = ",", delimr = ")"` corresponds to the common Fortran format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$(\ms{x}, \ms{y})\f$.
    !>                                  <li> The input arguments `deliml = "", subsep = "", delimr = "i", signed = .true._LK` corresponds to the common mathematical format for displaying complex values with \f$\ms{x}\f$ and \f$\ms{y}\f$ components: \f$\ms{x} + \ms{y}i\f$.
    !>                              </ol>
    !>                              (**optional**, default = `")"` if `mold` is of type `complex`, \f$\ms{"}\f$ if `mold` is of type `character`, and nothing otherwise.)
    !>  \param[in]  count       :   The input scalar positive `integer` of default kind \IK containing the **repeat count** of groups of subfields in the record.<br>
    !>                              For example,
    !>                              <ol>
    !>                                  <li>    If the goal is to print `7` scalar `integer` numbers on screen, `count` can be set to `7`.<br>
    !>                                  <li>    If the goal is to print `7` scalar `complex` numbers on screen, `count` can be set to `7` if `subcount` is set to `2`, or to `14` if `subcount` is missing.<br>
    !>                              </ol>
    !>                              See the Fortran standard for the definition of and more information about *repeat count*.<br>
    !>                              If the number of entries is larger than the specified *repeat count*, the rest of entries will be
    !>                              transferred to the next record when performing IO via the output `format` from this generic interface.<br>
    !>                              (**optional**, default = `*`, that is, as many as needed.)
    !>  \param[in]  subcount    :   The input scalar positive `integer` of default kind \IK containing the **subfield count** within a single field of the record.<br>
    !>                              The input `subcount` is essentially the number of times the input `subsep` appears between subfields plus `1`.<br>
    !>                              For example, if the `format` is to be used for `complex` values, `subcount` can be set to `2` along with other appropriate arguments to construct Fortran-style `complex` formats.<br>
    !>                              (**optional**, default = `2` if `mold` is of type `complex` and `0` otherwise.)
    !>  \param[in]  width       :   The input scalar positive `integer` of default kind \IK containing the width of each each subfield (or if none exists, each field) in the record formatted via the output `format`.<br>
    !>                              (**optional**. The default value is computed based on the input arguments such that any field value can be read or written with a fixed field length. Use `0` to request dynamic minimum width for each (sub)field that is automatically specified by the processor.)
    !>  \param[in]  ndigit      :   The input scalar positive `integer` of default kind \IK containing the precision of the subfields or fields.<br>
    !>                              <ol>
    !>                                  <li>    If the (sub)field is of type `real` or `complex`, then `ndigit` represents the number of **digits after the decimal point**.<br>
    !>                                  <li>    If the (sub)field is of type `integer`, then `ndigit` represents the minimum number of digits to display.<br>
    !>                                          This means that if an `integer` value has fewer digits than `ndigit`, the left side of the value will be padded with **leading zeros**.<br>
    !>                                          This form of padding with *leading zeros* is particularly useful for creating a numbered list of file names.<br>
    !>                                          Beware that `ndigit` can be zero, in which case, if the field value is `0`, it will not be displayed on screen and blank will be printed.<br>
    !>                                          Note that `ndigit` takes effect only when the input argument `mold` is of type `integer` or if the edit descriptor argument `ed` is set to `I` or `i`.<br>
    !>                                          Set `ndigit = range(int(1, kind(mold)))` to create an output `format` that pads `integer` fields with
    !>                                          maximum possible number of *leading zeros* for the specified `integer` kind `mold`.<br>
    !>                                  <li>    For all other field types (e.g., `character`, `logical`, etc) the value of this argument is irrelevant and is ignored.<br>
    !>                              </ol>
    !>                              (**optional**, default is `precision(mold)` for `real` and `complex` and `1` for `integer`. In all other cases or if `mold` is missing, the default is processor dependent.)
    !>  \param[in]  lenexp      :   The input scalar `integer` of default kind \IK containing the *minimum* width of the exponent for real-valued entries in the records formatted via the output `format`.<br>
    !>                              Note that when the input argument `ndigit` is specified, the Fortran default exponent field length becomes `3`.<br>
    !>                              As such, if `ndigit` is present, then it is recommended to also explicitly specify `lenexp` must be explicitly set for output formats that are supposed to handle
    !>                              numbers with kind type parameter numbers that have exponent range that occupies more than 3 digits, e.g., \RK128, \CK128.<br>
    !>                              (**optional**, default = `0` corresponding to the minimum number of digits required to represent the exponent value, that is, without leading zeros. If present, `ndigit` must be also present.)
    !>  \param[in]  signed      :   The input scalar `logical` of default kind \LK.<br>
    !>                              <ol>
    !>                                  <li> If `.true.`, then the output `format` will print all positive numeric values with their signs.
    !>                                  <li> If `.false.`, then the output `format` will not print all positive numeric values with their signs.
    !>                              </ol>
    !>                              (**optional**, default = `.false.`)
    !>
    !>  \return
    !>  `format`                :   The output scalar `allocatable` of type `character` of default kind \SK containing the requested IO format.
    !>
    !>  \interface{getFormat}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getFormat
    !>      character(:), allocatable :: format
    !>
    !>      ! generic fields format.
    !>
    !>      format = getFormat  ( prefix = prefix &
    !>                          , ed = ed &
    !>                          , sep = sep &
    !>                          , deliml = deliml &
    !>                          , subsep = subsep &
    !>                          , delimr = delimr &
    !>                          , count = count &
    !>                          , subcount = subcount &
    !>                          , width = width &
    !>                          , ndigit = ndigit &
    !>                          , lenexp = lenexp &
    !>                          , signed = signed &
    !>                          )
    !>
    !>      ! type-specific fields format.
    !>
    !>      format = getFormat  ( mold(:) &
    !>                          , prefix = prefix &
    !>                          , ed = ed &
    !>                          , sep = sep &
    !>                          , deliml = deliml &
    !>                          , subsep = subsep &
    !>                          , delimr = delimr &
    !>                          , count = count &
    !>                          , subcount = subcount &
    !>                          , width = width &
    !>                          , ndigit = ndigit &
    !>                          , lenexp = lenexp &
    !>                          , signed = signed &
    !>                          )
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `present(lenexp) .and. present(ndigit) .or. .not. present(lenexp)` must hold for the corresponding input argument.<br>
    !>  The Fortran standard requires the precision field to be present when the exponent field is present.<br>
    !>  The condition `present(lenexp) .and. width /= 0 .or. .not. present(lenexp)` must hold for the corresponding input argument.<br>
    !>  The Fortran standard requires the specified width be non-zero in the presence of the lenexp field.<br>
    !>  The condition `ed == "g" .or. ed == "G" .or. width > 0` must hold for the corresponding input arguments.<br>
    !>  The Fortran standard requires a non-zero width (preferably, `width >= 5 + ndigit + lenexp`).<br>
    !>  The condition `(ed /= SKG_"f" .and. ed /= SKG_"F") .or. .not.present(lenexp)` must hold for the corresponding input arguments.<br>
    !>  \vericons
    !>
    !>  \pure
    !>
    !>  \see
    !>  [display_type](@ref pm_io::display_type)<br>
    !>
    !>  \example{getFormat}
    !>  \include{lineno} example/pm_io/getFormat/main.F90
    !>  \compilef{getFormat}
    !>  \output{getFormat}
    !>  \include{lineno} example/pm_io/getFormat/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \bug
    !>  \status \unresolved
    !>  \source \ifort{2021.8.0 20221119}
    !>  \desc
    !>  The \ifort{2021.8.0 20221119} cannot run the following function call within the implementation of the procedures,
    !>  \code{.F90}
    !>      getCountDigit(range(mold))
    !>  \endcode
    !>  yielding the following error,<br>
    !>  \code{.sh}
    !>      forrtl: severe (174): SIGSEGV, segmentation fault occurred
    !>      image              PC                Routine            Line        Source
    !>      libpthread-2.33.s  00001550E3A9C1F0  Unknown               Unknown  Unknown
    !>      libparamonte_fort  00001550E810D8B4  pm_mathnumsys_MP_         137  pm_mathNumSys@routines.inc.F90
    !>      libparamonte_fort  00001550E764778D  pm_io_MP_get               83  pm_io@routines.inc.F90
    !>      main.exe           000000000040CBE9  MAIN__                     83  main.F90
    !>      main.exe           000000000040938D  Unknown               Unknown  Unknown
    !>      libc-2.33.so       00001550E38BD565  __libc_start_main     Unknown  Unknown
    !>      main.exe           00000000004092AE  Unknown               Unknown  Unknown
    !>  \endcode
    !>  \remedy
    !>  For now, the `value` attribute of the input argument of function [getCountDigit](@ref pm_mathNumSys::getCountDigit) was converted to `intent(in)`.<br>
    !>
    !>  \final{getFormat}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 2:47 AM, Michigan
    interface getFormat

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    PURE module function getFormat_D0_Def(prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D0_Def
#endif
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if SK5_ENABLED
    PURE module function getFormat_D1_SK5(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_SK5
#endif
        use pm_kind, only: SKG => SK5
        character(*,SKG)    , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if SK4_ENABLED
    PURE module function getFormat_D1_SK4(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_SK4
#endif
        use pm_kind, only: SKG => SK4
        character(*,SKG)    , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if SK3_ENABLED
    PURE module function getFormat_D1_SK3(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_SK3
#endif
        use pm_kind, only: SKG => SK3
        character(*,SKG)    , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if SK2_ENABLED
    PURE module function getFormat_D1_SK2(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_SK2
#endif
        use pm_kind, only: SKG => SK2
        character(*,SKG)    , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if SK1_ENABLED
    PURE module function getFormat_D1_SK1(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_SK1
#endif
        use pm_kind, only: SKG => SK1
        character(*,SKG)    , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if IK5_ENABLED
    PURE module function getFormat_D1_IK5(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_IK5
#endif
        use pm_kind, only: IKG => IK5
        integer(IKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if IK4_ENABLED
    PURE module function getFormat_D1_IK4(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_IK4
#endif
        use pm_kind, only: IKG => IK4
        integer(IKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if IK3_ENABLED
    PURE module function getFormat_D1_IK3(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_IK3
#endif
        use pm_kind, only: IKG => IK3
        integer(IKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if IK2_ENABLED
    PURE module function getFormat_D1_IK2(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_IK2
#endif
        use pm_kind, only: IKG => IK2
        integer(IKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if IK1_ENABLED
    PURE module function getFormat_D1_IK1(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_IK1
#endif
        use pm_kind, only: IKG => IK1
        integer(IKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if LK5_ENABLED
    PURE module function getFormat_D1_LK5(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_LK5
#endif
        use pm_kind, only: LKG => LK5
        logical(LKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if LK4_ENABLED
    PURE module function getFormat_D1_LK4(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_LK4
#endif
        use pm_kind, only: LKG => LK4
        logical(LKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if LK3_ENABLED
    PURE module function getFormat_D1_LK3(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_LK3
#endif
        use pm_kind, only: LKG => LK3
        logical(LKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if LK2_ENABLED
    PURE module function getFormat_D1_LK2(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_LK2
#endif
        use pm_kind, only: LKG => LK2
        logical(LKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if LK1_ENABLED
    PURE module function getFormat_D1_LK1(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_LK1
#endif
        use pm_kind, only: LKG => LK1
        logical(LKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if CK5_ENABLED
    PURE module function getFormat_D1_CK5(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_CK5
#endif
        use pm_kind, only: CKG => CK5
        complex(CKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if CK4_ENABLED
    PURE module function getFormat_D1_CK4(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_CK4
#endif
        use pm_kind, only: CKG => CK4
        complex(CKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if CK3_ENABLED
    PURE module function getFormat_D1_CK3(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_CK3
#endif
        use pm_kind, only: CKG => CK3
        complex(CKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if CK2_ENABLED
    PURE module function getFormat_D1_CK2(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_CK2
#endif
        use pm_kind, only: CKG => CK2
        complex(CKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if CK1_ENABLED
    PURE module function getFormat_D1_CK1(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_CK1
#endif
        use pm_kind, only: CKG => CK1
        complex(CKG)        , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module function getFormat_D1_RK5(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)           , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if RK4_ENABLED
    PURE module function getFormat_D1_RK4(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)           , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if RK3_ENABLED
    PURE module function getFormat_D1_RK3(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)           , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if RK2_ENABLED
    PURE module function getFormat_D1_RK2(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)           , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

#if RK1_ENABLED
    PURE module function getFormat_D1_RK1(mold, prefix, ed, sep, deliml, subsep, delimr, count, subcount, width, ndigit, lenexp, signed) result(format)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFormat_D1_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)           , intent(in)                :: mold(:)
        character(*, SK)    , intent(in)    , optional  :: prefix, ed, sep, deliml, subsep, delimr
        integer(IK)         , intent(in)    , optional  :: count, subcount, width, ndigit, lenexp
        logical(LK)         , intent(in)    , optional  :: signed
        character(:, SK)    , allocatable               :: format
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!    !>  \brief
!    !>  Generate and return the minimum required IO field width for a single value of the same type and kind as the input `mold`,
!    !>  such that IO with the output field length does not overflow.
!    !>
!    !>  \details
!    !>  The primary usage of the procedures of this generic interface is
!    !>  to use the output of these procedures as the `width` argument of
!    !>  [getFormat](@ref pm_io::getFormat).<br>
!    !>
!    !>  \param[in]  mold    :   The input scalar of
!    !>                          <ul>
!    !>                              <li>    type `integer` of kind \IKALL,
!    !>                              <li>    type `complex` of kind \CKALL,
!    !>                              <li>    type `real` of kind \RKALL,
!    !>                          </ul>
!    !>                          whose kind type parameter is used to infer the minimum IO field length required without the possibility of overflow.
!    !>
!    !>  \return
!    !>  `lenField`          :   The output scalar of type `integer` of default kind \IK containing the minimum IO field length.
!    !>
!    !>  \interface{getLenFieldMin}
!    !>  \code{.F90}
!    !>
!    !>      use pm_kind, only: IK
!    !>      use pm_io, only: getLenFieldMin
!    !>      integer(IK) :: lenField
!    !>
!    !>      lenField = getLenFieldMin(mold)
!    !>
!    !>  \endcode
!    !>
!    !>  \note
!    !>  For `complex` values, the output `lenField` is the minimum required
!    !>  field length for **each (real or imaginary) component** of the complex value.<br>
!    !>
!    !>  \pure
!    !>
!    !>  \elemental
!    !>
!    !>  \see
!    !>  [display_type](@ref pm_io::display_type)<br>
!    !>  [getFormat](@ref pm_io::getFormat)<br>
!    !>  [getFormat](@ref pm_io::getFormat)<br>
!    !>
!    !>  \example{getLenFieldMin}
!    !>  \include{lineno} example/pm_io/getLenFieldMin/main.F90
!    !>  \compilef{getLenFieldMin}
!    !>  \output{getLenFieldMin}
!    !>  \include{lineno} example/pm_io/getLenFieldMin/main.out.F90
!    !>
!    !>  \test
!    !>  [test_pm_io](@ref test_pm_io)
!    !>
!    !>  \bug
!    !>  \status \unresolved
!    !>  \source \ifort{2021.8.0 20221119}
!    !>  \desc
!    !>  The \ifort{2021.8.0 20221119} cannot run the following function call within the implementation of the procedures,
!    !>  \code{.F90}
!    !>      getCountDigit(range(mold))
!    !>  \endcode
!    !>  yielding the following error,<br>
!    !>  \code{.sh}
!    !>      forrtl: severe (174): SIGSEGV, segmentation fault occurred
!    !>      image              PC                Routine            Line        Source
!    !>      libpthread-2.33.s  00001550E3A9C1F0  Unknown               Unknown  Unknown
!    !>      libparamonte_fort  00001550E810D8B4  pm_mathnumsys_MP_         137  pm_mathNumSys@routines.inc.F90
!    !>      libparamonte_fort  00001550E764778D  pm_io_MP_get          83  pm_io@routines.inc.F90
!    !>      main.exe           000000000040CBE9  MAIN__                     83  main.F90
!    !>      main.exe           000000000040938D  Unknown               Unknown  Unknown
!    !>      libc-2.33.so       00001550E38BD565  __libc_start_main     Unknown  Unknown
!    !>      main.exe           00000000004092AE  Unknown               Unknown  Unknown
!    !>  \endcode
!    !>  \remedy
!    !>  For now, `range(mold)` is saved in a variable and then passed to the function `getCountDigit()`.<br>
!    !>
!    !>  \todo
!    !>  \pmed
!    !>  A new interface for computing the maximum field length without redundant blanks for a specific given input **value** or collection of values should be added.<br>
!    !>
!    !>  \final{getLenFieldMin}
!    !>
!    !>  \author
!    !>  \AmirShahmoradi, Oct 16, 2009, 2:47 AM, Michigan
!    interface getLenFieldMin
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!
!#if IK5_ENABLED
!    pure elemental module function getLenFieldMin_D0_IK5(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_IK5
!#endif
!        use pm_kind, only: IKG => IK5
!        integer(IKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if IK4_ENABLED
!    pure elemental module function getLenFieldMin_D0_IK4(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_IK4
!#endif
!        use pm_kind, only: IKG => IK4
!        integer(IKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if IK3_ENABLED
!    pure elemental module function getLenFieldMin_D0_IK3(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_IK3
!#endif
!        use pm_kind, only: IKG => IK3
!        integer(IKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if IK2_ENABLED
!    pure elemental module function getLenFieldMin_D0_IK2(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_IK2
!#endif
!        use pm_kind, only: IKG => IK2
!        integer(IKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if IK1_ENABLED
!    pure elemental module function getLenFieldMin_D0_IK1(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_IK1
!#endif
!        use pm_kind, only: IKG => IK1
!        integer(IKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!#if CK5_ENABLED
!    pure elemental module function getLenFieldMin_D0_CK5(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_CK5
!#endif
!        use pm_kind, only: CKG => CK5
!        complex(CKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if CK4_ENABLED
!    pure elemental module function getLenFieldMin_D0_CK4(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_CK4
!#endif
!        use pm_kind, only: CKG => CK4
!        complex(CKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if CK3_ENABLED
!    pure elemental module function getLenFieldMin_D0_CK3(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_CK3
!#endif
!        use pm_kind, only: CKG => CK3
!        complex(CKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if CK2_ENABLED
!    pure elemental module function getLenFieldMin_D0_CK2(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_CK2
!#endif
!        use pm_kind, only: CKG => CK2
!        complex(CKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if CK1_ENABLED
!    pure elemental module function getLenFieldMin_D0_CK1(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_CK1
!#endif
!        use pm_kind, only: CKG => CK1
!        complex(CKG)    , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!#if RK5_ENABLED
!    pure elemental module function getLenFieldMin_D0_RK5(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_RK5
!#endif
!        use pm_kind, only: RKG => RK5
!        real(RKG)       , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if RK4_ENABLED
!    pure elemental module function getLenFieldMin_D0_RK4(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_RK4
!#endif
!        use pm_kind, only: RKG => RK4
!        real(RKG)       , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if RK3_ENABLED
!    pure elemental module function getLenFieldMin_D0_RK3(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_RK3
!#endif
!        use pm_kind, only: RKG => RK3
!        real(RKG)       , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if RK2_ENABLED
!    pure elemental module function getLenFieldMin_D0_RK2(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_RK2
!#endif
!        use pm_kind, only: RKG => RK2
!        real(RKG)       , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!#if RK1_ENABLED
!    pure elemental module function getLenFieldMin_D0_RK1(mold) result(lenField)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: getLenFieldMin_D0_RK1
!#endif
!        use pm_kind, only: RKG => RK1
!        real(RKG)       , intent(in)    :: mold
!        integer(IK)                     :: lenField
!    end function
!#endif
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    end interface
!
!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

contains

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!    !>  \brief
!    !>  Set the output optional arguments `iostat, iomsg` (if present) to their corresponding input values `stat, msg`,
!    !>  or if `iostat` is missing, call the `error stop msg` statement.
!    !>
!    !>  \param[in]     stat    :   The input scalar `integer` of default kind \IK.<br>
!    !>                             A non-zero value implies the occurrence of an error.<br>
!    !>                             Non-zero values are returned by all intrinsic Fortran IO statements (`open()`, `close()`, `inquire()`, `read()`, `write()`) if an IO error occurs.
!    !>  \param[in]     msg     :   The input scalar `character` of default kind \SK representing the contents of the output argument `iomsg`.<br>
!    !>                             If the output argument `iostat` is missing and `stat` is non-zero, then `msg` will be passed to the `error stop` statement.
!    !>  \param[out]    iostat  :   The output scalar `integer` of default kind \IK that, if present, is set to the input `stat`.<br>
!    !>                             (**optional**. If missing and `stat` is non-zero, then the program halts by calling `error stop msg`.)
!    !>  \param[inout]  iomsg   :   The input/output scalar `character` of default kind \SK.<br>
!    !>                             <ol>
!    !>                                 <li>    If `iomsg` is present and `stat` is non-zero, it is set to the input `msg` on return.<br>
!    !>                                 <li>    If `iomsg` is present and `stat` is zero, the input contents of `iomsg` will not change on return.<br>
!    !>                             </ol>
!    !>                             (**optional**. The presence of the output `iomsg` is relevant only if `iostat` is also present.)
!    !>
!    !>  \interface{setStatIO}
!    !>  \code{.F90}
!    !>
!    !>      use pm_io, only: setStatIO
!    !>
!    !>      ioFailed = setStatIO(stat, msg, iostat = iostat, iomsg = iomsg)
!    !>
!    !>  \endcode
!    !>
!    !>  \note
!    !>  This procedure is primarily intended for handling of IO errors within the parent module ([pm_io](@ref pm_io)).
!    !>
!    !>  \see
!    !>  [setFileClosed](@ref setFileClosed)<br>
!    !>  [getCountRecord](@ref getCountRecord)<br>
!    !>  [getCountRecordLeft](@ref getCountRecordLeft)<br>
!    !>  [setRecordFrom](@ref setRecordFrom)<br>
!    !>  [setContentsFrom](@ref setContentsFrom)
!    !>
!    !>  \test
!    !>  [test_pm_io](@ref test_pm_io)
!    !>
!    !>  \final{setStatIO}
!    !>
!    !>  \author
!    !>  \AmirShahmoradi, Tuesday March 7, 2017, 2:22 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
!    pure subroutine setStatIO(stat, msg, iostat, iomsg)
!#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
!        !DEC$ ATTRIBUTES DLLEXPORT :: setStatIO
!#endif
!        integer(IK)     , intent(in)                :: stat
!        character(*, SK), intent(in)                :: msg
!        integer(IK)     , intent(out)   , optional  :: iostat
!        character(*, SK), intent(inout) , optional  :: iomsg
!        if (present(iostat)) then
!            iostat = stat
!            if (present(iomsg)) iomsg = msg
!        else
!            if (stat /= 0_IK) error stop SK_"FATAL RUNTIME ERROR: " // trim(adjustl(msg))
!        end if
!    end subroutine

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidAccess(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"sequential" .or. value == SK_"direct" .or. value == SK_"stream", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidAction(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"readwrite" .or. value == SK_"read" .or. value == SK_"write", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidAsynchronous(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"no" .or. value == SK_"yes", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidBlank(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"null" .or. value == SK_"zero", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidDecimal(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"point" .or. value == SK_"comma", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidDelim(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"none" .or. value == SK_"apostrophe" .or. value == SK_"quote", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidEncoding(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"default" .or. value == SK_"utf-8", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidForm(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"formatted" .or. value == SK_"unformatted", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidPad(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"yes" .or. value == SK_"no", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidPosition(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"asis" .or. value == SK_"rewind" .or. value == SK_"append", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidRecl(value) result(isValid)
        integer(IK)         , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value > 0_IK, LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidRound(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"processor_defined" .or. value == SK_"compatible" .or. value == SK_"nearest" .or. value == SK_"zero" .or. value == SK_"down" .or. value == SK_"up", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidSign(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"processor_defined" .or. value == SK_"suppress" .or. value == SK_"plus", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    pure function isValidStatus(value) result(isValid)
        character(*, SK)    , intent(in)    :: value
        logical(LK)                         :: isValid
        isValid = logical(value == SK_"unknown" .or. value == SK_"scratch" .or. value == SK_"replace" .or. value == SK_"new" .or. value == SK_"old", LK)
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return `.true.` if the input unit corresponds to one of the processor
    !>  preconnected units: `output_unit`, `input_unit`, `error_unit`, otherwise return `.false.`.
    !>
    !>  \param[in]  unit    :   The input scalar of type `integer` of default kind \IK representing the unit number to be tested.
    !>
    !>  \return
    !>  `preconnected`      :   The output scalar of type `logical` of default kind \LK representing that is `.true.` if and only if
    !>                          the input unit corresponds to one of the preconnected units by the processor.
    !>
    !>  \interface{isPreconnected}
    !>  \code{.F90}
    !>
    !>      use pm_kind, only: IK
    !>      use pm_io, only: isPreconnected
    !>      logical(LK) :: preconnected
    !>      integer(IK) :: unit
    !>
    !>      preconnected = isPreconnected(unit)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \elemental
    !>
    !>  \remark
    !>  If no unit is connected to the input `file`, a value of `-1` will be returned.
    !>
    !>  \remark
    !>  This procedure is primarily useful for bypassing the existing bug in
    !>  Intel Fortran compiler with the `newunit` specifier of the `open` statement.
    !>
    !>  \see
    !>  [getFileUnit](@ref pm_io::getFileUnit)<br>
    !>
    !>  \example{isPreconnected}
    !>  \include{lineno} example/pm_io/isPreconnected/main.F90
    !>  \compilef{isPreconnected}
    !>  \output{isPreconnected}
    !>  \include{lineno} example/pm_io/isPreconnected/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{isPreconnected}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    pure elemental function isPreconnected(unit) result(preconnected)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isPreconnected
#endif
        use iso_fortran_env, only: output_unit, input_unit, error_unit
        integer(IK)     , intent(in)    :: unit
        logical(LK)                     :: preconnected
        preconnected = logical(unit == int(output_unit, IK) .or. unit == int(input_unit, IK) .or. unit == int(error_unit, IK), LK)
    end function isPreconnected

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Generate and return a random new unconnected file unit number that could be assigned to the `unit` specifier of
    !>  the Fortran intrinsic `open` statement. Optionally, return the unit number of a file whose path is given by the
    !>  input argument `file`.
    !>
    !>  \details
    !>  The behavior of this generic interface is fully dictated by the Fortran intrinsic `inquire()` when the optional argument `file` is present.<br>
    !>  For example, if the optional argument is present but no unit is connected to the file or the file does not exists, the `unit` returned is `-1`.<br>
    !>
    !>  \param[in]  file    :   The input scalar of type `character` of default kind \SK representing the path of the
    !>                          file whose unit is to be returned, if it is already opened.<br>
    !>                          (**optional**, if missing, a new unit number, that is not connected to any file, will be returned.)
    !>
    !>  \return
    !>  `unit`              :   The output scalar of type `integer` of default kind \IK containing<br>
    !>                          <ol>
    !>                              <li>    the unit number of the input `file` if it exists and is already connected.<br>
    !>                              <li>    the value `-1` if the input argument `file` is present but does not exist or is not already connected.<br>
    !>                              <li>    a valid random unit number that is not connected to any existing file, if the input argument `file` is missing.<br>
    !>                          </ol>
    !>
    !>  \interface{getFileUnit}
    !>  \code{.F90}
    !>
    !>      use pm_io, only: getFileUnit
    !>
    !>      unit = getFileUnit()
    !>      unit = getFileUnit(file)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  As per the Fortran standard, if no unit is connected to the input `file`, a value of `-1` will be returned.<br>
    !>
    !>  \impure
    !>
    !>  \elemental
    !>
    !>  \remark
    !>  This procedure is primarily useful for bypassing the existing bug in the
    !>  Intel Fortran compiler with the `newunit` specifier of the `open` statement.<br>
    !>
    !>  \see
    !>  [isPreconnected](@ref pm_io::isPreconnected)<br>
    !>
    !>  \example{getFileUnit}
    !>  \include{lineno} example/pm_io/getFileUnit/main.F90
    !>  \compilef{getFileUnit}
    !>  \output{getFileUnit}
    !>  \include{lineno} example/pm_io/getFileUnit/main.out.F90
    !>
    !>  \test
    !>  [test_pm_io](@ref test_pm_io)
    !>
    !>  \final{getFileUnit}
    !>
    !>  \author
    !>  \AmirShahmoradi, Tuesday March 7, 2017, 3:50 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas at Austin
    impure elemental function getFileUnit(file) result(unit)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getFileUnit
#endif
        character(*, SK), intent(in), optional  :: file
        integer(IK)                             :: unit
        logical(LK)                             :: opened
        if (present(file)) then
            inquire(file = file, number = unit)
        else
            unit = 100_IK
            do
                inquire(unit = unit, opened = opened)
                if (.not. opened) return
                unit = unit + 1_IK
            end do
        end if
    end function

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end module pm_io ! LCOV_EXCL_LINE
