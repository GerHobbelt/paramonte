!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!                                                                                                                            !!!!
!!!!    ParaMonte: Parallel Monte Carlo and Machine Learning Library.                                                           !!!!
!!!!                                                                                                                            !!!!
!!!!    Copyright (C) 2012-present, The Computational Data Science Lab                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!    This file is part of the ParaMonte library.                                                                             !!!!
!!!!                                                                                                                            !!!!
!!!!    LICENSE                                                                                                                 !!!!
!!!!                                                                                                                            !!!!
!!!!       https://github.com/cdslaborg/paramonte/blob/main/LICENSE.md                                                          !!!!
!!!!                                                                                                                            !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!>  \brief
!>  This module contains classes and procedures for non-adaptive and adaptive global numerical quadrature and Cauchy Principal Value
!>  of 1D functions with various types of singularities and points of difficulties via the Gauss-Kronrod and Clenshaw-Curtis quadrature formulae.<br>
!>
!>  \details
!>
!>  The algorithms of this module significantly extend the original routines of the venerable QuadPack library in FORTRAN77.<br>
!>
!>  Usage guidelines
!>  ----------------
!>
!>  **Question**<br>
!>  Is there a hassle-free simple nimble reliable numerical integrator that I can use as the first try?<br>
!>  **Answer:**<br>
!>  **YES**, as described below.<br>
!>
!>  <ol>
!>      <li>    The generic interface [isFailedQuad](@ref pm_quadPack::isFailedQuad)
!>              offers simple highly flexible set of routines for globally adaptive numerical integration of arbitrary 1D
!>              functions with varying degrees of difficulties (including Cauchy-type singularities) within the domain of integration.<br>
!>              The procedures of this generic interface rely on a fixed Gauss-Kronrod quadrature rule (10-12) to carry out the integration.<br>
!>      <li>    If you need specific or custom Gauss-Kronrod quadrature rules other than the default offered by [isFailedQuad](@ref pm_quadPack::isFailedQuad)
!>              or if the integration is going to be carried out many many times throughout the program (making absolute performance and thrifty memory management critical),
!>              use the less flexible but more performant interface [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
!>      <li>    If you prefer to compute the integral by a fixed Gauss-Kronrod quadrature rule without any error estimates,
!>              or with estimating error by applying progressively higher order Gauss-Kronrod quadrature rules,
!>              then use the procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).<br>
!>              In this case, any **error estimate** for the integration must be obtained manually by the user
!>              by computing the integral via progressively higher order Gauss-Kronrod quadrature rules until
!>              the desired accuracy is achieved.<br>
!>  </ol>
!>
!>  Background
!>  ----------
!>
!>  **Gaussian Quadrature** is an approximation of the definite integral of a function,
!>  usually stated as a weighted sum of function values at specified points within the integration domain.<br>
!>  An \f$n\f$-point Gaussian quadrature rule, named after **Carl Friedrich Gauss**, is a quadrature rule constructed
!>  to yield an **exact result** for **polynomials** of degree \f$2n − 1\f$ or less by a suitable choice of the nodes \f$x_i\f$ and weights \f$w_i\f$ for \f$i = \{1, \ldots, n\}\f$.<br>
!>  The modern formulation using orthogonal polynomials was developed by **Carl Gustav Jacobi** in 1826.<br>
!>  The most common domain of integration for such a rule is taken as \f$[−1, 1]\f$, so the rule is stated as
!>  \f{equation}{
!>      \large
!>      \int_{-1}^{+1} f(x) \mathrm{d}x \approx \sum_{i = 1}^{n} w_i f(x_i) ~,
!>  \f}
!>  which is exact for a polynomial of degree \f$2n − 1\f$ or less. This exact rule is known as the **Gauss-Legendre quadrature rule**.<br>
!>  The integration of polynomials is trivial and is rarely done via numerical methods.<br>
!>  However, transcendental and numerically defined functions are frequently integrated via Gaussian quadrature, and the defining problem becomes how to estimate the remainder.<br>
!>  The Gauss-Legendre quadrature rule will only be an accurate approximation to the integral above **if** \f$f(x)\f$ is well-approximated by a polynomial of degree \f$2n − 1\f$ or less on \f$[−1, 1]\f$.<br>
!>  The Gauss-Legendre quadrature rule is typically not used for integrable functions with endpoint singularities.<br>
!>  The key to the Gaussian quadrature is the derivation of the nodes and weights for which established formulae exist (e.g., [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK)).<br>
!>  It is possible to compute a Gaussian quadrature of order \f$n\f$ and another of order (e.g., \f$2n+1\f$) and use the difference as an error estimate.<br>
!>  However, this is not optimal, as the zeros of the Legendre polynomials (i.e., the nodes of Gaussian quadrature) are never the same for different orders.<br>
!>  This requires \f$3n + 1\f$ function evaluations to be performed.<br>
!>
!>  Gauss-Kronrod quadrature
!>  ------------------------
!>
!>  The error estimation challenge mentioned above limits the direct application of the Gauss-Legendre quadrature to integration problems.<br>
!>  Higher order Gauss-Legendre quadrature (corresponding to higher numbers of nodes and weights) does not necessarily overlap with the lower-order nodes.<br>
!>  This means that the lower-order calculations of \f$f(x)\f$ cannot be used in subsequent higher-order Gauss-Legendre quadrature, which has two consequences,<br>
!>  <ol>
!>      <li>    difficulty in estimating the integration error,<br>
!>      <li>    wasting of computational power due to non-overlapping of the lower and higher order Gauss-Legendre quadrature.<br>
!>  </ol>
!>
!>  The **Gauss-Kronrod quadrature** is an extension of Gaussian quadrature, enabling the use of lower-order nodes and computations in higher-order quadrature.<br>
!>  Kronrod (1964) considered the problem of how to interleave nodes into a Gauss-Legendre quadrature in such a way that all previous function evaluations can be reused,
!>  while increasing the order of polynomials that can be integrated exactly.<br>
!>  Kronrod discovered that one could integrate polynomials of degree \f$3n + 1\f$ by adding \f$n + 1\f$ nodes (computed from the zeros of the Legendre-Stieltjes polynomials)
!>  to a Gaussian quadrature of order \f$n\f$.<br>
!>  Later, Patterson (1968, 1969) showed how to compute continued extensions of this kind (e.g., [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK)).<br>
!>  This allows an a posteriori error estimate to be provided while still preserving exponential convergence.<br>
!>  This error estimate is, however, frequently pessimistic. This is particularly true when the estimated error is smaller than \f$1.25 \times 10^{-6}\f$
!>  meaning that the integration result is generally much more accurate than what is understood from the error estimate.<br>
!>
!>  The Gauss-Kronrod is a powerful driver in Adaptive Global Quadrature methods (e.g., as implemented in [getQuadGK](@ref pm_quadPack::getQuadGK)).<br>
!>
!>  Clenshaw-Curtis quadrature
!>  --------------------------
!>
!>  The **Clenshaw-Curtis quadrature** (Clenshaw and Curtis (1960)) handles the numerical computation of
!>  the integral of a function \f$f(x)\f$ over a finite interval, with weight function \f$w = 1\f$.<br>
!>  The idea of Clenshaw-Curtis integration is to approximate \f$f(x)\f$ by a truncated Chebyshev polynomials expansion, which can be integrated exactly.<br>
!>
!>  For functions with a slowly convergent Chebyshev series expansion, use of the Clenshaw-Curtis method is not advisable.<br>
!>  However, there is a possibility to retain the advantage of the computational ease of the Clenshaw-Curtis method while
!>  extending its practical applicability to functions with slowly convergent Chebyshev expansions.<br>
!>  This is accomplished by transferring the difficult part of the integrand, which causes the slow rate
!>  of convergence of the Chebyshev series (e.g. a rapidly varying factor), into a weight function.<br>
!>  Even certain singular weight functions, becoming infinite somewhere in the integration interval, can be treated successfully by this technique.<br>
!>  This is makes the Clenshaw-Curtis quadrature rules particularly suitable for computing the
!>  [Cauchy Principal Value](https://en.wikipedia.org/wiki/Cauchy_principal_value)
!>  of arbitrary functions when combined with the Gauss-Kronrod rules.<br>
!>
!>  \see
!>  [Robert Piessens et al., 1983, QuadPack: A Subroutine Package for Automatic Integration](https://www.google.com/books/edition/Quadpack/ctL6CAAAQBAJ?hl=en&gbpv=1&pg=PP1&printsec=frontcover)<br>
!>  [Laurie, 1997, Calculation of gauss-kronrod quadrature rules](https://www.ams.org/mcom/1997-66-219/S0025-5718-97-00861-2/S0025-5718-97-00861-2.pdf).<br>
!>  [Kronrod, 1965, Nodes and weights of quadrature formulas](https://api.semanticscholar.org/CorpusID:123027420).<br>
!>  Numerical Recipes in Fortran by Press et al., 1992, p. 154<br>
!>  [QuadPack2](https://github.com/jacobwilliams/quadpack): A modernization of the original venerable QuadPack library by Jacob Williams<br>
!>  QuadPack FORTRAN77 and Fortran90 version by John Burkardt<br>
!>  QuadPack by the GNU Scientific Library<br>
!>
!>  \warning
!>  The predefined Gauss-Kronrod rules of this modules are accurate up to 100 significant digits.<br>
!>  While this is likely more than enough precision for the next few decades, reaching this precision limit is unavoidable.<br>
!>  To avoid potential loss of precision and inaccurate integrations, the procedures of this library contain a runtime check
!>  to ensure the requested integration precision is within the limits of the precision of the constants of this library.<br>
!>  Note that this limitation only exists with predefined Gauss-Kronrod rules of this library.<br>
!>  The generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) can be always
!>  used at any distant future, for example, the year [one million and a half](https://youtu.be/cdNnlfZgnY8),
!>  to compute the Gauss-Kronrod rules for subsequent usage by the integrators of this module.<br>
!>
!>  \test
!>  [test_pm_quadPack](@ref test_pm_quadPack)<br>
!>
!>  \final
!>
!>  \author
!>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

module pm_quadPack

    use pm_kind, only: SK, IK, LK, RKH, RKB
    use pm_mathConst, only: ninf, ninf_type
    use pm_mathConst, only: pinf, pinf_type

    implicit none

    character(*, SK), parameter :: MODULE_NAME = "@pm_quadPack"

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the derived type for constructing objects that signify the computation of the Cauchy Principal Value of arbitrary function
    !>  whose Cauchy singularities is stored in the `cs` components of the objects of this type.<br>
    !>
    !>  \details
    !>  The Cauchy type of singularity represented by this derived type has the form,
    !>  \f{equation}{
    !>      \frac{1}{(x - c)} ~,~ x \in (\ms{lb}, \ms{ub}) ~,~ \ms{lb} < 0 < \ms{ub}
    !>  \f}
    !>  where \f$(\ms{lb}, \ms{ub})\f$ represent the integration bounds.<br>
    !>
    !>  Objects of this derived type can be passed to the primary integrators of the parent modules of this derived type:<br>
    !>  <ol>
    !>      <li>    [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>      <li>    [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  </ol>
    !>
    !>  \interface{wcauchy_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wcauchy_type
    !>      type(wcauchy_type) :: wcauchy
    !>
    !>      wcauchy = wcauchy_type(cs)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad).<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{wcauchy_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    type     :: wcauchy_type
        real(RKH) :: cs !<  \public The scalar component of type `real` of kind \RKH (the highest (precision) real kind available in the ParaMonte library, representing the point of singularity in the Cauchy weight of an integrand function: \f$\frac{1}{x - \ms{cs}}\f$.<br>
    end type

    !>  \brief
    !>  Return an object of type [wcauchy_type](@ref pm_quadPack::wcauchy_type) containing the Cauchy singularity of a weight of the form,
    !>  \f{equation}{
    !>      \frac{1}{(x - c)} ~,~ x \in (\ms{lb}, \ms{ub}) ~,~ \ms{lb} < 0 < \ms{ub}
    !>  \f}
    !>  where \f$(\ms{lb}, \ms{ub})\f$ represent the integration bounds.<br>
    !>
    !>  \devnote
    !>  This generic interface exists because of the lack of support for PDTs in gfortran,
    !>  requiring the derived type [wcauchy_type](@ref pm_quadPack::wcauchy_type) to have `cs` component with the highest precision.<br>
    !>
    !>  \param[in]  cs  :   The input scalar of type `real` of kind \RKALL, containing the Cauchy singularity.<br>
    !>
    !>  \return
    !>  `wcauchy`       :   The output scalar object of type [wcauchy_type](@ref pm_quadPack::wcauchy_type) containing the Cauchy singularity.<br>
    !>
    !>  \interface{wcauchy_typer}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wcauchy_type
    !>      type(wcauchy_type) :: wcauchy
    !>
    !>      wcauchy = wcauchy_type(cs)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  [wcauchy_type](@ref pm_quadPack::wcauchy_type)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)<br>
    !>
    !>  \final{wcauchy_typer}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface wcauchy_type

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE elemental module function wcauchy_typer_RK5(cs) result(wcauchy)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcauchy_typer_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)       , intent(in)            :: cs
        type(wcauchy_type)                      :: wcauchy
    end function
#endif

#if RK4_ENABLED
    PURE elemental module function wcauchy_typer_RK4(cs) result(wcauchy)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcauchy_typer_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)       , intent(in)            :: cs
        type(wcauchy_type)                      :: wcauchy
    end function
#endif

#if RK3_ENABLED
    PURE elemental module function wcauchy_typer_RK3(cs) result(wcauchy)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcauchy_typer_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)       , intent(in)            :: cs
        type(wcauchy_type)                      :: wcauchy
    end function
#endif

#if RK2_ENABLED
    PURE elemental module function wcauchy_typer_RK2(cs) result(wcauchy)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcauchy_typer_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)       , intent(in)            :: cs
        type(wcauchy_type)                      :: wcauchy
    end function
#endif

#if RK1_ENABLED
    PURE elemental module function wcauchy_typer_RK1(cs) result(wcauchy)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcauchy_typer_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)       , intent(in)            :: cs
        type(wcauchy_type)                      :: wcauchy
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the derived type for constructing objects that signify the computation of the integral of an arbitrary Sine-weighted function.
    !>
    !>  \details
    !>  The specified weight via this derive type has the form,
    !>  \f{equation}{
    !>      \sin(\omega x) ~,
    !>  \f}
    !>  that is used to signify the computation of the computation of the (Fourier transform) integral of the form:<br>
    !>  \f{equation}{
    !>      \int^{\ms{ub}}_{\ms{lb}} \sin(\omega x) f(x) dx
    !>  \f}
    !>  where \f$\omega\f$ and \f$f(x)\f$ are user-specified.<br>
    !>
    !>  Objects of this derived type can be passed to the primary integrators of the parent modules of this derived type:<br>
    !>  <ol>
    !>      <li>    [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>      <li>    [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  </ol>
    !>
    !>  \interface{wsin_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wsin_type
    !>      type(wsin_type) :: wsin_type
    !>
    !>      wsin = wsin_type(omega)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad).<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{wsin_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    type     :: wsin_type
        real(RKH) :: omega  !<  \public The scalar component of type `real` of kind \RKH (the highest (precision) real kind available in the ParaMonte library, representing the frequency coefficient of the weight.<br>
    end type

    !>  \brief
    !>  Return an object of type [wsin_type](@ref pm_quadPack::wsin_type) containing the frequency of the Sine weight of a Fourier transform integration.<br>
    !>
    !>  \devnote
    !>  This generic interface exists because of the lack of support for PDTs in gfortran,
    !>  requiring the derived type [wsin_type](@ref pm_quadPack::wsin_type) to have `omega` component with the highest precision.<br>
    !>
    !>  \param[in]  omega   :   The input scalar or array of arbitrary rank of type `real` of kind \RKALL,
    !>                          containing the angular frequency of the oscillatory Sine weight in the
    !>                          integrand whose integral is to be computed.
    !>
    !>  \return
    !>  `wsin`              :   The scalar or array of the same shape as `omega` of type `Sin_type` that uniquely
    !>                          determines the type and kind of the Sine weight to be used in the integrand.
    !>
    !>  \interface{wsin_typer}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wsin_type
    !>      type(wsin_type) :: wsin
    !>
    !>      wsin = wsin_type(omega)
    !>      print *, wsin%omega
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  [wsin_type](@ref pm_quadPack::wsin_type)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)<br>
    !>
    !>  \final{wsin_typer}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface wsin_type

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE elemental module function wsin_typer_RK5(omega) result(wsin)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wsin_typer_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)       , intent(in)            :: omega
        type(wsin_type)                         :: wsin
    end function
#endif

#if RK4_ENABLED
    PURE elemental module function wsin_typer_RK4(omega) result(wsin)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wsin_typer_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)       , intent(in)            :: omega
        type(wsin_type)                         :: wsin
    end function
#endif

#if RK3_ENABLED
    PURE elemental module function wsin_typer_RK3(omega) result(wsin)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wsin_typer_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)       , intent(in)            :: omega
        type(wsin_type)                         :: wsin
    end function
#endif

#if RK2_ENABLED
    PURE elemental module function wsin_typer_RK2(omega) result(wsin)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wsin_typer_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)       , intent(in)            :: omega
        type(wsin_type)                         :: wsin
    end function
#endif

#if RK1_ENABLED
    PURE elemental module function wsin_typer_RK1(omega) result(wsin)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wsin_typer_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)       , intent(in)            :: omega
        type(wsin_type)                         :: wsin
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the derived type for constructing objects that signify the computation of the integral of an arbitrary Cose-weighted function.
    !>
    !>  \details
    !>  The specified weight via this derive type has the form,
    !>  \f{equation}{
    !>      \cos(\omega x) ~,
    !>  \f}
    !>  that is used to signify the computation of the computation of the (Fourier transform) integral of the form:<br>
    !>  \f{equation}{
    !>      \int^{\ms{ub}}_{\ms{lb}} \cos(\omega x) f(x) dx
    !>  \f}
    !>  where \f$\omega\f$ and \f$f(x)\f$ are user-specified.<br>
    !>
    !>  Objects of this derived type can be passed to the primary integrators of the parent modules of this derived type:<br>
    !>  <ol>
    !>      <li>    [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>      <li>    [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  </ol>
    !>
    !>  \interface{wcos_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wcos_type
    !>      type(wcos_type) :: wcos_type
    !>
    !>      wcos = wcos_type(omega)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad).<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{wcos_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    type     :: wcos_type
        real(RKH) :: omega  !<  \public The scalar component of type `real` of kind \RKH (the highest (precision) real kind available in the ParaMonte library, representing the frequency coefficient of the weight.<br>
    end type

    !>  \brief
    !>  Return an object of type [wcos_type](@ref pm_quadPack::wcos_type) containing the frequency of the Cose weight of a Fourier transform integration.<br>
    !>
    !>  \devnote
    !>  This generic interface exists because of the lack of support for PDTs in gfortran,
    !>  requiring the derived type [wcos_type](@ref pm_quadPack::wcos_type) to have `omega` component with the highest precision.<br>
    !>
    !>  \param[in]  omega   :   The input scalar or array of arbitrary rank of type `real` of kind \RKALL,
    !>                          containing the angular frequency of the oscillatory Cosine weight in the
    !>                          integrand whose integral is to be computed.
    !>
    !>  \return
    !>  `wcos`              :   The scalar or array of the same shape as `omega` of type `Sin_type` that uniquely
    !>                          determines the type and kind of the Cosine weight to be used in the integrand.
    !>
    !>  \interface{wcos_typer}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: wcos_type
    !>      type(wcos_type) :: wcos
    !>
    !>      wcos = wcos_type(omega)
    !>      print *, wcos%omega
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>  [wcos_type](@ref pm_quadPack::wcos_type)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)<br>
    !>
    !>  \final{wcos_typer}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface wcos_type

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE elemental module function wcos_typer_RK5(omega) result(wcos)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcos_typer_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)       , intent(in)            :: omega
        type(wcos_type)                         :: wcos
    end function
#endif

#if RK4_ENABLED
    PURE elemental module function wcos_typer_RK4(omega) result(wcos)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcos_typer_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)       , intent(in)            :: omega
        type(wcos_type)                         :: wcos
    end function
#endif

#if RK3_ENABLED
    PURE elemental module function wcos_typer_RK3(omega) result(wcos)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcos_typer_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)       , intent(in)            :: omega
        type(wcos_type)                         :: wcos
    end function
#endif

#if RK2_ENABLED
    PURE elemental module function wcos_typer_RK2(omega) result(wcos)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcos_typer_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)       , intent(in)            :: omega
        type(wcos_type)                         :: wcos
    end function
#endif

#if RK1_ENABLED
    PURE elemental module function wcos_typer_RK1(omega) result(wcos)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: wcos_typer_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)       , intent(in)            :: omega
        type(wcos_type)                         :: wcos
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 7-point Gauss-Legendre quadrature with 15-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK15_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK15_type
    !>      type(GK15_type) :: GK15
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK15_type}
    !>  \include{lineno} example/pm_quadPack/GK15/main.F90
    !>  \compilef{GK15_type}
    !>  \output{GK15_type}
    !>  \include{lineno} example/pm_quadPack/GK15/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK15_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK15_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK15_type](@ref pm_quadPack::GK15_type) that indicates the use of 7-point Gauss-Legendre quadrature
    !>  with 15-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>
    !>  \example{GK15}
    !>  \include{lineno} example/pm_quadPack/GK15/main.F90
    !>  \compilef{GK15}
    !>  \output{GK15}
    !>  \include{lineno} example/pm_quadPack/GK15/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK15}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK15_type) , parameter :: GK15 = GK15_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK15
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 7-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG7](@ref pm_quadPack::nodeG7)<br>
    !>  [nodeK15](@ref pm_quadPack::nodeK15)<br>
    !>  [weightG7](@ref pm_quadPack::weightG7)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG7}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG7(4) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 4.0584515137739716690660641207696146334738201409937012638704325179466381322612565532831268972774658776528675866604802e-01_RKB &
    , 7.4153118559939443986386477328078840707414764714139026011995535196742987467218051379282683236686324705969251809311201e-01_RKB &
    , 9.4910791234275852452618968404785126240077093767061778354876910391306333035484014080573077002792572414430073966699522e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG7
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 7-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG7](@ref pm_quadPack::nodeG7)<br>
    !>  [nodeK15](@ref pm_quadPack::nodeK15)<br>
    !>  [weightG7](@ref pm_quadPack::weightG7)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG7}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG7(4) = &
    [ 4.1795918367346938775510204081632653061224489795918367346938775510204081632653061224489795918367346938775510204081633e-01_RKB &
    , 3.8183005050511894495036977548897513387836508353386273475108345103070554643412970834868465934404480145031467176458536e-01_RKB &
    , 2.7970539148927666790146777142377958248692506522659876453701403269361881043056267681324094290119761876632337521337205e-01_RKB &
    , 1.2948496616886969327061143267908201832858740225994666397720863872465523497204230871562541816292084508948440200163443e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG7
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 15-points Kronrod extension to the 7-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG7](@ref pm_quadPack::nodeG7)<br>
    !>  [nodeK15](@ref pm_quadPack::nodeK15)<br>
    !>  [weightG7](@ref pm_quadPack::weightG7)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK15}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK15(8) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 2.0778495500789846760068940377324491347978440714517064971384573461986693844943520226910343227183698530560857645062738e-01_RKB &
    , 4.0584515137739716690660641207696146334738201409937012638704325179466381322612565532831268972774658776528675866604802e-01_RKB &
    , 5.8608723546769113029414483825872959843678075060436095130499289319880373607444407464511674498935942098956811555121368e-01_RKB &
    , 7.4153118559939443986386477328078840707414764714139026011995535196742987467218051379282683236686324705969251809311201e-01_RKB &
    , 8.6486442335976907278971278864092620121097230707408814860145771276706770813259572103585847859604590541475281326027862e-01_RKB &
    , 9.4910791234275852452618968404785126240077093767061778354876910391306333035484014080573077002792572414430073966699522e-01_RKB &
    , 9.9145537112081263920685469752632851664204433837033470129108741357244173934653407235924503509626841760744349505339308e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK15
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 15-points Kronrod extension to the 7-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG7](@ref pm_quadPack::nodeG7)<br>
    !>  [nodeK15](@ref pm_quadPack::nodeK15)<br>
    !>  [weightG7](@ref pm_quadPack::weightG7)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK15}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK15(8) = &
    [ 2.0948214108472782801299917489171426369776208022370431671299800656137515132325648616816908211675949102392971459688215e-01_RKB &
    , 2.0443294007529889241416199923464908471651760418071835742447095312045467698546598879348374292009347554167803659293064e-01_RKB &
    , 1.9035057806478540991325640242101368282607807545535835588544088036744058072410212679605964605106377593834568683551139e-01_RKB &
    , 1.6900472663926790282658342659855028410624490030294424149734006755695680921619029112936702403855359908156070095656537e-01_RKB &
    , 1.4065325971552591874518959051023792039988975724799857556174546893312708093090950408097379122415555910759700350860143e-01_RKB &
    , 1.0479001032225018383987632254151801744375665421383061189339065133963746321576289524167571627509311333949422518201492e-01_RKB &
    , 6.3092092629978553290700663189204286665071157211550707113605545146983997477964874928199170264504441995865872491871943e-02_RKB &
    , 2.2935322010529224963732008058969591993560811275746992267507430254711815787976075946156368168156289483493617134063245e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK15
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 10-point Gauss-Legendre quadrature with 11-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK21_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK21_type
    !>      type(GK21_type) :: GK21
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK21_type}
    !>  \include{lineno} example/pm_quadPack/GK21/main.F90
    !>  \compilef{GK21_type}
    !>  \output{GK21_type}
    !>  \include{lineno} example/pm_quadPack/GK21/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK21_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK21_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK21_type](@ref pm_quadPack::GK21_type) that indicates the use of 10-point Gauss-Legendre quadrature
    !>  with 21-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK21}
    !>  \include{lineno} example/pm_quadPack/GK21/main.F90
    !>  \compilef{GK21}
    !>  \output{GK21}
    !>  \include{lineno} example/pm_quadPack/GK21/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK21}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK21_type) , parameter :: GK21 = GK21_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK21
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 10-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG10](@ref pm_quadPack::nodeG10)<br>
    !>  [nodeK21](@ref pm_quadPack::nodeK21)<br>
    !>  [weightG10](@ref pm_quadPack::weightG10)<br>
    !>  [weightK21](@ref pm_quadPack::weightK21)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG10}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG10(5) = &
    [ 1.4887433898163121088482600112971998461756485942069169570798925351590361735566852137117762979946369123003116080525534e-01_RKB &
    , 4.3339539412924719079926594316578416220007183765624649650270151314376698907770350122510275795011772122368293504099894e-01_RKB &
    , 6.7940956829902440623432736511487357576929471183480946766481718895255857539507492461507857357048037949983390204739932e-01_RKB &
    , 8.6506336668898451073209668842349304852754301496533045252195973184537475513805556135679072894604577069440463108641177e-01_RKB &
    , 9.7390652851717172007796401208445205342826994669238211923121206669659520323463615962572356495626855625823304251877421e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG10
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 10-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG10](@ref pm_quadPack::nodeG10)<br>
    !>  [nodeK21](@ref pm_quadPack::nodeK21)<br>
    !>  [weightG10](@ref pm_quadPack::weightG10)<br>
    !>  [weightK21](@ref pm_quadPack::weightK21)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG10}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG10(5) = &
    [ 2.9552422471475287017389299465133832942104671702685360135430802975599593821715232927035659579375421672271716440125256e-01_RKB &
    , 2.6926671930999635509122692156946935285975993846088379580056327624215343231917927676422663670925276075559581145036870e-01_RKB &
    , 2.1908636251598204399553493422816319245877187052267708988095654363519991065295128124268399317720219278659121687281289e-01_RKB &
    , 1.4945134915058059314577633965769733240255663966942736783547726875323865472663001094594726463473195191400575256104544e-01_RKB &
    , 6.6671344308688137593568809893331792857864834320158145128694881613412064084087101776785509685058877821090054714520419e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG10
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 21-points Kronrod extension to the 10-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG10](@ref pm_quadPack::nodeG10)<br>
    !>  [nodeK21](@ref pm_quadPack::nodeK21)<br>
    !>  [weightG10](@ref pm_quadPack::weightG10)<br>
    !>  [weightK21](@ref pm_quadPack::weightK21)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK21}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK21(11) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 1.4887433898163121088482600112971998461756485942069169570798925351590361735566852137117762979946369123003116080525534e-01_RKB &
    , 2.9439286270146019813112660310386556616268662515695791864888229172724611166332737888445523178268237359119185139299872e-01_RKB &
    , 4.3339539412924719079926594316578416220007183765624649650270151314376698907770350122510275795011772122368293504099894e-01_RKB &
    , 5.6275713466860468333900009927269414084301388194196695886034621458779266353216327549712087854169992422106448211158815e-01_RKB &
    , 6.7940956829902440623432736511487357576929471183480946766481718895255857539507492461507857357048037949983390204739932e-01_RKB &
    , 7.8081772658641689706371757834504237716340752029815717974694859999505607982761420654526977234238996241110129779403362e-01_RKB &
    , 8.6506336668898451073209668842349304852754301496533045252195973184537475513805556135679072894604577069440463108641177e-01_RKB &
    , 9.3015749135570822600120718005950834622516790998193924230349406866828415983091673055011194572851007884702013619684320e-01_RKB &
    , 9.7390652851717172007796401208445205342826994669238211923121206669659520323463615962572356495626855625823304251877421e-01_RKB &
    , 9.9565716302580808073552728068900284792126058721947892436337916111757023046774867357152325996912076724298149077812671e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK21
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 21-points Kronrod extension to the 10-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG10](@ref pm_quadPack::nodeG10)<br>
    !>  [nodeK21](@ref pm_quadPack::nodeK21)<br>
    !>  [weightG10](@ref pm_quadPack::weightG10)<br>
    !>  [weightK21](@ref pm_quadPack::weightK21)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK21}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK21(11) = &
    [ 1.4944555400291690566493646838982120374523631668747280383560851873698964478511841925721030705689540264726493367634340e-01_RKB &
    , 1.4773910490133849137484151597206804552373162548520660451819195439885993016735696405732703959182882254268727823258502e-01_RKB &
    , 1.4277593857706008079709427313871706088597905653190555560741004743970770449909340027811131706283756428281146832304737e-01_RKB &
    , 1.3470921731147332592805400177170683276099191300855971406636668491320291400121282036676953159488271772384389604997640e-01_RKB &
    , 1.2349197626206585107795810983107415951230034952864832764467994120974054238975454689681538622363738230836484113389878e-01_RKB &
    , 1.0938715880229764189921059032580496027181329983434522007819675829826550372891432168683899432674553842507906611591517e-01_RKB &
    , 9.3125454583697605535065465083366344390018828880760031970085038760177735672200775237414123061615827474831165614953012e-02_RKB &
    , 7.5039674810919952767043140916190009395219382000910088173697048048430404342858495178813808730646554086856929327903059e-02_RKB &
    , 5.4755896574351996031381300244580176373721114058333557524432615804784098927818975325116301569003298086458722055550981e-02_RKB &
    , 3.2558162307964727478818972459389760617388939845662609571537504232714121820165498692381607605384626494546068817765276e-02_RKB &
    , 1.1694638867371874278064396062192048396217332481931888927598147525622222058064992651806736704969967250888097490233242e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK21
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 15-point Gauss-Legendre quadrature with 31-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK31_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK31_type
    !>      type(GK31_type) :: GK31
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK31_type}
    !>  \include{lineno} example/pm_quadPack/GK31/main.F90
    !>  \compilef{GK31_type}
    !>  \output{GK31_type}
    !>  \include{lineno} example/pm_quadPack/GK31/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK31_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK31_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK31_type](@ref pm_quadPack::GK31_type) that indicates the use of 15-point Gauss-Legendre quadrature
    !>  with 31-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK31}
    !>  \include{lineno} example/pm_quadPack/GK31/main.F90
    !>  \compilef{GK31}
    !>  \output{GK31}
    !>  \include{lineno} example/pm_quadPack/GK31/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK31}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK31_type) , parameter :: GK31 = GK31_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK31
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 15-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG15](@ref pm_quadPack::nodeG15)<br>
    !>  [nodeK31](@ref pm_quadPack::nodeK31)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [weightK31](@ref pm_quadPack::weightK31)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG15}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG15(8) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 2.0119409399743452230062830339459620781283645446263767961594972460994823900302018760183625806752105908967902257386509e-01_RKB &
    , 3.9415134707756336989720737098104546836275277615869825503116534395160895778696141797549711416165976202589352169635648e-01_RKB &
    , 5.7097217260853884753722673725391064123838639628274960485326541705419537986975857948341462856982614477912646497026257e-01_RKB &
    , 7.2441773136017004741618605461393800963089929458410256355142342070412378167792521899610109760313432626923598549381925e-01_RKB &
    , 8.4820658341042721620064832077421685136625617473699263409572755876067507517414548519760771975082148085090373835713340e-01_RKB &
    , 9.3727339240070590430775894771020947124399627351530445790136307635020297379704552795054758617426808659746824044603157e-01_RKB &
    , 9.8799251802048542848956571858661258114697281712376148999999751558738843736901942471272205036831914497667516843990079e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG15
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 15-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG15](@ref pm_quadPack::nodeG15)<br>
    !>  [nodeK31](@ref pm_quadPack::nodeK31)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [weightK31](@ref pm_quadPack::weightK31)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG15}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG15(8) = &
    [ 2.0257824192556127288062019996751931483866215800947735679670411605143539875474607409339344071278803213535148267082999e-01_RKB &
    , 1.9843148532711157645611832644383932481869255995754199348473792792912479753343426813331499916481782320766020854889310e-01_RKB &
    , 1.8616100001556221102680056186642282450622601227792840281549572731001325550269916061894976888609932360539977709001384e-01_RKB &
    , 1.6626920581699393355320086048120881113090018009841290732186519056355356321227851771070517429241553621484461540657185e-01_RKB &
    , 1.3957067792615431444780479451102832252085027531551124320239112863108844454190781168076825736357133363814908889327664e-01_RKB &
    , 1.0715922046717193501186954668586930341554371575810198068702238912187799485231579972568585713760862404439808767837506e-01_RKB &
    , 7.0366047488108124709267416450667338466708032754330719825907292914387055512874237044840452066693939219355489858595041e-02_RKB &
    , 3.0753241996117268354628393577204417721748144833434074264228285504237189467117168039038770732399404002516991188859473e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG15
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 31-points Kronrod extension to the 15-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG15](@ref pm_quadPack::nodeG15)<br>
    !>  [nodeK31](@ref pm_quadPack::nodeK31)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [weightK31](@ref pm_quadPack::weightK31)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK31}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK31(16) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 1.0114206691871749902707423144739233878745105740164180495800189504151097862454083050931321451540380998341273193681967e-01_RKB &
    , 2.0119409399743452230062830339459620781283645446263767961594972460994823900302018760183625806752105908967902257386509e-01_RKB &
    , 2.9918000715316881216678002426638896266160338274382080184125545738918081102513884467602322020157243563662094470221235e-01_RKB &
    , 3.9415134707756336989720737098104546836275277615869825503116534395160895778696141797549711416165976202589352169635648e-01_RKB &
    , 4.8508186364023968069365574023235061286633893089407312129367943604080239955167155974371848690848595275551258416303565e-01_RKB &
    , 5.7097217260853884753722673725391064123838639628274960485326541705419537986975857948341462856982614477912646497026257e-01_RKB &
    , 6.5099674129741697053373589531327469254694822609259966708966160576093305841043840794460394747228060367236079289132544e-01_RKB &
    , 7.2441773136017004741618605461393800963089929458410256355142342070412378167792521899610109760313432626923598549381925e-01_RKB &
    , 7.9041850144246593296764929481794734686214051995697617332365280643308302974631807059994738664225445530963711137343440e-01_RKB &
    , 8.4820658341042721620064832077421685136625617473699263409572755876067507517414548519760771975082148085090373835713340e-01_RKB &
    , 8.9726453234408190088250965645449588283177871149442786763972687601078537721473771221195399661919716123038835639691946e-01_RKB &
    , 9.3727339240070590430775894771020947124399627351530445790136307635020297379704552795054758617426808659746824044603157e-01_RKB &
    , 9.6773907567913913425734797878433722528335733730013163797468062226335804249452174804319385048203118506304424717089291e-01_RKB &
    , 9.8799251802048542848956571858661258114697281712376148999999751558738843736901942471272205036831914497667516843990079e-01_RKB &
    , 9.9800229869339706028517284015227120907340644231555723034839427970683348682837134566648979907760125278631896777136104e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK31
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 31-points Kronrod extension to the 15-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG15](@ref pm_quadPack::nodeG15)<br>
    !>  [nodeK31](@ref pm_quadPack::nodeK31)<br>
    !>  [weightG15](@ref pm_quadPack::weightG15)<br>
    !>  [weightK31](@ref pm_quadPack::weightK31)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK31}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK31(16) = &
    [ 1.0133000701479154901737479276749254677092627259659629246734858372174107615774696665932418050683956749891773195816338e-01_RKB &
    , 1.0076984552387559504494666261756972191634838013536373069278929029488122760822761077475060185965408326901925180106227e-01_RKB &
    , 9.9173598721791959332393173484603131059567260816713281734860095693651563064308745717056680128223790739026832596087552e-02_RKB &
    , 9.6642726983623678505179907627589335136656568630495198973407668882934392359962841826511402504664592185391687490319950e-02_RKB &
    , 9.3126598170825321225486872747345718561927881321317330560285879189052002874531855060114908990458716740695847509343865e-02_RKB &
    , 8.8564443056211770647275443693774303212266732690655967817996052574877144544749814260718837576325109922207832119243346e-02_RKB &
    , 8.3080502823133021038289247286103789601554188253368717607281604875233630643885056057630789228337088859687986285569521e-02_RKB &
    , 7.6849680757720378894432777482659006722109101167947000584089097112470821092034084418224731527690291913686588446455555e-02_RKB &
    , 6.9854121318728258709520077099147475786045435140671549698798093177992675624987998849748628778570667518643649536771245e-02_RKB &
    , 6.2009567800670640285139230960802932190400004210329723569147829395618376206272317333030584268303808639229575334680414e-02_RKB &
    , 5.3481524690928087265343147239430296771554760947116739813222888752727413616259625439714812475198987513183153639571249e-02_RKB &
    , 4.4589751324764876608227299373279690223256649667921096570980823211805450700059906366455036418897149593261561551176267e-02_RKB &
    , 3.5346360791375846222037948478360048122630678992420820868148023340902501837247680978434662724296810081131106317333086e-02_RKB &
    , 2.5460847326715320186874001019653359397271745046864640508377984982400903447009185267605205778819712848080691366407461e-02_RKB &
    , 1.5007947329316122538374763075807268094639436437387634979291759700896494746154334398961710227490402528151677469993935e-02_RKB &
    , 5.3774798729233489877920514301276498183080402431284197876486169536848635554354599213793172596490038991436925569025913e-03_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK31
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 20-point Gauss-Legendre quadrature with 41-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK41_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK41_type
    !>      type(GK41_type) :: GK41
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK41_type}
    !>  \include{lineno} example/pm_quadPack/GK41/main.F90
    !>  \compilef{GK41_type}
    !>  \output{GK41_type}
    !>  \include{lineno} example/pm_quadPack/GK41/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK41_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK41_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK41_type](@ref pm_quadPack::GK41_type) that indicates the use of 20-point Gauss-Legendre quadrature
    !>  with 41-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK41}
    !>  \include{lineno} example/pm_quadPack/GK41/main.F90
    !>  \compilef{GK41}
    !>  \output{GK41}
    !>  \include{lineno} example/pm_quadPack/GK41/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK41}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK41_type) , parameter :: GK41 = GK41_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK41
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 21-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG20](@ref pm_quadPack::nodeG20)<br>
    !>  [nodeK41](@ref pm_quadPack::nodeK41)<br>
    !>  [weightG20](@ref pm_quadPack::weightG20)<br>
    !>  [weightK41](@ref pm_quadPack::weightK41)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG20}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG20(10) = &
    [ 7.6526521133497333754640409398838211004796266813497500804795244384256342048336978241545114181556215606998505646364133e-02_RKB &
    , 2.2778585114164507808049619536857462474308893768292747231463573920717134186355582779495212519096870803177373131560430e-01_RKB &
    , 3.7370608871541956067254817702492723739574632170568271182794861351564576437305952789589568363453337894476772208852815e-01_RKB &
    , 5.1086700195082709800436405095525099842549132920242683347234861989473497039076572814403168305086777919832943068843526e-01_RKB &
    , 6.3605368072651502545283669622628593674338911679936846393944662254654126258543013255870319549576130658211710937772596e-01_RKB &
    , 7.4633190646015079261430507035564159031073067956917644413954590606853535503815506468110411362064752061238490065167656e-01_RKB &
    , 8.3911697182221882339452906170152068532962936506563737325249272553286109399932480991922934056595764922060422035306914e-01_RKB &
    , 9.1223442825132590586775244120329811304918479742369177479588221915807089120871907893644472619292138737876039175464603e-01_RKB &
    , 9.6397192727791379126766613119727722191206032780618885606353759389204158078438305698001812525596471563131043491596423e-01_RKB &
    , 9.9312859918509492478612238847132027822264713090165589614818413121798471762775378083944940249657220927472894034724419e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG20
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 20-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG20](@ref pm_quadPack::nodeG20)<br>
    !>  [nodeK41](@ref pm_quadPack::nodeK41)<br>
    !>  [weightG20](@ref pm_quadPack::weightG20)<br>
    !>  [weightK41](@ref pm_quadPack::weightK41)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG20}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG20(10) = &
    [ 1.5275338713072585069808433195509759349194864511237859727470104981759745316273778153557248783650390593544001842813788e-01_RKB &
    , 1.4917298647260374678782873700196943669267990408136831649621121780984442259558678069396132603521048105170913854567338e-01_RKB &
    , 1.4209610931838205132929832506716493303451541339202030333736708298382808749793436761694922428320058260133068573666201e-01_RKB &
    , 1.3168863844917662689849449974816313491611051114698352699643649370885435642948093314355797518397262924510598005463625e-01_RKB &
    , 1.1819453196151841731237737771138228700504121954896877544688995202017474835051151630572868782581901744606267543092317e-01_RKB &
    , 1.0193011981724043503675013548034987616669165602339255626197161619685232202539434647534931576947985821375859035525483e-01_RKB &
    , 8.3276741576704748724758143222046206100177828583163290744882060785693082894079419471375190843790839349096116111932764e-02_RKB &
    , 6.2672048334109063569506535187041606351601076578436364099584345437974811033665678644563766056832203512603253399592073e-02_RKB &
    , 4.0601429800386941331039952274932109879090639989951536817606854561832296750987328295538920623044384976189825709675075e-02_RKB &
    , 1.7614007139152118311861962351852816362143105543336732524349326677348419259621847817403105542146097668703716227512570e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG20
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 41-points Kronrod extension to the 20-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG20](@ref pm_quadPack::nodeG20)<br>
    !>  [nodeK41](@ref pm_quadPack::nodeK41)<br>
    !>  [weightG20](@ref pm_quadPack::weightG20)<br>
    !>  [weightK41](@ref pm_quadPack::weightK41)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK41}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK41(21) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 7.6526521133497333754640409398838211004796266813497500804795244384256342048336978241545114181556215606998505646364133e-02_RKB &
    , 1.5260546524092267550522024102267752791167622481841730660174156703809133685751696356987995886397049724808931527012542e-01_RKB &
    , 2.2778585114164507808049619536857462474308893768292747231463573920717134186355582779495212519096870803177373131560430e-01_RKB &
    , 3.0162786811491300432055535685859226061539650501373092456926374427956957435978384116066498234762220215751079886015902e-01_RKB &
    , 3.7370608871541956067254817702492723739574632170568271182794861351564576437305952789589568363453337894476772208852815e-01_RKB &
    , 4.4359317523872510319999221349264010784010101082300309613315028346299543059315258601993479156987847429893626854030516e-01_RKB &
    , 5.1086700195082709800436405095525099842549132920242683347234861989473497039076572814403168305086777919832943068843526e-01_RKB &
    , 5.7514044681971031534294603658642513281381264014771682537415885495717468074720062012357788489049470208285175093670561e-01_RKB &
    , 6.3605368072651502545283669622628593674338911679936846393944662254654126258543013255870319549576130658211710937772596e-01_RKB &
    , 6.9323765633475138480549071184593153338642585141021417904687378454301191710739219011546672416325022748282227809465165e-01_RKB &
    , 7.4633190646015079261430507035564159031073067956917644413954590606853535503815506468110411362064752061238490065167656e-01_RKB &
    , 7.9504142883755119835063883327278794295938959911578029703855163894322697871710382866701777890251824617748545658564370e-01_RKB &
    , 8.3911697182221882339452906170152068532962936506563737325249272553286109399932480991922934056595764922060422035306914e-01_RKB &
    , 8.7827681125228197607744299511307846671124526828251164853898086998248145904743220740840261624245683876748360309079747e-01_RKB &
    , 9.1223442825132590586775244120329811304918479742369177479588221915807089120871907893644472619292138737876039175464603e-01_RKB &
    , 9.4082263383175475351998272221244338027429557377965291059536839973186796006557571220888218676776618448841584569497535e-01_RKB &
    , 9.6397192727791379126766613119727722191206032780618885606353759389204158078438305698001812525596471563131043491596423e-01_RKB &
    , 9.8150787745025025919334299472021694456725093981023759869077533318793098857465723460898060491887511355706497739384103e-01_RKB &
    , 9.9312859918509492478612238847132027822264713090165589614818413121798471762775378083944940249657220927472894034724419e-01_RKB &
    , 9.9885903158827766383831557654586300999957020432629666866666860339324411793311982967839129772854179884971700274369367e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK41
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 41-points Kronrod extension to the 20-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG20](@ref pm_quadPack::nodeG20)<br>
    !>  [nodeK41](@ref pm_quadPack::nodeK41)<br>
    !>  [weightG20](@ref pm_quadPack::weightG20)<br>
    !>  [weightK41](@ref pm_quadPack::weightK41)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK41}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK41(21) = &
    [ 7.6600711917999656445049901530101740827932500628670118055485349620314721456712029449597396569857880493210849110825276e-02_RKB &
    , 7.6377867672080736705502835038061001800801036764945996714946431116936745542061941050008345047482501253320401746334511e-02_RKB &
    , 7.5704497684556674659542775376616558263363155900414326194855223272348838596099414841886740468379707283366777797425290e-02_RKB &
    , 7.4582875400499188986581418362487528616116493572092273080047040726969899567887364227664202642942357104526915332274625e-02_RKB &
    , 7.3030690332786667495189417658913112760626845234552742380174250771849743831660040966804802312464527721645765620253776e-02_RKB &
    , 7.1054423553444068305790361723210167412912159322210143921628270586407381879789525901086146473278095159807542174985045e-02_RKB &
    , 6.8648672928521619345623411885367801715489704958239860400434264173923806029589970941711224257967651039544669425313433e-02_RKB &
    , 6.5834597133618422111563556969397943147223506343381443709751749639944420314384296347503523810096842402960802728781816e-02_RKB &
    , 6.2653237554781168025870122174254980585819744698897886186553324157100424088919284503451596742588386343548162830898103e-02_RKB &
    , 5.9111400880639572374967220648594217136419365977042191748388047204015262840407696611508732839851952697839735487615776e-02_RKB &
    , 5.5195105348285994744832372419777329194753456228153116909812131213177827707884692917845453999535518818940813085110223e-02_RKB &
    , 5.0944573923728691932707670050344948664836365809262579747517140086119113476866735641054822574173198900379392130050979e-02_RKB &
    , 4.6434821867497674720231880926107516842127071007077929289994127933243222585938804392953931185146446072587020288747981e-02_RKB &
    , 4.1668873327973686263788305936894738043960843153010324860966353235271889596379726462208702081068715463576895020003842e-02_RKB &
    , 3.6600169758200798030557240707211008487453496747498001651070009441973280061489266074044986901436324295513243878212345e-02_RKB &
    , 3.1287306777032798958543119323800737887769280362813337359554598005322423266047996771926031069705049476071896145456496e-02_RKB &
    , 2.5882133604951158834505067096153142999479118048674944526997797755374306421629440393392427198869345793286369198147609e-02_RKB &
    , 2.0388373461266523598010231432754705122838627940185929365371868214433006532030353671253640300679157504987977281782909e-02_RKB &
    , 1.4626169256971252983787960308868356163881050162249770342103474631076960029748751959380482484308382288261238476948520e-02_RKB &
    , 8.6002698556429421986617879501023472521289227667077976622450602031426535362696437838448828009554532025301579670206091e-03_RKB &
    , 3.0735837185205315012182932460309874880335046882543449198461628212114333665590378156706265241414469306987988292234740e-03_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK41
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 25-point Gauss-Legendre quadrature with 51-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK51_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK51_type
    !>      type(GK51_type) :: GK51
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK51_type}
    !>  \include{lineno} example/pm_quadPack/GK51/main.F90
    !>  \compilef{GK51_type}
    !>  \output{GK51_type}
    !>  \include{lineno} example/pm_quadPack/GK51/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK51_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK51_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK51_type](@ref pm_quadPack::GK51_type) that indicates the use of 25-point Gauss-Legendre quadrature
    !>  with 51-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK51}
    !>  \include{lineno} example/pm_quadPack/GK51/main.F90
    !>  \compilef{GK51}
    !>  \output{GK51}
    !>  \include{lineno} example/pm_quadPack/GK51/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK51}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK51_type) , parameter :: GK51 = GK51_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK51
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 25-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG25](@ref pm_quadPack::nodeG25)<br>
    !>  [nodeK51](@ref pm_quadPack::nodeK51)<br>
    !>  [weightG25](@ref pm_quadPack::weightG25)<br>
    !>  [weightK51](@ref pm_quadPack::weightK51)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG25}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG25(13) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 1.2286469261071039638735981880803680553220534604978373842389353789270883496885841582643884994633105537597765980412320e-01_RKB &
    , 2.4386688372098843204519036279745158640563315632598447642113565325038747278585595067977636776325034060327548499765742e-01_RKB &
    , 3.6117230580938783773582173012764066742207834704337506979457877784674538239569654860329531506093761400789294612122812e-01_RKB &
    , 4.7300273144571496052218211500919204133181773846162729090723082769560327584128603010315684778279363544192787010704498e-01_RKB &
    , 5.7766293024122296772368984161265406739573503929151825664548350776102301275263202227671659646579649084013116066120581e-01_RKB &
    , 6.7356636847346836448512063324762217588341672807274931705965696177828773684928421158196368568030932194044282149314388e-01_RKB &
    , 7.5925926303735763057728286520436097638752201889833412091838973544501862882026240760763679724185230331463919586229073e-01_RKB &
    , 8.3344262876083400142102110869356956946096411382352078602086471546171813247709012525322973947759168107133491065937347e-01_RKB &
    , 8.9499199787827536885104200678280495417455484975358390306170168295917151090119945137118600693039178162093726882638296e-01_RKB &
    , 9.4297457122897433941401116965847053190520157060899014192745249713729532254404926130890521815127348327109666786665572e-01_RKB &
    , 9.7666392145951751149831538647959406774537055531440674467098742731616386753588055389644670948300617866819865983054648e-01_RKB &
    , 9.9555696979049809790878494689390161725756264940480817121080493113293348134372793448728802635294700756868258870429256e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG25
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 25-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG25](@ref pm_quadPack::nodeG25)<br>
    !>  [nodeK51](@ref pm_quadPack::nodeK51)<br>
    !>  [weightG25](@ref pm_quadPack::weightG25)<br>
    !>  [weightK51](@ref pm_quadPack::weightK51)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG25}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG25(13) = &
    [ 1.2317605372671545120390287307905014243823362751815166539135219731691200794926142128460112517504958377310054583945994e-01_RKB &
    , 1.2224244299031004168895951894585150583505924756305904090758008223203896721918010243033540891078906637115620156845304e-01_RKB &
    , 1.1945576353578477222817812651290104739017670141372642551958788133518409022018773502442869720975271321374348568426235e-01_RKB &
    , 1.1485825914571164833932554586955580864093619166818014959151499003148279667112542256534429898558156273250513652351744e-01_RKB &
    , 1.0851962447426365311609395705011661934007758798672201615649430734883929279360844269339768350029654172135832773427565e-01_RKB &
    , 1.0053594906705064420220689039268582698846609452814190706986904199941294815904602968195565620373258211755226681206658e-01_RKB &
    , 9.1028261982963649811497220702891653380992558959334310970483768967017384678410526902484398142953718885872521590850372e-02_RKB &
    , 8.0140700335001018013234959669111302290225732853675893716201462973612828934801289559457377714225318048243957479325813e-02_RKB &
    , 6.8038333812356917207187185656707968554709494354636562615071226410003654051711473106651522969481873733098761760660898e-02_RKB &
    , 5.4904695975835191925936891540473324160109985553111349048508498244593774678436511895711924079433444763756746828817613e-02_RKB &
    , 4.0939156701306312655623487711645953660845783364104346504698414899297432880215512770478971055110424130123527015425511e-02_RKB &
    , 2.6354986615032137261901815295299144935963281703322468755366165783870934008879499371529821528172928890350362464605104e-02_RKB &
    , 1.1393798501026287947902964113234773603320526292909696448948061116189891729766743355923677112945033505688431618009664e-02_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG25
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 51-points Kronrod extension to the 25-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG25](@ref pm_quadPack::nodeG25)<br>
    !>  [nodeK51](@ref pm_quadPack::nodeK51)<br>
    !>  [weightG25](@ref pm_quadPack::weightG25)<br>
    !>  [weightK51](@ref pm_quadPack::weightK51)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK51}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK51(26) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 6.1544483005685078886546392366796631281724348039823545274305431751687279361558658545141048781022691067898008423227288e-02_RKB &
    , 1.2286469261071039638735981880803680553220534604978373842389353789270883496885841582643884994633105537597765980412320e-01_RKB &
    , 1.8371893942104889201596988875952841578528447834990555215034512653236752851109815617651867160645591242103823539931527e-01_RKB &
    , 2.4386688372098843204519036279745158640563315632598447642113565325038747278585595067977636776325034060327548499765742e-01_RKB &
    , 3.0308953893110783016747890998033932920041937876655194685731578452573120372337209717349617882111662416355753711853559e-01_RKB &
    , 3.6117230580938783773582173012764066742207834704337506979457877784674538239569654860329531506093761400789294612122812e-01_RKB &
    , 4.1788538219303774885181439459457248709336998140069528034955785068796932076966599548717224205109797297615032607570119e-01_RKB &
    , 4.7300273144571496052218211500919204133181773846162729090723082769560327584128603010315684778279363544192787010704498e-01_RKB &
    , 5.2632528433471918259962377815801017803683252320191114313002425180471455022502695302371008520604638341970901082293650e-01_RKB &
    , 5.7766293024122296772368984161265406739573503929151825664548350776102301275263202227671659646579649084013116066120581e-01_RKB &
    , 6.2681009901031741278812268162451788101954628995068510806525222008437260184181183053045236423845198752346149030569920e-01_RKB &
    , 6.7356636847346836448512063324762217588341672807274931705965696177828773684928421158196368568030932194044282149314388e-01_RKB &
    , 7.1776640681308438818665407977329778059771167555515582423493486823991612820974965089522905953765860328116692570706602e-01_RKB &
    , 7.5925926303735763057728286520436097638752201889833412091838973544501862882026240760763679724185230331463919586229073e-01_RKB &
    , 7.9787379799850005941041090499430656940863230009338267661706934499488650817643824077118950314443984031474353711531825e-01_RKB &
    , 8.3344262876083400142102110869356956946096411382352078602086471546171813247709012525322973947759168107133491065937347e-01_RKB &
    , 8.6584706529327559544899696958834008820284409402823690293965213246691432948180280120756708738064779055576005302835351e-01_RKB &
    , 8.9499199787827536885104200678280495417455484975358390306170168295917151090119945137118600693039178162093726882638296e-01_RKB &
    , 9.2074711528170156174634608454633063157457035996277199700642836501131385042631212407808952281702820179915510491592339e-01_RKB &
    , 9.4297457122897433941401116965847053190520157060899014192745249713729532254404926130890521815127348327109666786665572e-01_RKB &
    , 9.6161498642584251241813003366016724169212642963709676666624520141292893281185666917636407790823210892689040877316178e-01_RKB &
    , 9.7666392145951751149831538647959406774537055531440674467098742731616386753588055389644670948300617866819865983054648e-01_RKB &
    , 9.8803579453407724763733101457740622707248415209160748131449972199405186821347293686245404742032360498210710718706868e-01_RKB &
    , 9.9555696979049809790878494689390161725756264940480817121080493113293348134372793448728802635294700756868258870429256e-01_RKB &
    , 9.9926210499260983419345748654034059370452496042279618586228697762904524428167719073818746102238075978747461480736921e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK51
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 51-points Kronrod extension to the 25-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG25](@ref pm_quadPack::nodeG25)<br>
    !>  [nodeK51](@ref pm_quadPack::nodeK51)<br>
    !>  [weightG25](@ref pm_quadPack::weightG25)<br>
    !>  [weightK51](@ref pm_quadPack::weightK51)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK51}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK51(26) = &
    [ 6.1580818067832935078759824240064553190436936903140808056908996403358367244202623293256774502185186717703954810463664e-02_RKB &
    , 6.1471189871425316661544131965264177586537962876885022711111683500151700796198726558483367566537422877227096643444043e-02_RKB &
    , 6.1128509717053048305859030416292711922678552321960938357322028070390133769952032831204895569347757809858568165047769e-02_RKB &
    , 6.0539455376045862945360267517565427162312365710457079923487043144554747810689514408013582515489930908693681447570811e-02_RKB &
    , 5.9720340324174059979099291932561853835363045476189975483372207816149988460708299020779612375010639778624011960832019e-02_RKB &
    , 5.8689680022394207961974175856787764139795646254828315293243700305012569486054157617049685031506591863121580010947248e-02_RKB &
    , 5.7437116361567832853582693939506471994832856823896682976509412313367495727224381199978598247737089593472710899482737e-02_RKB &
    , 5.5950811220412317308240686382747346820271035112771802428932791066115158268338607019365831655460314732208940609352540e-02_RKB &
    , 5.4251129888545490144543370459875606826076838441263383072163293312936923476650934130242315028422047795830492882862973e-02_RKB &
    , 5.2362885806407475864366712137872714887351550723707596350905793656046659248541276597504566497990926306481919129870507e-02_RKB &
    , 5.0277679080715671963325259433440084440587630604775975142050968279743014641141402310302584542633557037153607386127936e-02_RKB &
    , 4.7982537138836713906392255756914754983592207423271169651235865196757913880334117810235517477328110033499422471098658e-02_RKB &
    , 4.5502913049921788909870584752660393043707768935695327316724254392794299567957035458208970599641697203261236226745020e-02_RKB &
    , 4.2872845020170049476895792439495161101999504199883328877919242515738957655253932048951366960802592343905647433925806e-02_RKB &
    , 4.0083825504032382074839284467075646401410549266591308713115878386835777315058451955614116158949614066927183232852042e-02_RKB &
    , 3.7116271483415543560330625367619875995997802688047764805628702762773009669395760582294525748583875707140577080663373e-02_RKB &
    , 3.4002130274329337836748795229551203225670528250050443083264193121524339063344855010257660547708022429300203676502386e-02_RKB &
    , 3.0792300167387488891109020215228585600877162393292487644544830559965388047996492709248618249084851477787538356572832e-02_RKB &
    , 2.7475317587851737802948455517811078614796013288710603199613621069727810352835469926107822047433566792405123805901196e-02_RKB &
    , 2.4009945606953216220092489164881081392931528209659330290734972342536012282191913069778658241972047765300060007037359e-02_RKB &
    , 2.0435371145882835456568292235938973678758006097668937220074531550163622566841885855957623103354443247806459277197725e-02_RKB &
    , 1.6847817709128298231516667536336315840402654624706139411175769276842182270078960078544597372646532637619276509222462e-02_RKB &
    , 1.3236229195571674813656405846976238077578084997863654732213860488560614587634395544002156258192582265590155862296710e-02_RKB &
    , 9.4739733861741516072077105236553238716453268483726334971394029603529306140359023187904705754719643032594360138998941e-03_RKB &
    , 5.5619321353567137580402369010655220701769295496290984052961210793810038857581724171021610100708799763006942755331129e-03_RKB &
    , 1.9873838923303159265078518828434098894299804282505973837653346298985629336820118753523093675303476883723992297810124e-03_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK51
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of 30-point Gauss-Legendre quadrature with 61-point Kronrod
    !>  extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \interface{GK61_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: GK61_type
    !>      type(GK61_type) :: GK61
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [GK15_type](@ref pm_quadPack::GK15_type)<br>
    !>  [GK21_type](@ref pm_quadPack::GK21_type)<br>
    !>  [GK31_type](@ref pm_quadPack::GK31_type)<br>
    !>  [GK41_type](@ref pm_quadPack::GK41_type)<br>
    !>  [GK51_type](@ref pm_quadPack::GK51_type)<br>
    !>  [GK61_type](@ref pm_quadPack::GK61_type)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK61_type}
    !>  \include{lineno} example/pm_quadPack/GK61/main.F90
    !>  \compilef{GK61_type}
    !>  \output{GK61_type}
    !>  \include{lineno} example/pm_quadPack/GK61/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK61_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: GK61_type
    end type

    !>  \brief
    !>  The scalar constant object of type [GK61_type](@ref pm_quadPack::GK61_type) that indicates the use of 30-point Gauss-Legendre quadrature
    !>  with 61-point Kronrod extension formulae as the drivers in the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadGK](@ref pm_quadPack::getQuadGK).
    !>
    !>  \see
    !>  [GK15](@ref pm_quadPack::GK15)<br>
    !>  [GK21](@ref pm_quadPack::GK21)<br>
    !>  [GK31](@ref pm_quadPack::GK31)<br>
    !>  [GK41](@ref pm_quadPack::GK41)<br>
    !>  [GK51](@ref pm_quadPack::GK51)<br>
    !>  [GK61](@ref pm_quadPack::GK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \example{GK61}
    !>  \include{lineno} example/pm_quadPack/GK61/main.F90
    !>  \compilef{GK61}
    !>  \output{GK61}
    !>  \include{lineno} example/pm_quadPack/GK61/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{GK61}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(GK61_type) , parameter :: GK61 = GK61_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: GK61
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 30-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG30](@ref pm_quadPack::nodeG30)<br>
    !>  [nodeK61](@ref pm_quadPack::nodeK61)<br>
    !>  [weightG30](@ref pm_quadPack::weightG30)<br>
    !>  [weightK61](@ref pm_quadPack::weightK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeG30}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeG30(15) = &
    [ 5.1471842555317695833025213166722573749141453666569564255160843987964755210427109055870090707285485841217089963590678e-02_RKB &
    , 1.5386991360858354696379467274325592041855197124433846171896298291578714851081610139692310651074078557990111754952062e-01_RKB &
    , 2.5463692616788984643980512981780510788278930330251842616428597508896353156907880290636628138423620257595521678255758e-01_RKB &
    , 3.5270472553087811347103720708937386065363100802142562659418446890026941623319107866436039675211352945165817827083104e-01_RKB &
    , 4.4703376953808917678060990032285400016240759386142440975447738172761535172858420700400688872124189834257262048739699e-01_RKB &
    , 5.3662414814201989926416979331107279416417800693029710545274348291201490861897837863114116009718990258091585830703557e-01_RKB &
    , 6.2052618298924286114047755643118929920736469282952813259505117012433531497488911774115258445532782106478789996137481e-01_RKB &
    , 6.9785049479331579693229238802664006838235380065395465637972284673997672124315996069538163644008904690545069439941341e-01_RKB &
    , 7.6777743210482619491797734097450313169488361723290845320649438736515857017299504505260960258623968420224697596501719e-01_RKB &
    , 8.2956576238276839744289811973250191643906869617034167880695298345365650658958163508295244350814016004371545455777732e-01_RKB &
    , 8.8256053579205268154311646253022559005668914714648423206832605312161626269519165572921583828573210485349058106849548e-01_RKB &
    , 9.2620004742927432587932427708047400408647453682532906091103713367942299565110232681677288015055886244486106298320068e-01_RKB &
    , 9.6002186496830751221687102558179766293035921740392339948566167242493995770706842922718944370380002378239172677454384e-01_RKB &
    , 9.8366812327974720997003258160566280194031785470971136351718001015114429536479104370207597166035471368057762560137209e-01_RKB &
    , 9.9689348407464954027163005091869528334088203811775079010809429780238769521016374081588201955806171741257405095963817e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeG30
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 30-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG30](@ref pm_quadPack::nodeG30)<br>
    !>  [nodeK61](@ref pm_quadPack::nodeK61)<br>
    !>  [weightG30](@ref pm_quadPack::weightG30)<br>
    !>  [weightK61](@ref pm_quadPack::weightK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightG30}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightG30(15) = &
    [ 1.0285265289355884034128563670541504386837555706492822258631898667601623865660942939262884632188870916503815852709086e-01_RKB &
    , 1.0176238974840550459642895216855404463270628948712684086426094541964251360531767494547599781978391198881693385887696e-01_RKB &
    , 9.9593420586795267062780282103569476529869263666704277221365146183946660389908809018092299289324184705373523229592037e-02_RKB &
    , 9.6368737174644259639468626351809865096406461430160245912994275732837534742003123724951247818104195363343093583583429e-02_RKB &
    , 9.2122522237786128717632707087618767196913234418234107527675047001973047070094168298464052916811907158954949394100501e-02_RKB &
    , 8.6899787201082979802387530715125702576753328743545344012222129882153582254261494247955033509639105330215477601953921e-02_RKB &
    , 8.0755895229420215354694938460529730875892803708439299890258593706051180567026345604212402769217808080749416147400962e-02_RKB &
    , 7.3755974737705206268243850022190734153770526037049438941269182374599399314635211710401352716638183270192254236882630e-02_RKB &
    , 6.5974229882180495128128515115962361237442953656660378967031516042143672466094179365819913911598737439478205808271237e-02_RKB &
    , 5.7493156217619066481721689402056128797120670721763134548715799003232147409954376925211999650950125355559974348279846e-02_RKB &
    , 4.8402672830594052902938140422807517815271809197372736345191936791805425677102152797767439563562263454374645955072007e-02_RKB &
    , 3.8799192569627049596801936446347692033200976766395352107732789705946970952769793919055026279035105656340228558382274e-02_RKB &
    , 2.8784707883323369349719179611292043639588894546287496474180122608145988940013933101730206711484171554940392262251283e-02_RKB &
    , 1.8466468311090959142302131912047269096206533968181403371298365514585599521307973654080519029675417955638095832046164e-02_RKB &
    , 7.9681924961666056154658834746736224504806965871517212294851633569200384329013332941536616922861735209846506562158817e-03_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightG30
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the abscissas of the 61-points Kronrod extension to the 30-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG30](@ref pm_quadPack::nodeG30)<br>
    !>  [nodeK61](@ref pm_quadPack::nodeK61)<br>
    !>  [weightG30](@ref pm_quadPack::weightG30)<br>
    !>  [weightK61](@ref pm_quadPack::weightK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{nodeK61}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: nodeK61(31) = &
    [ 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e+00_RKB &
    , 5.1471842555317695833025213166722573749141453666569564255160843987964755210427109055870090707285485841217089963590678e-02_RKB &
    , 1.0280693796673703014709675131800059247190133296515840552101946914632788253917872738234797140786490207720254922664913e-01_RKB &
    , 1.5386991360858354696379467274325592041855197124433846171896298291578714851081610139692310651074078557990111754952062e-01_RKB &
    , 2.0452511668230989143895767100202470952410426459556377447604465028350321894663245495592565235317147819577892124850607e-01_RKB &
    , 2.5463692616788984643980512981780510788278930330251842616428597508896353156907880290636628138423620257595521678255758e-01_RKB &
    , 3.0407320227362507737267710719925655353115778980946272844421536998312150442387767304001423699909778588529370119457430e-01_RKB &
    , 3.5270472553087811347103720708937386065363100802142562659418446890026941623319107866436039675211352945165817827083104e-01_RKB &
    , 4.0040125483039439253547621154266063361104593297078395983186610656429170689311759061175527015710247383961903284673474e-01_RKB &
    , 4.4703376953808917678060990032285400016240759386142440975447738172761535172858420700400688872124189834257262048739699e-01_RKB &
    , 4.9248046786177857499369306120770879564426564096318697026073340982988422546396352776837047452262025983265531109327026e-01_RKB &
    , 5.3662414814201989926416979331107279416417800693029710545274348291201490861897837863114116009718990258091585830703557e-01_RKB &
    , 5.7934523582636169175602493217254049590705158881215289208126016612312833567812241903809970751783808208940322061083509e-01_RKB &
    , 6.2052618298924286114047755643118929920736469282952813259505117012433531497488911774115258445532782106478789996137481e-01_RKB &
    , 6.6006106412662696137005366814927075303835037480883390955067197339904937499734522076788020517029688190998858739703079e-01_RKB &
    , 6.9785049479331579693229238802664006838235380065395465637972284673997672124315996069538163644008904690545069439941341e-01_RKB &
    , 7.3379006245322680472617113136952764566938172775468549208701399518300016463613325382024664531597318795933262446521430e-01_RKB &
    , 7.6777743210482619491797734097450313169488361723290845320649438736515857017299504505260960258623968420224697596501719e-01_RKB &
    , 7.9972783582183908301366894232268324073569842937778450923647349548686662567326007229195202524185356472023967927713548e-01_RKB &
    , 8.2956576238276839744289811973250191643906869617034167880695298345365650658958163508295244350814016004371545455777732e-01_RKB &
    , 8.5720523354606109895865851065894385682080017062359612850504551739119887225712932688031120704657195642614071367390794e-01_RKB &
    , 8.8256053579205268154311646253022559005668914714648423206832605312161626269519165572921583828573210485349058106849548e-01_RKB &
    , 9.0557330769990779854652255892595831956897536366222841356404766397803760239449631913585074426842574155323901785046522e-01_RKB &
    , 9.2620004742927432587932427708047400408647453682532906091103713367942299565110232681677288015055886244486106298320068e-01_RKB &
    , 9.4437444474855997941583132403743912158564371496498093181748940139520917000657342753448871376849848523800667868447591e-01_RKB &
    , 9.6002186496830751221687102558179766293035921740392339948566167242493995770706842922718944370380002378239172677454384e-01_RKB &
    , 9.7311632250112626837469386842370688488763796428343933853755850185624118958166838288308561708261486365954975485787212e-01_RKB &
    , 9.8366812327974720997003258160566280194031785470971136351718001015114429536479104370207597166035471368057762560137209e-01_RKB &
    , 9.9163099687040459485862836610948572485050033374616325510019923349807489603260796605556191495843575227494654783755353e-01_RKB &
    , 9.9689348407464954027163005091869528334088203811775079010809429780238769521016374081588201955806171741257405095963817e-01_RKB &
    , 9.9948441005049063757132589570581081946887394701850801923632642830748016674843587830656468823145435723317885056396548e-01_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: nodeK61
#endif

    !>  \brief
    !>  A vector of type `real` of the highest-precision kind available by the processor,
    !>  containing the weights of the 61-points Kronrod extension to the 30-points Gauss quadrature rule.
    !>
    !>  \see
    !>  [nodeG30](@ref pm_quadPack::nodeG30)<br>
    !>  [nodeK61](@ref pm_quadPack::nodeK61)<br>
    !>  [weightG30](@ref pm_quadPack::weightG30)<br>
    !>  [weightK61](@ref pm_quadPack::weightK61)<br>
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weightK61}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    real(RKB)   , parameter :: weightK61(31) = &
    [ 5.1494729429451567558340433647099307532736880396464168074637323362474083844397567724480716864880173808112573901197920e-02_RKB &
    , 5.1426128537459025933862879215781259829552034862395987263855824172761589259406892072066110681184224608133314131500422e-02_RKB &
    , 5.1221547849258772170656282604944208251146952425246327553509056805511015401279553971190412722969308620984161625812560e-02_RKB &
    , 5.0881795898749606492297473049804691853384914260919239920771942080972542646780575571132056254070929858650733836163479e-02_RKB &
    , 5.0405921402782346840893085653585028902197018251622233664243959211066713308635283713447747907973700791599900911248852e-02_RKB &
    , 4.9795683427074206357811569379942328539209602813696108951047392842948482646220377655098341924089250200477846596263918e-02_RKB &
    , 4.9055434555029778887528165367238173605887405295296569579490717901328215644590555247522873065246297467067324397612445e-02_RKB &
    , 4.8185861757087129140779492298304592605799236108429800057373350872433793583969368428942672063270298939865425225579922e-02_RKB &
    , 4.7185546569299153945261478181099486482884807300628457194141861551725533289490897029020276525603515502104799540544222e-02_RKB &
    , 4.6059238271006988116271735559373580594692875571824924004732379492293604006446052672252973438978639166425766841417488e-02_RKB &
    , 4.4814800133162663192355551616723243757431392796373009889680201194063503947907899189061064792111919040540351834527742e-02_RKB &
    , 4.3452539701356069316831728117073258074603308631703168064888805495738640839573863333942084117196541456054957383622173e-02_RKB &
    , 4.1969810215164246147147541285969757790088656718992374820388720323852655511200365790379948462006156953358103259681948e-02_RKB &
    , 4.0374538951535959111995279752468114216126062126030255633998289613810846761059740961836828802959573901107306640876603e-02_RKB &
    , 3.8678945624727592950348651532281050250923629821553846790376130679337402056620700554139109487533759557982632153728099e-02_RKB &
    , 3.6882364651821229223911065617135967736955164781030337670005198584196134970154169862584193360751243227989492571664973e-02_RKB &
    , 3.4979338028060024137499670731467875097226912794818719972208457232177786702008744219498470603846784465175225933802357e-02_RKB &
    , 3.2981447057483726031814191016853927510599291213858385714519347641452316582381008804994515341969205985818543200837577e-02_RKB &
    , 3.0907257562387762472884252943092272635270458523807153426840486964022086189874056947717446328187131273807982629114591e-02_RKB &
    , 2.8754048765041292843978785354334211144679160542074930035102280759132174815469834227854660515366003136772757344886331e-02_RKB &
    , 2.6509954882333101610601709335075414366517579522748565770867438338472138903658077617652522759934474895733739329287706e-02_RKB &
    , 2.4191162078080601365686370725232026760391377828182462432228943562944885267501070688006470962871743661192935455117297e-02_RKB &
    , 2.1828035821609192297167485738338993401507296056834912773630422358720439403382559079356058602393879803560534375378340e-02_RKB &
    , 1.9414141193942381173408951050128455851421014191431525770276066536497179079025540486072726114628763606440143557769099e-02_RKB &
    , 1.6920889189053272627572289420322092368566703783835191139883410840546679978551861043620089451681146020853650713611444e-02_RKB &
    , 1.4369729507045804812451432443580010195841899895001505873565899403000198662495821906144274682894222591414503342336172e-02_RKB &
    , 1.1823015253496341742232898853250592896264406250607818326302431548265365155855182739401700032519141448997853772603766e-02_RKB &
    , 9.2732796595177634284411468920243604212700249381931076964956469143626665557434385492325784596343112153704094886248672e-03_RKB &
    , 6.6307039159312921733198263697501681336283882177812585973955597357837568277731921327731815844512598157843672104469554e-03_RKB &
    , 3.8904611270998840512672018445155032785151429848864649214200101281144733676455451061226273655941038347210163533085954e-03_RKB &
    , 1.3890136986770076245515912267596996810488412919632724534411055332301367130989865366956251556423820479579333920310978e-03_RKB ]
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weightK61
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Return the Kronrod \f$2n + 1\f$ nodes and weights of the extension to the \f$n\f$-point Gauss-Legendre quadrature,
    !>  as well as the \f$n\f$-point Gauss-Legendre weights.
    !>
    !>  \details
    !>  The abscissas and weights for both the Gauss and Kronrod rules are computed for integration over the interval \f$[-1,+1]\f$.<br>
    !>  Also, only the nonnegative abscissas are computed because the quadrature formulae is symmetric with respect to the origin.<br>
    !>  See the documentation of [pm_quadPack](@ref pm_quadPack) for more details on the Gauss-Kronrod quadrature.<br>
    !>
    !>  \param[in]  order   :   The input scalar `integer` of default kind \IK containing the Number of Points in the Gauss quadrature rule.<br>
    !>                          (**optional**. If present, then the rest of the (output vector) arguments must be all `allocatable`.)
    !>  \param[out] nodeK   :   The output `contiguous` or `allocatable` vector of size `(1 : n + 1)` of type `real` of kind \RKALL, containing the Gauss-Kronrod nodes (abscissas).<br>
    !>                          <ol>
    !>                              <li>    If the input argument `order` is present, then `Node` must be an `allocatable` vector that will be reallocated to `order+1` on output.<br>
    !>                              <li>    If the input argument `order` is missing, then `Node` must be a  `contiguous`  vector of size `order + 1`, where `order` is the desired number of points in the Gauss rule.<br>
    !>                          </ol>
    !>  \param[out] weightK :   The output `contiguous` or `allocatable` vector of the same type, kind, and size as `nodeK` containing the Gauss-Kronrod optimal extension weights.<br>
    !>                          <ol>
    !>                              <li>    If the input argument `order` is present, then `weightK` must be an `allocatable` vector that will be reallocated to `order+1` on output.<br>
    !>                              <li>    If the input argument `order` is missing, then `weightK` must be a  `contiguous`  vector of size `order + 1`, where `order` is the desired number of points in the Gauss rule.<br>
    !>                          </ol>
    !>  \param[out] weightG :   The output `contiguous` or `allocatable` vector of size `(size(nodeK) / 2)`, of the same type and kind as `nodeK` containing the Gauss-Legendre weights.<br>
    !>                          By definition, the elements of `weightG(:)` correspond to the node elements `nodeK(2::2)`.<br>
    !>                          <ol>
    !>                              <li>    If the input argument `order` is present, then `weightG` must be an `allocatable` vector that will be reallocated to `(order+1)/2` on output.<br>
    !>                              <li>    If the input argument `order` is missing, then `weightG` must be a  `contiguous`  vector of size `order + 1`, where `order` is the desired number of points in the Gauss rule.<br>
    !>                          </ol>
    !>
    !>  \interface{setNodeWeightGK}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: setNodeWeightGK
    !>
    !>      call setNodeWeightGK(nodeK, weightK, weightG)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The number of points \f$n\f$ in the Gauss quadrature rule is determined from the size of the specified `nodeK` argument as `n = size(nodeK) - 1`.<br>
    !>  As such, the sizes of `weightK` and `weightG` must be `size(nodeK) - 1` and `size(nodeK) / 2` respectively.<br>
    !>  \vericons
    !>
    !>  \impure
    !>
    !>  \see
    !>  [Robert Piessens, Maria Branders, 1974, A Note on the Optimal Addition of Abscissas to Quadrature Formulas of Gauss and Lobatto, Mathematics of Computation, 28, 125, 135-139](https://www.ams.org/journals/mcom/1974-28-125/S0025-5718-1974-0343552-5/S0025-5718-1974-0343552-5.pdf).<br>
    !>  [Laurie, 1997, Calculation of gauss-kronrod quadrature rules](https://www.ams.org/mcom/1997-66-219/S0025-5718-97-00861-2/S0025-5718-97-00861-2.pdf).<br>
    !>  [Kronrod, 1965, Nodes and weights of quadrature formulas](https://api.semanticscholar.org/CorpusID:123027420).<br>
    !>  [FORTRAN90 version by John Burkardt](https://people.sc.fsu.edu/~jburkardt/m_src/kronrod/kronrod.html).<br>
    !>
    !>  \example{setNodeWeightGK}
    !>  \include{lineno} example/pm_quadPack/setNodeWeightGK/main.F90
    !>  \compilef{setNodeWeightGK}
    !>  \output{setNodeWeightGK}
    !>  \include{lineno} example/pm_quadPack/setNodeWeightGK/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{setNodeWeightGK}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface setNodeWeightGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setNodeWeightGKFixed_RK5(nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKFixed_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)   , intent(out)   , contiguous    :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setNodeWeightGKFixed_RK4(nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKFixed_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)   , intent(out)   , contiguous    :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setNodeWeightGKFixed_RK3(nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKFixed_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)   , intent(out)   , contiguous    :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setNodeWeightGKFixed_RK2(nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKFixed_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)   , intent(out)   , contiguous    :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setNodeWeightGKFixed_RK1(nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKFixed_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)   , intent(out)   , contiguous    :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setNodeWeightGKAlloc_RK5(order, nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKAlloc_RK5
#endif
        use pm_kind, only: RKG => RK5
        integer(IK) , intent(in)                    :: order
        real(RKG)   , intent(out)   , allocatable   :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setNodeWeightGKAlloc_RK4(order, nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKAlloc_RK4
#endif
        use pm_kind, only: RKG => RK4
        integer(IK) , intent(in)                    :: order
        real(RKG)   , intent(out)   , allocatable   :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setNodeWeightGKAlloc_RK3(order, nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKAlloc_RK3
#endif
        use pm_kind, only: RKG => RK3
        integer(IK) , intent(in)                    :: order
        real(RKG)   , intent(out)   , allocatable   :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setNodeWeightGKAlloc_RK2(order, nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKAlloc_RK2
#endif
        use pm_kind, only: RKG => RK2
        integer(IK) , intent(in)                    :: order
        real(RKG)   , intent(out)   , allocatable   :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setNodeWeightGKAlloc_RK1(order, nodeK, weightK, weightG)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setNodeWeightGKAlloc_RK1
#endif
        use pm_kind, only: RKG => RK1
        integer(IK) , intent(in)                    :: order
        real(RKG)   , intent(out)   , allocatable   :: nodeK(:), weightG(:), weightK(:)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    ! Naming convention: getQuadGKDFU, getQuadGKDPU, getQuadGKDNU, getQuadGKDBU
    ! G: Gauss rule,
    ! K: Kronrod rule,
    ! D: default method,
    ! F: finite integration limits,
    ! P: Positive integration limit,
    ! N: Negative integration limit,
    ! B: Both negative and positive integration limits,

    !>  \brief
    !>  Compute the 1D integral of the input scalar integrand `getFunc` on the finite or infinite interval `[a, b]`
    !>  and estimate its absolute error via the requested **non-adaptive** Gauss-Kronrod (GK) extension rule.
    !>
    !>  \param      getFunc         :   The input function to be integrated (i.e., the integrand).
    !>                                      -#  On entry, it must take an input scalar of the same type and kind as `abserr`.<br>
    !>                                      -#  On exit, it must generate an input scalar of the same type and kind as `abserr`, representing the corresponding function value.<br>
    !>                                  The following illustrates the general interface of `getFunc`:
    !>                                  \code{.F90}
    !>
    !>                                      function getFunc(x) result(func)
    !>                                          use pm_kind, only: RK => RKG
    !>                                          real(RK)    , intent(in)    :: x
    !>                                          real(RK)                    :: func
    !>                                      end function
    !>
    !>                                  \endcode
    !>                                  where `RKG` refers to any desired `real` kind supported by the processor that is desired for the output `abserr`.<br>
    !>  \param[in]  lb              :   The input scalar argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    a value of type `real` of the same kind as the kind for the output `abserr`, representing the lower limit of integration, or<br>
    !>                                      <li>    the constant [ninf](@ref pm_mathConst::ninf), representing negative infinity (\f$-\infty\f$) as the lower limit of integration.<br>
    !>                                  </ol>
    !>  \param[in]  ub              :   The input scalar argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    a value of type `real` of the same kind as the kind for the output `abserr`, representing the upper limit of integration, or<br>
    !>                                      <li>    the constant [pinf](@ref pm_mathConst::pinf), representing positive infinity (\f$+\infty\f$) as the upper limit of integration.<br>
    !>                                  </ol>
    !>  \param[out] qrule           :   The input scalar constant argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    [GK15](@ref pm_quadPack::GK15) of type [GK15_type](@ref pm_quadPack::GK15_type), or<br>
    !>                                      <li>    [GK21](@ref pm_quadPack::GK21) of type [GK21_type](@ref pm_quadPack::GK21_type), or<br>
    !>                                      <li>    [GK31](@ref pm_quadPack::GK31) of type [GK31_type](@ref pm_quadPack::GK31_type), or<br>
    !>                                      <li>    [GK41](@ref pm_quadPack::GK41) of type [GK41_type](@ref pm_quadPack::GK41_type), or<br>
    !>                                      <li>    [GK51](@ref pm_quadPack::GK51) of type [GK51_type](@ref pm_quadPack::GK51_type), or<br>
    !>                                      <li>    [GK61](@ref pm_quadPack::GK61) of type [GK61_type](@ref pm_quadPack::GK61_type).<br>
    !>                                  </ol>
    !>                                  The specified objects are empty and merely serve to differentiate the multitude of orders of Gauss-Kronrod quadrature rules.<br>
    !>                                  For example, specifying [GK15](@ref pm_quadPack::GK15) dictates the use of 15-points Gauss-Kronrod quadrature rules for computing the integral and estimating its error.<br>
    !>                                  (**optional**. It can be present <b>if and only if</b> `nodeK`, `weightK` and `weightG` optional input arguments are missing.)
    !>  \param[in]  nodeK           :   The input `contiguous` vector argument of the same type and kind as `abserr`, of size \f$n + 1\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the nodes of the \f$n\f$-points Gauss-Legendre quadrature rule and its \f$n+1\f$-points Kronrod extension rule.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It can be present <b>if and only if</b> `weightK` and `weightG` optional input arguments are present and `qrule` is missing.)
    !>  \param[in]  weightK         :   The input `contiguous` vector argument of the same type and kind as `abserr`, of size \f$n + 1\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the Kronrod optimal extension weights for the \f$2n+1\f$-points Gauss-Legendre-Kronrod quadrature method.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It can be present <b>if and only if</b> `nodeK` and `weightG` optional input arguments are present and `qrule` is missing.)
    !>  \param[in]  weightG         :   The input `contiguous` vector argument of the same type and kind as `abserr`, of size \f$(n + 1)/2\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the weights for the \f$n\f$-points Gauss-Legendre quadrature method.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It can be present <b>if and only if</b> `nodeK` and `weightK` optional input arguments are present and `qrule` is missing.)
    !>  \param[out] abserr          :   The output scalar argument of type `real` of kind \RKALL, representing the estimated absolute error in the resulting integral.<br>
    !>  \param[out] intAbsFunc      :   The output scalar argument of the same type and kind as `abserr`, representing the integral of the absolute value of the input integrand function `getFunc()` over the specified range `[lb, ub]`.<br>
    !>                                  This output is not of primary use to the end users, but is required for computation of global error and the stopping rule in Global Adaptive Quadrature algorithms.<br>
    !>  \param[out] smoothness      :   The output scalar argument of the same type and kind as `abserr`, representing a measure of the smoothness of the input integrand function `getFunc()` over the specified range `[lb, ub]`.<br>
    !>                                  This output is not of primary use to the end users, but is required for computation of global error and the stopping rule in Global Adaptive Quadrature algorithms.<br>
    !>
    !>  \return
    !>  `quadGK`                    :   The output scalar of the same type and kind as the output `abserr`, containing the integral of the specified integrand `getFunc()` over the specified range `[lb, ub]`.
    !>
    !>  \interface{getQuadGK}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: getQuadGK
    !>
    !>      quadGK = getQuadGK(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness)
    !>      quadGK = getQuadGK(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `lb < ub` must hold for the corresponding procedure argument.<br>
    !>  Also, the conditions `size(nodeK) == size(weightK)` and `ssize(weightG) == size(nodeK) / 2` must hold for the corresponding procedure arguments, if present.<br>
    !>  \vericons
    !>
    !>  \warning
    !>  If the target function contains points of difficulties, singularities, or discontinuities,
    !>  user must ensure the abscissas of the specified Gauss-Kronrod rule do not match such points.<br>
    !>  Particularly, computing an integrand at its singularities can lead to undefined values that can lead
    !>  to unexpected **segmentation fault** or propagation of `NaN` values within the computational flow
    !>  or other strange errors that can be extremely difficult to debug.<br>
    !>  A simple check can be added within the target integrand implementations to ensure no such difficulty point matches an input value at which the function must be evaluated.<br>
    !>  Alternatively, one should consider using the adaptive integration routines [isFailedQuad](@ref pm_quadPack::isFailedQuad) or [getQuadErr](@ref pm_quadPack::getQuadErr)
    !>  while setting their input `help` arguments to the points of difficulties of the integrand.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [Robert Piessens, Maria Branders, 1974, A Note on the Optimal Addition of Abscissas to Quadrature Formulas of Gauss and Lobatto, Mathematics of Computation, 28, 125, 135-139](https://www.ams.org/journals/mcom/1974-28-125/S0025-5718-1974-0343552-5/S0025-5718-1974-0343552-5.pdf).<br>
    !>  [Laurie, 1997, Calculation of gauss-kronrod quadrature rules](https://www.ams.org/mcom/1997-66-219/S0025-5718-97-00861-2/S0025-5718-97-00861-2.pdf).<br>
    !>  [Kronrod, 1965, Nodes and weights of quadrature formulas](https://api.semanticscholar.org/CorpusID:123027420).<br>
    !>  [FORTRAN90 version by John Burkardt](https://people.sc.fsu.edu/~jburkardt/m_src/kronrod/kronrod.html).<br>
    !>
    !>  \example
    !>  \include{lineno} example/pm_quadPack/getQuadGK/main.F90
    !>  \compilef
    !>  \output
    !>  \include{lineno} example/pm_quadPack/getQuadGK/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{getQuadGK}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan

    ! GK15

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK15_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK15_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK15_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK15_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK15_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK15_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK15_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK15_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK15_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK15_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK15_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK15_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK15_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK15_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK15_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK15_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK15_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK15_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK15_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK15_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK15_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK15_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GK21

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK21_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK21_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK21_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK21_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK21_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK21_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK21_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK21_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK21_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK21_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK21_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK21_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK21_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK21_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK21_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK21_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK21_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK21_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK21_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK21_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK21_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK21_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GK31

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK31_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK31_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK31_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK31_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK31_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK31_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK31_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK31_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK31_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK31_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK31_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK31_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK31_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK31_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK31_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK31_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK31_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK31_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK31_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK31_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK31_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK31_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GK41

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK41_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK41_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK41_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK41_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK41_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK41_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK41_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK41_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK41_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK41_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK41_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK41_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK41_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK41_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK41_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK41_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK41_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK41_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK41_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK41_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK41_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK41_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GK51

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK51_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK51_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK51_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK51_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK51_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK51_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK51_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK51_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK51_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK51_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK51_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK51_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK51_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK51_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK51_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK51_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK51_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK51_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK51_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK51_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK51_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK51_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GK61

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK61_FF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK61_FF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK61_FF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK61_FF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK61_FF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK61_FI_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK61_FI_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK61_FI_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK61_FI_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK61_FI_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK61_IF_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK61_IF_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK61_IF_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK61_IF_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK61_IF_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGK61_II_RK5(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGK61_II_RK4(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGK61_II_RK3(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGK61_II_RK2(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGK61_II_RK1(getFunc, lb, ub, qrule, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGK61_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        type(GK61_type) , intent(in)                    :: qrule
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! GKXX

    interface getQuadGK

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGKXX_FF_RK5(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGKXX_FF_RK4(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGKXX_FF_RK3(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGKXX_FF_RK2(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGKXX_FF_RK1(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGKXX_FI_RK5(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGKXX_FI_RK4(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGKXX_FI_RK3(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGKXX_FI_RK2(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGKXX_FI_RK1(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        real(RKG)       , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGKXX_IF_RK5(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGKXX_IF_RK4(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGKXX_IF_RK3(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGKXX_IF_RK2(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGKXX_IF_RK1(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        real(RKG)       , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function getQuadGKXX_II_RK5(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK4_ENABLED
    module function getQuadGKXX_II_RK4(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK3_ENABLED
    module function getQuadGKXX_II_RK3(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK2_ENABLED
    module function getQuadGKXX_II_RK2(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

#if RK1_ENABLED
    module function getQuadGKXX_II_RK1(getFunc, lb, ub, nodeK, weightK, weightG, abserr, intAbsFunc, smoothness) result(quadGK)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: getQuadGKXX_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                            :: getFunc
        type(ninf_type) , intent(in)                    :: lb
        type(pinf_type) , intent(in)                    :: ub
        real(RKG)       , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)       , intent(out)                   :: abserr, intAbsFunc, smoothness
        real(RKG)                                       :: quadGK
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  The scalar `integer` of default kind \IK, containing the maximum size of the Table of Epsilon algorithm.
    !>
    !>  \details
    !>  This parameter is used by the various quadrature procedures of this module to perform integration extrapolations.
    !>
    !>  \warning
    !>  If the Epsilon table size exceeds this number, the upper diagonal of the Epsilon table will be deleted.
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [setSeqLimEps](@ref pm_quadPack::setSeqLimEps)<br>
    !>
    !>  \final{MAXLEN_EPSTAB}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    integer(IK) , parameter :: MAXLEN_EPSTAB = 50_IK

    !>  \brief
    !>  This is the indicator type for generating instances of objects that indicate the use of Epsilon extrapolation method of
    !>  Wynn (1961) to accelerate the convergence of integrations of functions with integrable singularities and infinities using
    !>  the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadErr](@ref pm_quadPack::getQuadErr).
    !>
    !>  \details
    !>  This is an empty derived type that exists solely for generating unique objects that are distinguishable
    !>  as input arguments to procedures under the generic interface [getQuadErr](@ref pm_quadPack::getQuadErr).
    !>
    !>  \interface{weps_type}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: weps
    !>      type(weps_type), parameter :: weps
    !>
    !>  \endcode
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weps_type}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type :: weps_type
    end type

    !>  \brief
    !>  The scalar constant object of type [weps_type](@ref pm_quadPack::weps_type) that indicates the use of Epsilon extrapolation method of
    !>  Wynn (1961) to accelerate the convergence of integrations of functions with integrable singularities and infinities using
    !>  the (Adaptive) Global Gauss-Kronrod Quadrature of [getQuadErr](@ref pm_quadPack::getQuadErr).
    !>
    !>  \details
    !>  See the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr) for example usage.<br>
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{weps}
    !>
    !>  \author
    !>  \AmirShahmoradi, September 1, 2017, 12:00 AM, Institute for Computational Engineering and Sciences (ICES), The University of Texas Austin<br>
    type(weps_type) , parameter :: weps = weps_type()
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
    !DIR$ ATTRIBUTES DLLEXPORT :: weps
#endif

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Return the limit of a given sequence of approximations via the Epsilon method of Wynn (1961).
    !>
    !>  \details
    !>  Also return an estimate of the absolute error in the limit.<br>
    !>
    !>  \remark
    !>  This generic interface is meant to be primarily by and used within the Adaptive Gauss-Kronrod quadrature routines of the parent module.<br>
    !>  There is practically no usage for this generic interface outside of the parent module.<br>
    !>
    !>  \param[inout]   inew        :   The input/output scalar of type `integer` of default kind \IK, containing the index of the new element in the first column of the Epsilon table.<br>
    !>  \param[inout]   ical        :   The input/output scalar of type `integer` of default kind \IK, containing the number of calls made to the procedure.<br>
    !>                                  On the first call `ical = 0` must hold.
    !>  \param[inout]   EpsTable    :   The input/output vector of type `real` of kind \RKALL, of size ([MAXLEN_EPSTAB](@ref pm_quadPack::MAXLEN_EPSTAB) + 2),
    !>                                  containing the elements of the two lower diagonals of the triangular Epsilon table.<br>
    !>                                  The elements are numbered starting at the right-hand corner of the triangle.<br>
    !>  \param[inout]   SeqLims     :   The input/output vector of size `(3)` of the same type and kind as `EpsTable(:)`, containing the last three computed sequence limits.<br>
    !>  \param[out]     seqlim      :   The output scalar of the same type and kind as `EpsTable(:)`, containing the sequence limit.<br>
    !>  \param[out]     abserr      :   The output scalar of the same type and kind as `EpsTable(:)`, containing the sequence limit absolute error estimate.<br>
    !>
    !>  \interface{setSeqLimEps}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: setSeqLimEps
    !>
    !>      call setSeqLimEps(inew, ical, EpsTable, SeqLims, seqlim, error)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [P. Wynn, 1961, The Epsilon Algorithm and Operational Formulas](https://www.ams.org/mcom/1961-15-074/S0025-5718-1961-0158513-X/S0025-5718-1961-0158513-X.pdf).<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{setSeqLimEps}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface setSeqLimEps

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    pure module subroutine setSeqLimEps_RK5(inew, ical, EpsTable, SeqLims, seqlim, abserr)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setSeqLimEps_RK5
#endif
        use pm_kind, only: RKG => RK5
        integer(IK) , intent(inout)                 :: inew, ical
        real(RKG)   , intent(inout)                 :: EpsTable(MAXLEN_EPSTAB + 2), SeqLims(3)
        real(RKG)   , intent(out)                   :: seqlim, abserr
    end subroutine
#endif

#if RK4_ENABLED
    pure module subroutine setSeqLimEps_RK4(inew, ical, EpsTable, SeqLims, seqlim, abserr)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setSeqLimEps_RK4
#endif
        use pm_kind, only: RKG => RK4
        integer(IK) , intent(inout)                 :: inew, ical
        real(RKG)   , intent(inout)                 :: EpsTable(MAXLEN_EPSTAB + 2), SeqLims(3)
        real(RKG)   , intent(out)                   :: seqlim, abserr
    end subroutine
#endif

#if RK3_ENABLED
    pure module subroutine setSeqLimEps_RK3(inew, ical, EpsTable, SeqLims, seqlim, abserr)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setSeqLimEps_RK3
#endif
        use pm_kind, only: RKG => RK3
        integer(IK) , intent(inout)                 :: inew, ical
        real(RKG)   , intent(inout)                 :: EpsTable(MAXLEN_EPSTAB + 2), SeqLims(3)
        real(RKG)   , intent(out)                   :: seqlim, abserr
    end subroutine
#endif

#if RK2_ENABLED
    pure module subroutine setSeqLimEps_RK2(inew, ical, EpsTable, SeqLims, seqlim, abserr)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setSeqLimEps_RK2
#endif
        use pm_kind, only: RKG => RK2
        integer(IK) , intent(inout)                 :: inew, ical
        real(RKG)   , intent(inout)                 :: EpsTable(MAXLEN_EPSTAB + 2), SeqLims(3)
        real(RKG)   , intent(out)                   :: seqlim, abserr
    end subroutine
#endif

#if RK1_ENABLED
    pure module subroutine setSeqLimEps_RK1(inew, ical, EpsTable, SeqLims, seqlim, abserr)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setSeqLimEps_RK1
#endif
        use pm_kind, only: RKG => RK1
        integer(IK) , intent(inout)                 :: inew, ical
        real(RKG)   , intent(inout)                 :: EpsTable(MAXLEN_EPSTAB + 2), SeqLims(3)
        real(RKG)   , intent(out)                   :: seqlim, abserr
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Sort the input local error estimates list (resulting from the interval subdivision process of the Adaptive Global
    !>  quadrature procedures of this module) in descending order.
    !>
    !>  \brief
    !>  Two error estimates are inserted using the sequential search method at each call to this interface,
    !>  top-down for the largest error estimate and bottom-up for the smallest error estimate.
    !>
    !>  \remark
    !>  This generic interface is meant to be primarily by and used within the Adaptive Gauss-Kronrod quadrature routines of the parent module.<br>
    !>  There is practically no usage for this generic interface outside of the parent module.<br>
    !>
    !>  \param[in]      nintmax     :   The input scalar of type `integer` of default kind \IK, containing the maximum number of subintervals allowed in the quadrature.<br>
    !>  \param[in]      sinfoErr    :   The input vector of size `(1:nint <= nintmax)`, containing the local error estimates from the quadrature subintervals.<br>
    !>  \param[inout]   sindex      :   The input/output `contiguous` vector of the same type, kind, and size as `sinfoErr(:)`, the first `k` elements of which contain
    !>                                  pointers to the error estimates, such that `sinfoErr(sindex(1)), ..., sinfoErr(sindex(k))` form a decreasing sequence,
    !>                                  with `k = nint` if `nint <= (nintmax / 2 + 2)`, and `k = nintmax + 1 - nint` otherwise.
    !>  \param[inout]   nrmax       :   The input/output scalar of type `integer` of default kind \IK, containing the index of element of `sindex(:)`,
    !>                                  such that `maxErrLoc = sindex(nrmax)` number of calls made to the procedure.<br>
    !>  \param[inout]   maxErrLoc   :   The input/output scalar of type `integer` of kind \IK, containing the `nrmax`-th largest error estimate currently in the error list.<br>
    !>  \param[out]     maxErrVal   :   The output scalar of the same type and kind as `sinfoErr(:)`, containing the `nrmax`-th largest error estimate in the error list.<br>
    !>
    !>  \interface{setErrSorted}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: setErrSorted
    !>
    !>      call setErrSorted(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
    !>
    !>  \endcode
    !>
    !>  \warnpure
    !>
    !>  \see
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{setErrSorted}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface setErrSorted

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    PURE module subroutine setErrSorted_RK5(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setErrSorted_RK5
#endif
        use pm_kind, only: RKG => RK5
        integer(IK) , intent(in)                    :: nintmax
        real(RKG)   , intent(in)                    :: sinfoErr(:)
        integer(IK) , intent(inout) , contiguous    :: sindex(:)
        integer(IK) , intent(inout)                 :: nrmax, maxErrLoc
        real(RKG)   , intent(out)                   :: maxErrVal
    end subroutine
#endif

#if RK4_ENABLED
    PURE module subroutine setErrSorted_RK4(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setErrSorted_RK4
#endif
        use pm_kind, only: RKG => RK4
        integer(IK) , intent(in)                    :: nintmax
        real(RKG)   , intent(in)                    :: sinfoErr(:)
        integer(IK) , intent(inout) , contiguous    :: sindex(:)
        integer(IK) , intent(inout)                 :: nrmax, maxErrLoc
        real(RKG)   , intent(out)                   :: maxErrVal
    end subroutine
#endif

#if RK3_ENABLED
    PURE module subroutine setErrSorted_RK3(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setErrSorted_RK3
#endif
        use pm_kind, only: RKG => RK3
        integer(IK) , intent(in)                    :: nintmax
        real(RKG)   , intent(in)                    :: sinfoErr(:)
        integer(IK) , intent(inout) , contiguous    :: sindex(:)
        integer(IK) , intent(inout)                 :: nrmax, maxErrLoc
        real(RKG)   , intent(out)                   :: maxErrVal
    end subroutine
#endif

#if RK2_ENABLED
    PURE module subroutine setErrSorted_RK2(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setErrSorted_RK2
#endif
        use pm_kind, only: RKG => RK2
        integer(IK) , intent(in)                    :: nintmax
        real(RKG)   , intent(in)                    :: sinfoErr(:)
        integer(IK) , intent(inout) , contiguous    :: sindex(:)
        integer(IK) , intent(inout)                 :: nrmax, maxErrLoc
        real(RKG)   , intent(out)                   :: maxErrVal
    end subroutine
#endif

#if RK1_ENABLED
    PURE module subroutine setErrSorted_RK1(nintmax, sinfoErr, sindex, nrmax, maxErrLoc, maxErrVal)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setErrSorted_RK1
#endif
        use pm_kind, only: RKG => RK1
        integer(IK) , intent(in)                    :: nintmax
        real(RKG)   , intent(in)                    :: sinfoErr(:)
        integer(IK) , intent(inout) , contiguous    :: sindex(:)
        integer(IK) , intent(inout)                 :: nrmax, maxErrLoc
        real(RKG)   , intent(out)                   :: maxErrVal
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Compute and return the series expansion of the input function values via the Chebyshev
    !>  polynomials of the first kind of degrees `12` and `24` using Fast Fourier Transform method.
    !>
    !>  \details
    !>  The returned coefficients are such that,<br>
    !>  \f{eqnarray}{
    !>
    !>     f(x) &=& \sum_{k = 1}^{13} \ms{cheb12}(k) \times T(k-1,x) ~, \\
    !>     f(x) &=& \sum_{k = 1}^{25} \ms{cheb24}(k) \times T(k-1,x) ~,
    !>
    !>  \f}
    !>  where \f$T(n,x)\f$ is the Chebyshev polynomial of the first kind of degree \f$n\f$ evaluated at proper points.<br>
    !>
    !>  \remark
    !>  This generic interface is meant to be primarily by and used within the Adaptive Gauss-Kronrod quadrature routines of the parent module.<br>
    !>  There is practically no usage for this generic interface outside of the parent module.<br>
    !>
    !>  \param[inout]   func    :   The input/output vector of size `25` of type `real` of kind \RKALL, containing the function values.<br>
    !>  \param[out]     cheb12  :   The output vector of the same type and kind as `func`, of size `13`, containing the Chebyshev Coefficients of degree `12`.
    !>  \param[out]     cheb24  :   The output vector of the same type and kind as `func`, of size `25`, containing the Chebyshev Coefficients of degree `24`.
    !>
    !>  \interface{setChebExpan}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: setChebExpan
    !>
    !>      call setChebExpan(func, cheb12, cheb24)
    !>
    !>  \endcode
    !>
    !>  \pure
    !>
    !>  \see
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [getQuadRomb](@ref pm_quadRomb::getQuadRomb)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{setChebExpan}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface setChebExpan

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    pure module subroutine setChebExpan_RK5(func, cheb12, cheb24)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setChebExpan_RK5
#endif
        use pm_kind, only: RKG => RK5
        real(RKG)       , intent(inout)                 :: func(25)
        real(RKG)       , intent(out)                   :: cheb12(13), cheb24(25)
    end subroutine
#endif

#if RK4_ENABLED
    pure module subroutine setChebExpan_RK4(func, cheb12, cheb24)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setChebExpan_RK4
#endif
        use pm_kind, only: RKG => RK4
        real(RKG)       , intent(inout)                 :: func(25)
        real(RKG)       , intent(out)                   :: cheb12(13), cheb24(25)
    end subroutine
#endif

#if RK3_ENABLED
    pure module subroutine setChebExpan_RK3(func, cheb12, cheb24)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setChebExpan_RK3
#endif
        use pm_kind, only: RKG => RK3
        real(RKG)       , intent(inout)                 :: func(25)
        real(RKG)       , intent(out)                   :: cheb12(13), cheb24(25)
    end subroutine
#endif

#if RK2_ENABLED
    pure module subroutine setChebExpan_RK2(func, cheb12, cheb24)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setChebExpan_RK2
#endif
        use pm_kind, only: RKG => RK2
        real(RKG)       , intent(inout)                 :: func(25)
        real(RKG)       , intent(out)                   :: cheb12(13), cheb24(25)
    end subroutine
#endif

#if RK1_ENABLED
    pure module subroutine setChebExpan_RK1(func, cheb12, cheb24)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: setChebExpan_RK1
#endif
        use pm_kind, only: RKG => RK1
        real(RKG)       , intent(inout)                 :: func(25)
        real(RKG)       , intent(out)                   :: cheb12(13), cheb24(25)
    end subroutine
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Compute the 1D integral of the input scalar (potentially singular) integrand `getFunc` on a finite or semi/fully-infinite
    !>  interval `(a, b)` and estimate its absolute error via the requested **adaptive global quadrature** rule.
    !>
    !>  \details
    !>  This interface provides a simple nimble powerful wrapper for the higher-performance but lower-level [getQuadErr](@ref pm_quadPack::getQuadErr) interface, much like the \f$\ms{integral}\f$ routine of MATLAB.<br>
    !>  The algorithm uses an Adaptive Global Quadrature with Gauss-Kronrod 10-21 quadrature rules combined with the Epsilon extrapolation method of Wynn (1961) to evaluate the integral.<br>
    !>  See the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr) for further details on the integration methodologies and implementations.<br>
    !>
    !>  \param      getFunc         :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>  \param[in]  lb              :   The input scalar of type `real` of the same kind as `integral`, representing the lower limit of integration.<br>
    !>                                  Set `lb = -huge(lb)` or to the IEEE-compliant negative infinity (`lb = `[getInfNeg(lb)](@ref pm_except::getInfNeg))
    !>                                  to imply \f$-\infty\f$ as the lower bound of integration.<br>
    !>  \param[in]  ub              :   The input scalar of type `real` of the same kind as `integral`, representing the upper limit of integration.<br>
    !>                                  Set `ub = huge(ub)` or to the IEEE-compliant positive infinity (`ub = `[getInfPos(lb)](@ref pm_except::getInfPos))
    !>                                  to imply \f$+\infty\f$ as the upper bound of integration.<br>
    !>  \param[out] integral        :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>  \param[in]  abstol          :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**, default = `0`)<br>
    !>  \param[in]  reltol          :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**, default = `epsilon(real(0, kind(integral)))**(2./3.)`)<br>
    !>  \param[in]  help            :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**. If missing, the procedure attempts to compute the integral without explicit assumptions about the singularities or discontinuities.)<br>
    !>  \param[out] abserr          :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**. If missing, the estimated error of the integral will not be returned.)<br>
    !>  \param[out] neval           :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**. If missing, the number of function evaluations will not be returned.)<br>
    !>  \param[out] nint            :   See the description of the corresponding argument in the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr).<br>
    !>                                  (**optional**. If missing, the number of subintervals formed will not be returned.)<br>
    !>  \param[out] msg             :   The output scalar argument of type `character` of default kind \SK of arbitrary length type parameter that is set to a diagnostic message if the integration fails to converge.<br>
    !>                                  A length type parameter of `127` is sufficient to capture all error messages.<br>
    !>                                  If `msg` has shorter length parameter, the output message will be trimmed from the end, otherwise padded with blanks as necessary.<br>
    !>                                  (**optional**. If missing, no diagnostic message will be returned.)<br>
    !>
    !>  \return
    !>  `failed`                    :   The output scalar of type `logical` of default kind \LK, that is set to `.true.` <b>if and only if</b> the integration **fails to converge within the requested tolerances**.<br>
    !>                                  Otherwise, it is set `.false.` if the integration succeeds with no errors.<br>
    !>                                  See the description of the output argument `err` of [getQuadErr](@ref pm_quadPack::getQuadErr) for information on the kinds of integration failures that can happen.<br>
    !>
    !>  \interface{isFailedQuad}
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: isFailedQuad
    !>      use pm_kind, only: LK
    !>      logical(LK) :: failed
    !>
    !>      failed = isFailedQuad(getFunc, lb, ub       , integral, abserr = abserr, abstol = abstol, reltol = reltol, neval = neval, nint = nint, msg = msg)
    !>      failed = isFailedQuad(getFunc, lb, ub, help , integral, abserr = abserr, abstol = abstol, reltol = reltol, neval = neval, nint = nint, msg = msg)
    !>
    !>  \endcode
    !>
    !>  \warning
    !>  All conditions in the **warning** section of the documentation of [getQuadErr](@ref pm_quadPack::getQuadErr) also apply to this interface.<br>
    !>  \vericons
    !>
    !>  \warning
    !>  If the target function contains points of difficulties, singularities, or discontinuities,
    !>  user must ensure the abscissas of the specified Gauss-Kronrod rule do not match such points.<br>
    !>  Particularly, computing an integrand at its singularities can lead to undefined values that can lead
    !>  to unexpected **segmentation fault** or propagation of `NaN` values within the computational flow
    !>  or other strange errors that can be extremely difficult to debug.<br>
    !>  A simple check can be added within the target integrand implementations to ensure no such difficulty point matches an input value at which the function must be evaluated.<br>
    !>  Alternatively, one should consider using the adaptive integration routines [isFailedQuad](@ref pm_quadPack::isFailedQuad) or [getQuadErr](@ref pm_quadPack::getQuadErr)
    !>  while setting their input `help` arguments to the points of difficulties of the integrand.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getQuadGK](@ref pm_quadPack::getQuadGK)<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [getQuadRomb](@ref pm_quadRomb::getQuadRomb)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad)<br>
    !>
    !>  \example{isFailedQuad}
    !>  \include{lineno} example/pm_quadPack/isFailedQuad/main.F90
    !>  \compilef{isFailedQuad}
    !>  \output{isFailedQuad}
    !>  \include{lineno} example/pm_quadPack/isFailedQuad/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{isFailedQuad}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan
    interface isFailedQuad

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function isFailedQuadQAGD_RK5(getFunc, lb, ub, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGD_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK4_ENABLED
    module function isFailedQuadQAGD_RK4(getFunc, lb, ub, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGD_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK3_ENABLED
    module function isFailedQuadQAGD_RK3(getFunc, lb, ub, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGD_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK2_ENABLED
    module function isFailedQuadQAGD_RK2(getFunc, lb, ub, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGD_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK1_ENABLED
    module function isFailedQuadQAGD_RK1(getFunc, lb, ub, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGD_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function isFailedQuadQAGS_RK5(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGS_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(weps_type)     , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK4_ENABLED
    module function isFailedQuadQAGS_RK4(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGS_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(weps_type)     , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK3_ENABLED
    module function isFailedQuadQAGS_RK3(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGS_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(weps_type)     , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK2_ENABLED
    module function isFailedQuadQAGS_RK2(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGS_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(weps_type)     , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK1_ENABLED
    module function isFailedQuadQAGS_RK1(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGS_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(weps_type)     , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function isFailedQuadQAGP_RK5(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGP_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(in)    , contiguous            :: help(:)
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK4_ENABLED
    module function isFailedQuadQAGP_RK4(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGP_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(in)    , contiguous            :: help(:)
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK3_ENABLED
    module function isFailedQuadQAGP_RK3(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGP_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(in)    , contiguous            :: help(:)
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK2_ENABLED
    module function isFailedQuadQAGP_RK2(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGP_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(in)    , contiguous            :: help(:)
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK1_ENABLED
    module function isFailedQuadQAGP_RK1(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAGP_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        real(RKG)           , intent(in)    , contiguous            :: help(:)
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function isFailedQuadQAWC_RK5(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAWC_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(wcauchy_type)  , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK4_ENABLED
    module function isFailedQuadQAWC_RK4(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAWC_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(wcauchy_type)  , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK3_ENABLED
    module function isFailedQuadQAWC_RK3(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAWC_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(wcauchy_type)  , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK2_ENABLED
    module function isFailedQuadQAWC_RK2(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAWC_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(wcauchy_type)  , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

#if RK1_ENABLED
    module function isFailedQuadQAWC_RK1(getFunc, lb, ub, help, integral, abserr, abstol, reltol, neval, nint, msg) result(failed)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: isFailedQuadQAWC_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                        :: getFunc
        real(RKG)           , intent(in)                            :: lb, ub
        real(RKG)           , intent(out)                           :: integral
        type(wcauchy_type)  , intent(in)                            :: help
        real(RKG)           , intent(out)   , optional              :: abserr
        real(RKG)           , intent(in)    , optional              :: abstol
        real(RKG)           , intent(in)    , optional              :: reltol
        integer(IK)         , intent(out)   , optional              :: neval
        integer(IK)         , intent(out)   , optional              :: nint
        character(*, SK)    , intent(out)   , optional              :: msg
        logical(LK)                                                 :: failed
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    !>  \brief
    !>  Compute the 1D integral of the input scalar (potentially singular) integrand `getFunc` on a finite or semi/fully-infinite
    !>  interval `(a, b)` and estimate its absolute error via the requested **adaptive global Gauss-Kronrod (GK)** extension rules.
    !>
    !>  \details
    !>  The resulting integral hopefully satisfies the accuracy condition `abs(truth - result) <= max(abstol, reltol * abs(i))`,<br>
    !>  where `truth` is the true value of the integral and `abstol, reltol` are the user-specified absolute and relative tolerances, respectively.<br>
    !>  This interface combines and significantly extends the functionalities of the `QAG`, `QAGI`, `QAGP`, `QAGS`, `QAWC`, `QAWO`, `QAWS` subroutines of the venerable QUADPACK library.<br>
    !>
    !>  Specifically,<br>
    !>  <ol>
    !>      <li>    When the input argument `help` is missing, this interface performs **adaptive global Gauss-Kronrod (GK)** with the user-specified
    !>              predefined (7-15 (`GK15`), 10-21 (`GK21`), 15-31 (`GK31`), 20-41 (`GK41`), 25-51 (`GK51`), 30-61 (`GK61`)) Gauss-Kronrod extension rules,<br>
    !>              or with user-specified arbitrarily-defined Gauss-Kronrod extension rules via the triple `(nodeK, weightK, weightG)` input arguments.<br>
    !>              This interface replicates and extends the <b>QAG/QAGE</b> functionalities of the QuadPack library to all Gauss-Kronrod extension rules mentioned above and all `real` kinds supported by the processor.<br>
    !>      <li>    When the input argument `help` is present and set to [weps](@ref pm_quadPack::weps), this interface accelerates the convergence of **adaptive global Gauss-Kronrod (GK)**
    !>              with predefined or arbitrary Gauss-Kronrod rules are mentioned above, via the Epsilon extrapolation algorithm of Wynn (1961)).<br>
    !>              **This extrapolation is particularly helpful with**,<br>
    !>              <ol>
    !>                  <li>    integration of integrands with singularities at or within the integration limits, or<br>
    !>                  <li>    integration of integrands with semi or doubly infinite integration limits,<br>
    !>              </ol>
    !>              possibly leading to orders of magnitude speedup in computing the integral within the requested tolerance.<br>
    !>              This interface replicates and extends the <b>QAGS/QAGSE</b> functionalities of the QuadPack library to all Gauss-Kronrod extension rules and all `real` kinds supported by the processor.<br>
    !>      <li>    When the input argument `help` is present and set to a vector of points of difficulties within the integration domain, this interface accelerates the convergence of **adaptive global Gauss-Kronrod (GK)**
    !>              with predefined or arbitrary Gauss-Kronrod rules are mentioned above via the Epsilon algorithm of Wynn (1961)).<br>
    !>              Simultaneously, the interface carefully takes into account the specified points of integration difficulty (such as singularities or discontinuities) specified in `help`.<br>
    !>              This interface replicates and extends the <b>QAGP/QAGPE</b> functionalities of the QuadPack library to all Gauss-Kronrod extension rules and all `real` kinds supported by the processor.<br>
    !>      <li>    When the integration limits are set to,<br>
    !>              <ol>
    !>                  <li>    `(lb = ninf, ub)`, implying the semi-infinite range \f$(-\infty, \ms{ub})\f$, or<br>
    !>                  <li>    `(lb, ub = pinf)`, implying the semi-infinite range \f$(\ms{lb}, +\infty)\f$, or<br>
    !>                  <li>    `(lb = ninf, ub = pinf)`, implying the fully-infinite range \f$(-\infty, +\infty)\f$,<br>
    !>              </ol>
    !>              this interface first applies the following corresponding change of variables,<br>
    !>              <ol>
    !>                  <li>    \f$x = \ms{ub} - \frac{1 - t}{t}\f$,
    !>                  <li>    \f$x = \ms{lb} + \frac{1 - t}{t}\f$,
    !>                  <li>    \f$x = \frac{1 - t}{t}\f$,
    !>              </ol>
    !>              to the integrand to transform the semi/fully-infinite integration range to the finite range \f$(0, 1)\f$.<br>
    !>              Then it calls the user-specified interface to perform the integration.<br>
    !>              The functionality of this interface significantly extends the functionalities of the <b>QAGI/QAGIE</b> routines of the QuadPack library.<br>
    !>              Specifically, this interface<br>
    !>              <ol>
    !>                  <li>    computes integrals with arbitrary machine precision by accepting all `real` kinds supported by the processor.<br>
    !>                  <li>    allows the use of all predefined or arbitrary Gauss-Kronrod rules for semi or fully infinite integrations.<br>
    !>                  <li>    allows explicit specification of singularities or discontinuities via the input `help` argument for semi or fully infinite integrations.<br>
    !>              </ol>
    !>  </ol>
    !>
    !>  \param      getFunc         :   The input function to be integrated (i.e., the integrand).<br>
    !>                                  <ol>
    !>                                      <li>    On entry, it must take an input scalar of the same type and kind as `integral`.<br>
    !>                                      <li>    On exit, it must generate an input scalar of the same type and kind as `integral`, representing the corresponding function value.<br>
    !>                                  </ol>
    !>                                  The following illustrates the general interface of `getFunc`:<br>
    !>                                  \code{.F90}
    !>
    !>                                      function getFunc(x) result(func)
    !>                                          real(RKG)   , intent(in)    :: x
    !>                                          real(RKG)                   :: func
    !>                                      end function
    !>
    !>                                  \endcode
    !>                                  where `RKG` must match the user-specified kind type parameter for the `integral` output argument below.<br>
    !>  \param[in]  lb              :   The input scalar argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    a value of type `real` of the same kind as `integral`, representing the lower limit of integration, or<br>
    !>                                      <li>    the constant [ninf](@ref pm_mathConst::ninf), representing negative infinity (\f$-\infty\f$) as the lower limit of integration.<br>
    !>                                  </ol>
    !>  \param[in]  ub              :   The input scalar argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    a value of type `real` of the same kind as `integral`, representing the upper limit of integration, or<br>
    !>                                      <li>    the constant [pinf](@ref pm_mathConst::pinf), representing positive infinity (\f$+\infty\f$) as the upper limit of integration.<br>
    !>                                  </ol>
    !>  \param[in]  abstol          :   The input scalar argument of the same type and kind as `integral`, representing the absolute tolerance of integration.<br>
    !>                                  If the estimated integration error reaches a value below this threshold, the integration is assumed to have converged.<br>
    !>                                  This argument can be set to any non-negative value, including `abstol = 0.`.<br>
    !>  \param[in]  reltol          :   The input scalar argument of the same type and kind as `integral`, representing the relative tolerance of integration.<br>
    !>                                  If the relative accuracy of integration reaches a value below this threshold, the integration is assumed to have converged.<br>
    !>                                  This argument can be set to any positive value significantly larger (e.g., \f$\times10000\f$) than `epsilon(real(0., kind(reltol))`.<br>
    !>                                  A good rule of thumb is to set `reltol = epsilon(real(0, kind(integral)))**(2./3.)`.<br>
    !>                                  The integration result is generally orders of magnitude more precise than the specified `reltol`.<br>
    !>  \param[in]  qrule           :   The input scalar constant argument that can be either,<br>
    !>                                  <ol>
    !>                                      <li>    [GK15](@ref pm_quadPack::GK15) of type [GK15_type](@ref pm_quadPack::GK15_type), or<br>
    !>                                      <li>    [GK21](@ref pm_quadPack::GK21) of type [GK21_type](@ref pm_quadPack::GK21_type), or<br>
    !>                                      <li>    [GK31](@ref pm_quadPack::GK31) of type [GK31_type](@ref pm_quadPack::GK31_type), or<br>
    !>                                      <li>    [GK41](@ref pm_quadPack::GK41) of type [GK41_type](@ref pm_quadPack::GK41_type), or<br>
    !>                                      <li>    [GK51](@ref pm_quadPack::GK51) of type [GK51_type](@ref pm_quadPack::GK51_type), or<br>
    !>                                      <li>    [GK61](@ref pm_quadPack::GK61) of type [GK61_type](@ref pm_quadPack::GK61_type).<br>
    !>                                  </ol>
    !>                                  The specified objects are empty and merely serve to differentiate the multitude of orders of Gauss-Kronrod quadrature rules.<br>
    !>                                  For example, specifying [GK15](@ref pm_quadPack::GK15) dictates the use of 15-points Gauss-Kronrod quadrature rules for computing the integral and estimating its error.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> `nodeK`, `weightK` and `weightG` optional input arguments are missing.)
    !>  \param[in]  nodeK           :   The input `contiguous` vector argument of the same type and kind as `integral`, of size \f$n + 1\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the nodes of the \f$n\f$-points Gauss-Legendre quadrature rule and its \f$n+1\f$-points Kronrod extension rule.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> `weightK` and `weightG` optional input arguments are present and `qrule` is missing.)
    !>  \param[in]  weightK         :   The input `contiguous` vector argument of the same type and kind as `integral`, of size \f$n + 1\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the Kronrod optimal extension weights for the \f$2n+1\f$-points Gauss-Legendre-Kronrod quadrature method.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> `nodeK` and `weightG` optional input arguments are present and `qrule` is missing.)
    !>  \param[in]  weightG         :   The input `contiguous` vector argument of the same type and kind as `integral`, of size \f$(n + 1)/2\f$, where \f$n\f$ is the number of points in the Gauss rule to be used for the integration.<br>
    !>                                  It contains the weights for the \f$n\f$-points Gauss-Legendre quadrature method.<br>
    !>                                  The procedures under the generic interface [setNodeWeightGK](@ref pm_quadPack::setNodeWeightGK) return this vector.<br>
    !>                                  (**optional**. It must be present <b>if and only if</b> `nodeK` and `weightK` optional input arguments are present and `qrule` is missing.)
    !>  \param[in]  help            :   The input scalar constant argument that can be any of the following:<br>
    !>                                  <ol>
    !>                                      <li>    The scalar constant [weps](@ref pm_quadPack::weps) of an object of type [weps_type](@ref pm_quadPack::weps_type),
    !>                                              implying the use of the Epsilon extrapolation algorithm of Wynn (1961)) for computing the integral and estimating its error.<br>
    !>                                              The specified objects are empty and merely serve to differentiate the multitude of different extrapolation methods to accelerate the integration convergence.<br>
    !>                                              **Specify this argument as [weps](@ref pm_quadPack::weps) if you suspect the integrand contains integrable singularities or the integration range is semi/fully-infinite.**<br>
    !>                                              In such cases, the extrapolation method can lead to orders of magnitude faster convergence of integration compared with no acceleration.<br>
    !>                                              When the input argument `help` is set to `wesp`, the integration routine corresponds to the [QAGI](https://netlib.org/quadpack/) and [QAGS](https://netlib.org/quadpack/) routines of QuadPack software.<br>
    !>                                              However, unlike [QAGI](https://netlib.org/quadpack/) and [QAGS](https://netlib.org/quadpack/) which use Gauss-Kronrod 7-15 and 10-21 quadrature rules respectively,
    !>                                              this generic interface allows the extrapolation and acceleration of **any** Gauss-Kronrod quadrature rule with the Epsilon method of Wynn (1961).<br>
    !>                                              See examples below for an illustration of the speedup and appropriate use cases.<br>
    !>                                      <li>    A vector of non-zero length of the same type and kind as the input `integral`, containing the points of integration difficulty within the specified integration range `(lb, ub)`.<br>
    !>                                              These points can be (integrable) singularities or discontinuities in the integrand that cannot not be modeled well by polynomials.<br>
    !>                                              Specifying the difficulty points, when they are known, can lead to significant computational speedups and convergence of the integral.<br>
    !>                                              **On input, the specified `help` points must be in ascending order.**<br>
    !>                                              If manual sorting is impossible, `help` can be sorted automatically via [setSorted](@ref pm_arraySort::setSorted) before calling this procedure.<br>
    !>                                              Additionally, all elements of `help` must be unique.<br>
    !>                                              If uniqueness is unknown at runtime, the unique elements of `help` can be automatically obtained via [getUnique](@ref pm_arrayUnique::getUnique) before calling this procedure.<br>
    !>                                              **When both the lower and upper limits of integration are infinities (\f$(\ms{lb}, \ms{ub}) = (-\infty, +\infty)\f$), the specified difficulty points in `help` cannot contain `-1`**.<br>
    !>                                              In such cases, use a simple change of variable to shift the singularity to values other than `-1`.<br>
    !>                                      <li>    A scalar constant of type [wcauchy_type](@ref pm_quadPack::wcauchy_type) implying that the Cauchy Principal Value of the input function must be computed.<br>
    !>                                              In such a case, the Cauchy singularity must be stored in the `cs` component of the input object of [wcauchy_type](@ref pm_quadPack::wcauchy_type) before calling this generic interface.<br>
    !>                                              **If the integrand has more than one Cauchy pole**, split the integration range such that each separate range contains only one Cauchy singularity.<br>
    !>                                              Then, pass each integrand separately to this generic interface and sum the results of the two integrations.<br>
    !>                                  </ol>
    !>                                  (**optional**. If missing, the procedure attempts to compute the integral without convergence-accelerating extrapolations or explicit assumptions about the singularities or discontinuities.)<br>
    !>  \param[out] integral        :   The output scalar of type `real` of kind \RKALL, containing the integral of the specified integrand `getFunc()` over the specified range `(lb, ub)`.<br>
    !>  \param[out] abserr          :   The output scalar argument of the same type and kind as `integral`, representing the estimated absolute error in the resulting integral,<br>
    !>                                  which should equal or exceed `abs(truth - integral)` where `truth` is the true value of the integral.<br>
    !>  \param[out] sinfo           :   The output `contiguous` matrix argument of the same type and kind as `integral`, of size `(1:4, 1:nintmax)` where `nintmax` is the maximum number of
    !>                                  subintervals the procedure is allowed to create to refine the computed integral.<br>
    !>                                  <ol>
    !>                                      <li>    The first  row, `sinfo(1,1:nint)`, contains the lower bound                 of each of `nint <= nintmax` final surviving subintervals formed in the integration process.
    !>                                      <li>    The second row, `sinfo(2,1:nint)`, contains the upper bound                 of each of `nint <= nintmax` final surviving subintervals formed in the integration process.
    !>                                      <li>    The third  row, `sinfo(3,1:nint)`, contains the estimated integral          of each of `nint <= nintmax` final surviving subintervals formed in the integration process.
    !>                                      <li>    The fourth row, `sinfo(4,1:nint)`, contains the estimated integral error    of each of `nint <= nintmax` final surviving subintervals formed in the integration process.
    !>                                  </ol>
    !>  \param[out] sindex          :   The output `contiguous` vector argument of type `integer` of default kind \IK of size `(1:nintmax)`, the first `k` elements of which contain pointers to the error estimates over the subintervals,<br>
    !>                                  such that `sinfo(3, sindex(1)), ..., sinfo(sindex(k))` form a decreasing sequence with `k = nint` if `nint <= (nintmax / 2 + 2)`, and `k = nintmax - nint + 1` otherwise.<br>
    !>  \param[out] neval           :   The output scalar argument of type `integer` of default kind \IK, containing the number of function calls made during the integration.<br>
    !>  \param[out] nint            :   The output scalar argument of type `integer` of default kind \IK, containing the number of final surviving subintervals formed during the integration.<br>
    !>
    !>  \return
    !>  `err`                       :   The output scalar of type `integer` of default kind \IK, that is set to zero if the integration converges without any errors.<br>
    !>                                  Otherwise, a non-zero value of `err` indicates the occurrence of an error of varying severities,
    !>                                  <ol>
    !>                                      <li>    If `err == 1`, then the maximum number of subdivisions allowed has reached.<br>
    !>                                              One can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account).<br>
    !>                                              However, if this yields no improvement, it is advised to analyze the integrand in order to determine the integration difficulties.<br>
    !>                                              If the position of a local difficulty can be determined (i.e., a singularity or discontinuity within the interval),
    !>                                              one will probably gain from splitting up the interval at this point and calling the integrator on the subranges.<br>
    !>                                              If possible, an appropriate special-purpose integrator should be used which is designed for handling the type of difficulty involved.<br>
    !>                                      <li>    If `err == 2`, then the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved.<br>
    !>                                      <li>    If `err == 3`, then an extremely bad integrand behavior occurs at some points of the integration interval.<br>
    !>                                      <li>    If `err == 4`, then the algorithm has not converged on return due to the detection of roundoff errors in the extrapolation method.<br>
    !>                                              The returned result is the best that could be obtained and is not necessarily wrong.<br>
    !>                                              In such cases, check whether the output `abserr` is satisfactory for the specific task, even though it may be larger than the requested tolerances.<br>
    !>                                              Increasing the requested absolute and relative tolerances may help convergence.<br>
    !>                                      <li>    If `err == 5`, then the algorithm has not converged.<br>
    !>                                              The integral is likely divergent, or slowly convergent.<br>
    !>                                              Note that divergence can be the underlying cause for any of the error numbers listed here.<br>
    !>                                  </ol>
    !>
    !>  \interface
    !>  \code{.F90}
    !>
    !>      use pm_quadPack, only: getQuadErr
    !>
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) ! extends QAG/QAGI routines of QuadPack.
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) ! extends QAGS/QAGI/QAWC routines of QuadPack.
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, qrule, help(:), integral, abserr, sinfo, sindex, neval, nint) ! extends QAGS/QAGI/QAGP routines of QuadPack.
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, nodeK(:), weightK(:), weightG(:), integral, abserr, sinfo, sindex, neval, nint) ! extends QAG/QAGI/QAWC routines of QuadPack.
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, nodeK(:), weightK(:), weightG(:), help, integral, abserr, sinfo, sindex, neval, nint) ! extends QAGS/QAGI routines of QuadPack.
    !>      err = getQuadErr(getFunc, lb, ub, abstol, reltol, nodeK(:), weightK(:), weightG(:), help(:), integral, abserr, sinfo, sindex, neval, nint) ! extends QAGS/QAGI/QAGP routines of QuadPack.
    !>      !
    !>  \endcode
    !>
    !>  \warning
    !>  The condition `lb < ub` must hold for the corresponding procedure argument.<br>
    !>  The condition `abstol > 0.` must hold for the corresponding procedure arguments.<br>
    !>  The condition `reltol > 0.` must hold for the corresponding procedure arguments.<br>
    !>  The condition `size(sindex) > 0_IK` must hold for the corresponding procedure arguments.<br>
    !>  The condition `size(sinfo, 1) == 4_IK` must hold for the corresponding procedure arguments.<br>
    !>  The condition `size(sinfo, 2) == size(sindex)` must hold for the corresponding procedure arguments.<br>
    !>  The condition `size(help) > 0` must hold for the corresponding procedure arguments when `help` contains a set of points of difficulties within the domain of integration.<br>
    !>  The condition `all(help > lb)` must hold for the corresponding procedure arguments when `help` contains a set of points of difficulties within the domain of integration.<br>
    !>  The condition `all(help < ub)` must hold for the corresponding procedure arguments when `help` contains a set of points of difficulties within the domain of integration.<br>
    !>  The condition `all(help /= -1.) .and. lb == ninf .and. ub == pinf` must hold for the corresponding procedure arguments when `help` contains a set of points of difficulties within the domain of integration.<br>
    !>  The element values of the input `help` must be in ascending order when `help` contains a set of points of difficulties within the domain of integration.<br>
    !>  \vericons
    !>
    !>  \warning
    !>  If the target function contains points of difficulties, singularities, or discontinuities,
    !>  user must ensure the abscissas of the specified Gauss-Kronrod rule do not match such points.<br>
    !>  Particularly, computing an integrand at its singularities can lead to undefined values that can lead
    !>  to unexpected **segmentation fault** or propagation of `NaN` values within the computational flow
    !>  or other strange errors that can be extremely difficult to debug.<br>
    !>  A simple check can be added within the target integrand implementations to ensure no such difficulty point matches an input value at which the function must be evaluated.<br>
    !>  Alternatively, one should consider using the adaptive integration routines [isFailedQuad](@ref pm_quadPack::isFailedQuad) or [getQuadErr](@ref pm_quadPack::getQuadErr)
    !>  while setting their input `help` arguments to the points of difficulties of the integrand.<br>
    !>
    !>  \impure
    !>
    !>  \note
    !>  **semi/fully-infinite intervals**<br>
    !>  If the integration range is semi or fully infinite, the recommended quadrature rule is [GK21](@ref pm_quadPack::GK21).<br>
    !>  Higher quadrature rules are also possible and available for semi/fully-infinite intervals although benefits could be minimal
    !>  due to the introduction of the singularity in the transformed finite-range integrand.<br>
    !>
    !>  \impure
    !>
    !>  \see
    !>  [getQuadGK](@ref  pm_quadPack::getQuadGK).<br>
    !>  [getQuadErr](@ref pm_quadPack::getQuadErr)<br>
    !>  [getQuadRomb](@ref pm_quadRomb::getQuadRomb)<br>
    !>  [isFailedQuad](@ref pm_quadPack::isFailedQuad).<br>
    !>
    !>  \example{getQuadErr}
    !>  \include{lineno} example/pm_quadPack/getQuadErr/main.F90
    !>  \compilef{getQuadErr}
    !>  \output{getQuadErr}
    !>  \include{lineno} example/pm_quadPack/getQuadErr/main.out.F90
    !>
    !>  \test
    !>  [test_pm_quadPack](@ref test_pm_quadPack)
    !>
    !>  \final{getQuadErr}
    !>
    !>  \author
    !>  \AmirShahmoradi, Oct 16, 2009, 11:14 AM, Michigan

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    ! QAGD_GK15

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK15_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK15_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK15_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK15_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK15_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK15_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK15_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK15_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK15_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK15_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK15_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK15_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK15_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK15_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK15_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK15_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK15_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK15_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK15_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK15_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK15_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GK21

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK21_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK21_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK21_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK21_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK21_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK21_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK21_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK21_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK21_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK21_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK21_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK21_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK21_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK21_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK21_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK21_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK21_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK21_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK21_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK21_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK21_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GK31

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK31_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK31_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK31_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK31_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK31_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK31_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK31_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK31_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK31_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK31_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK31_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK31_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK31_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK31_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK31_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK31_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK31_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK31_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK31_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK31_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK31_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GK41

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK41_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK41_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK41_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK41_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK41_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK41_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK41_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK41_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK41_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK41_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK41_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK41_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK41_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK41_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK41_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK41_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK41_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK41_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK41_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK41_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK41_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GK51

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK51_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK51_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK51_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK51_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK51_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK51_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK51_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK51_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK51_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK51_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK51_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK51_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK51_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK51_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK51_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK51_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK51_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK51_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK51_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK51_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK51_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GK61

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK61_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK61_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK61_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK61_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK61_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK61_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK61_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK61_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK61_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK61_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK61_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK61_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK61_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK61_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK61_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GK61_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GK61_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GK61_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GK61_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GK61_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GK61_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGD_GKXX

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GKXX_FF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GKXX_FF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GKXX_FF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GKXX_FF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GKXX_FF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GKXX_FI_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GKXX_FI_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GKXX_FI_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GKXX_FI_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GKXX_FI_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GKXX_IF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GKXX_IF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GKXX_IF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GKXX_IF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GKXX_IF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGD_GKXX_II_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGD_GKXX_II_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGD_GKXX_II_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGD_GKXX_II_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGD_GKXX_II_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGD_GKXX_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    ! QAGS_GK15

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK15_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK15_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK15_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK15_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK15_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK15_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK15_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK15_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK15_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK15_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK15_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK15_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK15_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK15_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK15_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK15_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK15_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK15_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK15_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK15_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK15_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GK21

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK21_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK21_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK21_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK21_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK21_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK21_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK21_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK21_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK21_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK21_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK21_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK21_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK21_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK21_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK21_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK21_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK21_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK21_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK21_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK21_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK21_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GK31

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK31_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK31_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK31_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK31_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK31_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK31_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK31_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK31_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK31_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK31_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK31_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK31_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK31_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK31_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK31_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK31_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK31_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK31_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK31_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK31_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK31_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GK41

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK41_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK41_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK41_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK41_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK41_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK41_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK41_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK41_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK41_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK41_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK41_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK41_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK41_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK41_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK41_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK41_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK41_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK41_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK41_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK41_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK41_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GK51

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK51_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK51_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK51_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK51_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK51_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK51_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK51_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK51_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK51_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK51_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK51_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK51_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK51_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK51_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK51_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK51_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK51_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK51_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK51_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK51_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK51_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GK61

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK61_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK61_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK61_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK61_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK61_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK61_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK61_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK61_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK61_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK61_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK61_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK61_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK61_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK61_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK61_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GK61_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GK61_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GK61_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GK61_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GK61_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GK61_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGS_GKXX

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GKXX_FF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GKXX_FF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GKXX_FF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GKXX_FF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GKXX_FF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GKXX_FI_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GKXX_FI_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GKXX_FI_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GKXX_FI_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GKXX_FI_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GKXX_IF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GKXX_IF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GKXX_IF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GKXX_IF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GKXX_IF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGS_GKXX_II_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGS_GKXX_II_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGS_GKXX_II_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGS_GKXX_II_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGS_GKXX_II_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGS_GKXX_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(weps_type)     , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    ! QAGP_GK15

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK15_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK15_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK15_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK15_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK15_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK15_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK15_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK15_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK15_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK15_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK15_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK15_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK15_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK15_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK15_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK15_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK15_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK15_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK15_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK15_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK15_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GK21

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK21_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK21_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK21_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK21_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK21_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK21_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK21_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK21_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK21_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK21_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK21_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK21_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK21_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK21_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK21_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK21_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK21_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK21_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK21_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK21_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK21_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GK31

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK31_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK31_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK31_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK31_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK31_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK31_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK31_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK31_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK31_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK31_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK31_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK31_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK31_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK31_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK31_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK31_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK31_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK31_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK31_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK31_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK31_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GK41

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK41_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK41_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK41_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK41_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK41_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK41_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK41_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK41_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK41_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK41_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK41_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK41_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK41_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK41_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK41_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK41_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK41_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK41_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK41_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK41_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK41_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GK51

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK51_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK51_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK51_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK51_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK51_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK51_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK51_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK51_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK51_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK51_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK51_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK51_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK51_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK51_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK51_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK51_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK51_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK51_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK51_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK51_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK51_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GK61

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK61_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK61_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK61_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK61_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK61_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK61_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK61_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK61_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK61_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK61_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK61_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK61_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK61_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK61_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK61_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GK61_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GK61_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GK61_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GK61_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GK61_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GK61_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAGP_GKXX

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GKXX_FF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GKXX_FF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GKXX_FF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GKXX_FF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GKXX_FF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GKXX_FI_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GKXX_FI_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GKXX_FI_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GKXX_FI_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GKXX_FI_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GKXX_IF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GKXX_IF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GKXX_IF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GKXX_IF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GKXX_IF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAGP_GKXX_II_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAGP_GKXX_II_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAGP_GKXX_II_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAGP_GKXX_II_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAGP_GKXX_II_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAGP_GKXX_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        real(RKG)           , intent(in)    , contiguous    :: help(:)
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    ! QAWC FF

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK15_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK15_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK15_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK15_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK15_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK21_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK21_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK21_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK21_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK21_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK31_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK31_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK31_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK31_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK31_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK41_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK41_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK41_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK41_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK41_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK51_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK51_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK51_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK51_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK51_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK61_FF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK61_FF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK61_FF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK61_FF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK61_FF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GKXX_FF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GKXX_FF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GKXX_FF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GKXX_FF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GKXX_FF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAWC FI

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK15_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK15_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK15_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK15_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK15_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK21_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK21_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK21_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK21_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK21_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK31_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK31_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK31_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK31_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK31_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK41_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK41_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK41_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK41_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK41_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK51_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK51_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK51_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK51_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK51_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK61_FI_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK61_FI_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK61_FI_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK61_FI_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK61_FI_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GKXX_FI_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FI_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GKXX_FI_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FI_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GKXX_FI_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FI_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GKXX_FI_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FI_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GKXX_FI_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_FI_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        real(RKG)           , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAWC IF

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK15_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK15_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK15_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK15_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK15_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK21_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK21_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK21_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK21_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK21_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK31_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK31_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK31_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK31_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK31_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK41_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK41_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK41_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK41_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK41_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK51_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK51_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK51_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK51_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK51_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK61_IF_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK61_IF_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK61_IF_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK61_IF_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK61_IF_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GKXX_IF_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_IF_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GKXX_IF_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_IF_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GKXX_IF_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_IF_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GKXX_IF_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_IF_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GKXX_IF_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_IF_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        real(RKG)           , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

    ! QAWC II

    interface getQuadErr

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK15_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK15_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK15_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK15_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK15_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK15_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK15_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK21_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK21_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK21_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK21_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK21_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK21_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK21_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK31_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK31_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK31_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK31_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK31_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK31_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK31_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK41_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK41_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK41_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK41_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK41_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK41_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK41_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK51_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK51_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK51_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK51_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK51_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK51_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK51_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GK61_II_RK5(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GK61_II_RK4(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GK61_II_RK3(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GK61_II_RK2(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GK61_II_RK1(getFunc, lb, ub, abstol, reltol, qrule, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GK61_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        type(GK61_type)     , intent(in)                    :: qrule
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#if RK5_ENABLED
    module function QAWC_GKXX_II_RK5(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_II_RK5
#endif
        use pm_kind, only: RKG => RK5
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK4_ENABLED
    module function QAWC_GKXX_II_RK4(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_II_RK4
#endif
        use pm_kind, only: RKG => RK4
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK3_ENABLED
    module function QAWC_GKXX_II_RK3(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_II_RK3
#endif
        use pm_kind, only: RKG => RK3
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK2_ENABLED
    module function QAWC_GKXX_II_RK2(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_II_RK2
#endif
        use pm_kind, only: RKG => RK2
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

#if RK1_ENABLED
    module function QAWC_GKXX_II_RK1(getFunc, lb, ub, abstol, reltol, nodeK, weightK, weightG, help, integral, abserr, sinfo, sindex, neval, nint) result(err)
#if __INTEL_COMPILER && DLL_ENABLED && (_WIN32 || _WIN64)
        !DEC$ ATTRIBUTES DLLEXPORT :: QAWC_GKXX_II_RK1
#endif
        use pm_kind, only: RKG => RK1
        procedure(real(RKG))                                :: getFunc
        type(ninf_type)     , intent(in)                    :: lb
        type(pinf_type)     , intent(in)                    :: ub
        real(RKG)           , intent(in)                    :: abstol
        real(RKG)           , intent(in)                    :: reltol
        real(RKG)           , intent(in)    , contiguous    :: nodeK(:), weightK(:), weightG(:)
        type(wcauchy_type)  , intent(in)                    :: help
        real(RKG)           , intent(out)                   :: integral, abserr
        real(RKG)           , intent(out)   , contiguous    :: sinfo(:,:)
        integer(IK)         , intent(out)   , contiguous    :: sindex(:)
        integer(IK)         , intent(out)                   :: neval
        integer(IK)         , intent(out)                   :: nint
        integer(IK)                                         :: err
    end function
#endif

    !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end interface

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end module pm_quadPack