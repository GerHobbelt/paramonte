%>  \brief
%>  This is the base class for generating instances of objects that contains
%>  layout information for a set of tiled subplots in a single figure.<br>
%>
%>  \details
%>  For more information, see the documentation of the class constructor
%>  [pm.vis.TilingLayout::TilingLayout](@ref TilingLayout::TilingLayout).<br>
%>
%>  \note
%>  This class is not meant to be used directly by the end users.<br>
%>  Instead, use other classes that internally use this class as a component.<br>
%>
%>  \note
%>  See the list of class attributes below,
%>  also those of the superclass [pm.matlab.Handle](@ref Handle).<br>
%>
%>  \note
%>  The tiling layout generated by this class is different from new MATLAB ``tiledlayout``.<br>
%>  Specifically, this class aims to mimic the layout originally devised the first version of ParaMonte MATLAB library release.<br>
%>  This ParaMonte tiling layout is, for example, used in making corner plots (formerly known as ``GridPlot`` in ParaMonte V1).<br>
%>
%>  \final
%>
%>  \author
%>  \AmirShahmoradi, August 31 2024, 6:40 AM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
classdef TilingLayout < pm.matlab.Handle

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    properties(Access = public)
        %>
        %>  ``position``
        %>
        %>  The MATLAB vector of length four containing a set of positive values
        %>  representing the figure pixel coordinates as ``[startx, starty, width, height]`` with respect to the screen.<br>
        %>  The default value is set such that the whole tiling looks square-shaped.<br>
        %>
        position = [];
        %>
        %>  ``tiling``
        %>
        %>  The scalar MATLAB ``struct`` containing the following components:<br>
        %>  <ol>
        %>      <li>    ``nrow``        :   The MATLAB scalar positive whole-number
        %>                                  representing the number of subplots in each column of the subplot tiling.<br>
        %>      <li>    ``ncol``        :   The MATLAB scalar positive whole-number
        %>                                  representing the number of subplots in each row of the subplot tiling.<br>
        %>      <li>    ``tile``        :   The scalar MATLAB ``struct`` containing the following components:<br>
        %>                                  <ol>
        %>                                      <li>    ``width``       :   The MATLAB scalar positive number in the range ``[0, 1]``,
        %>                                                                  containing the width of each tile (subplot) along the x-axis
        %>                                                                  in normalized units **with respect to the tiling width**.<br>
        %>                                                                  The default value is ``14 / 15``.<br>
        %>                                      <li>    ``height``      :   The MATLAB scalar positive number in the range ``[0, 1]``,
        %>                                                                  containing the height of each tile (subplot) along the x-axis in normalized units.<br>
        %>                                                                  in normalized units **with respect to the tiling height**.<br>
        %>                                                                  The default value is ``14 / 15``.<br>
        %>                                      <li>    ``position``    :   The MATLAB tensor of shape ``[4, nrow, ncol]``, each ``[:, irow, icol]``
        %>                                                                  slice of which contains a set of positive normalized values in the range ``[0, 1]``,
        %>                                                                  representing the position of the tile sitting at ``[irow, icol]`` starting from
        %>                                                                  the top-left corner of the tiling.<br>
        %>                                                                  The positions are computed **with respect to the figure container**.<br>
        %>                                                                  The position values are calculated based on the tiling position.<br>
        %>                                                                  **Beware that this component is always set by the ``update()`` method.**<br>
        %>                                  </ol>
        %>      <li>    ``position``    :   The MATLAB vector of length four containing
        %>                                  a set of positive normalized values in the range ``[0, 1]``,
        %>                                  representing the whole tiling coordinates as ``[startx, starty, width, height]``.<br>
        %>                                  The default value is ``[0.07, 0.07, 0.93, 0.93]``.<br>
        %>  </ol>
        %>
        tiling = struct();
        %>
        %>  ``cbarh``
        %>
        %>  The MATLAB ``struct`` containing information about the **horizontal colorbar**
        %>  that can be optionally added to the main axes (i.e., the collection of all axes).<br>
        %>  It has the following components:<br>
        %>
        %>  <ol>
        %>      <li>    ``position``    :   The MATLAB vector of length four containing
        %>                                  a set of positive normalized values in the range ``[0, 1]``,
        %>                                  representing the whole colorbar coordinates as ``[startx, starty, width, height]``.<br>
        %>                                  The default value is set such that the colorbar sits reasonably at the top of the tiling.<br>
        %>      <li>    ``margint``     :   The MATLAB scalar positive ``double`` in the range ``[0, 1]``,
        %>                                  representing the top margin of the horizontal colorbar that appears on top of the tiling.<br>
        %>                                  This margin adds room for adding the colorbar axes label and tick marks.<br>
        %>                                  The default value is ``0.07``.<br>
        %>      <li>    ``enabled``     :   The MATLAB ``logical`` scalar that allows addition of the colorbar if ``true``.<br>
        %>                                  The default value is ``false``.<br>
        %>  </ol>
        %>
        cbarh = struct();
        %>
        %>  ``cbarh``
        %>
        %>  The MATLAB ``struct`` containing information about the **horizontal colorbar**
        %>  that can be optionally added to the main axes (i.e., the collection of all axes).<br>
        %>  It has the following components:<br>
        %>
        %>  <ol>
        %>      <li>    ``position``    :   The MATLAB vector of length four containing
        %>                                  a set of positive normalized values in the range ``[0, 1]``,
        %>                                  representing the whole colorbar coordinates as ``[startx, starty, width, height]``.<br>
        %>                                  The default value is set such that the colorbar sits reasonably at the top of the tiling.<br>
        %>      <li>    ``marginr``     :   The MATLAB scalar positive ``double`` in the range ``[0, 1]``,
        %>                                  representing the top margin of the vertical colorbar that appears to the right of the tiling.<br>
        %>                                  This margin adds room for adding the colorbar axes label and tick marks.<br>
        %>                                  The default value is ``0.07``.<br>
        %>      <li>    ``enabled``     :   The MATLAB ``logical`` scalar that allows addition of the colorbar if ``true``.<br>
        %>                                  The default value is ``false``.<br>
        %>  </ol>
        %>
        cbarv = struct();
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    methods(Access = public)

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %>  \brief
        %>  Construct and return an object of class [pm.vis.TilingLayout](@ref TilingLayout).<br>
        %>
        %>  \details
        %>  This is the constructor of the class [pm.vis.TilingLayout](@ref TilingLayout).<br>
        %>
        %>  \param[in]  nrow        :   The input scalar MATLAB positive whole-number, containing the number of rows of axes in the tiling.<br>
        %>  \param[in]  ncol        :   The input scalar MATLAB positive whole-number, containing the number of columns of axes in the tiling.<br>
        %>  \param[in]  varargin    :   Any ``property, value`` pair of the parent object.<br>
        %>                              If the property is a ``struct()``, then its value must be given as a cell array,
        %>                              with consecutive elements representing the struct ``property-name, property-value`` pairs.<br>
        %>                              Note that all of these property-value pairs can be also directly set via the
        %>                              parent object attributes, before calling the ``make()`` method.<br>
        %>
        %>  \return
        %>  ``self``                :   The output scalar object of class [pm.vis.TilingLayout](@ref TilingLayout).<br>
        %>
        %>  \interface{TilingLayout}
        %>  \code{.m}
        %>
        %>      g = pm.vis.TilingLayout([], [], varargin);
        %>      g = pm.vis.TilingLayout([], ncol, upper, varargin);
        %>      g = pm.vis.TilingLayout(nrow, [], upper, varargin);
        %>      g = pm.vis.TilingLayout(nrow, ncol, upper, varargin);
        %>
        %>  \endcode
        %>
        %>  \example{TilingLayout}
        %>  \include{lineno} example/vis/TilingLayout/main.m
        %>  \vis{TilingLayout}
        %>  \image html example/vis/TilingLayout/TilingLayout.1.png width=700
        %>
        %>  \final{TilingLayout}
        %>
        %>  \author
        %>  \AmirShahmoradi, August 31 2024, 6:40 AM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
        function self = TilingLayout(nrow, ncol, varargin)
            self.tiling.nrow = nrow;
            self.tiling.ncol = ncol;
            self.reset(varargin{:});
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %>  \brief
        %>  Reset the properties of the figure to the original default settings.<br>
        %>
        %>  \details
        %>  Use this method when you change many attributes of the plot and
        %>  you want to clean up and go back to the default settings.<br>
        %>
        %>  \param[in]  self        :   The **implicitly-passed** input argument representing the parent object of the method.<br>
        %>  \param[in]  varargin    :   Any ``property, value`` pair of the parent object.<br>
        %>                              If the property is a ``struct()``, then its value must be given as a cell array,
        %>                              with consecutive elements representing the struct ``property-name, property-value`` pairs.<br>
        %>                              Note that all of these property-value pairs can be also directly set via the
        %>                              parent object attributes, before calling the ``make()`` method.<br>
        %>
        %>  \interface{reset}
        %>  \code{.m}
        %>
        %>      g = pm.vis.TilingLayout(varargin)
        %>      g.reset(varargin); % reset all object properties to the default settings.
        %>
        %>  \endcode
        %>
        %>  \final{reset}
        %>
        %>  \author
        %>  \FatemehBagheri, May 20 2024, 1:25 PM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
        %>  \AmirShahmoradi, July 7 2024, 12:53 AM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
        function reset(self, varargin)
            self.tiling.tile = struct();
            self.position = nan * zeros(4, 1);
            self.tiling.position = nan * zeros(4, 1);
            self.tiling.tile.position = nan * zeros(4, self.tiling.nrow, self.tiling.ncol);
            self.tiling.tile.height = [];
            self.tiling.tile.width = [];
            self.tiling.height = [];
            self.tiling.width = [];
            self.cbarh.margint = [];
            self.cbarv.marginr = [];
            for cbar = ["cbarh", "cbarv"]
                self.(cbar).enabled = [];
                self.(cbar).position = [];
            end
            self.update(varargin{:});
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %>  \brief
        %>  Update the figure, tiling, and colorbar layout based on the specified components positions.<br>
        %>
        %>  \details
        %>  For example, change the tiling or colorbar positions or the tile counts through the relevant object components,
        %>  then use this method to renormalize all positions (to range ``[0, 1]``) and update the individual tile positions.<br>
        %>
        %>  \param[in]  self        :   The **implicitly-passed** input argument representing the parent object of the method.<br>
        %>  \param[in]  varargin    :   Any ``property, value`` pair of the parent object.<br>
        %>                              If the property is a ``struct()``, then its value must be given as a cell array,
        %>                              with consecutive elements representing the struct ``property-name, property-value`` pairs.<br>
        %>                              Note that all of these property-value pairs can be also directly set via the
        %>                              parent object attributes, before calling the ``make()`` method.<br>
        %>
        %>  \interface{update}
        %>  \code{.m}
        %>
        %>      g = pm.vis.TilingLayout(subplot, varargin);
        %>      g.update(varargin);
        %>
        %>  \endcode
        %>
        %>  \warning
        %>  This method causes side-effects by manipulating
        %>  the existing attributes of the object.<br>
        %>
        %>  \example{update}
        %>
        %>  \final{update}
        %>
        %>  \author
        %>  \FatemehBagheri, May 20 2024, 1:25 PM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
        %>  \AmirShahmoradi, July 7 2024, 12:53 AM, NASA Goddard Space Flight Center (GSFC), Washington, D.C.<br>
        function update(self, varargin)

            %%%%
            %%%% parse optional arguments.
            %%%%

            if ~isempty(varargin)
                self.hash2comp(varargin);
            end

            %%%%
            %%%% parse optional arguments.
            %%%%

            for cbar = ["cbarh", "cbarv"]
                if  isempty(self.(cbar).enabled)
                    self.(cbar).enabled = false;
                end
            end

            %%%%
            %%%% Setup default tiling dimensions.
            %%%%

            self.setKeyVal("tiling", "nrow", 1);
            self.setKeyVal("tiling", "ncol", 1);
            self.setKeyVal("tiling", "tile", "width", 14 / 15);
            self.setKeyVal("tiling", "tile", "height", 14 / 15);

            %%%%
            %%%% Setup tiling position.
            %%%%

            if isnan(self.tiling.position(1)); self.tiling.position(1) = 0.07; end
            if isnan(self.tiling.position(2)); self.tiling.position(2) = 0.07; end
            if isnan(self.tiling.position(3)); self.tiling.position(3) = 1 - self.tiling.position(1); end
            if isnan(self.tiling.position(4)); self.tiling.position(4) = 1 - self.tiling.position(2); end

            %%%%
            %%%% vertical colorbar specs.
            %%%%

            def = [ self.tiling.position(1) + self.tiling.position(3) ...
                  , self.tiling.position(2) ...
                  , 0.03 ...
                  , self.tiling.position(4) - (1 - self.tiling.tile.height) ...
                  ];
            if  isempty(self.cbarv.position)
                self.cbarv.position = def;
            else
                for i = 1 : length(self.cbarv.position)
                    if  isnan(self.cbarv.position(i))
                        self.cbarv.position(i) = def(i);
                    end
                end
            end
            if  isempty(self.cbarv.marginr) || isnan(self.cbarv.marginr)
                self.cbarv.marginr = 0.07;
            end

            %%%%
            %%%% horizontal colorbar specs.
            %%%%

            def = [ self.tiling.position(1) ...
                  , self.tiling.position(2) + self.tiling.position(4) ...
                  , self.tiling.position(3) - (1 - self.tiling.tile.width) ...
                  , 0.03 ...
                  ];
            if  isempty(self.cbarh.position)
                self.cbarh.position = def;
            else
                for i = 1 : length(self.cbarh.position)
                    if  isnan(self.cbarh.position(i))
                        self.cbarh.position(i) = def(i);
                    end
                end
            end
            if  isempty(self.cbarh.margint) || isnan(self.cbarh.margint)
                self.cbarh.margint = 0.07;
            end

            normfac = struct("cbarv", 1, "cbarh", 1, "width", 1, "height", 1);

            %%%%
            %%%% Renormalize positions if colorbars are activated.
            %%%%

            if  self.cbarv.enabled
                normfac.cbarv = 1 / (self.cbarv.position(1) + self.cbarv.position(3) + self.cbarv.marginr); % last term adds a right margin.
                self.tiling.position(1) = self.tiling.position(1) * normfac.cbarv;
                self.tiling.position(3) = self.tiling.position(3) * normfac.cbarv;
                self.cbarv.position(1) = self.cbarv.position(1) * normfac.cbarv;
                self.cbarv.position(3) = self.cbarv.position(3) * normfac.cbarv;
                self.cbarh.position(1) = self.cbarh.position(1) * normfac.cbarv;
                self.cbarh.position(3) = self.cbarh.position(3) * normfac.cbarv;
            end

            if  self.cbarh.enabled
                normfac.cbarh = 1 / (self.cbarh.position(2) + self.cbarh.position(4) + self.cbarh.margint); % last term adds a right margin.
                self.tiling.position(2) = self.tiling.position(2) * normfac.cbarh;
                self.tiling.position(4) = self.tiling.position(4) * normfac.cbarh;
                self.cbarh.position(2) = self.cbarh.position(2) * normfac.cbarh;
                self.cbarh.position(4) = self.cbarh.position(4) * normfac.cbarh;
                self.cbarv.position(2) = self.cbarv.position(2) * normfac.cbarh;
                self.cbarv.position(4) = self.cbarv.position(4) * normfac.cbarh;
            end

            %%%%
            %%%% Set the tile positions.
            %%%%

            self.tiling.tile.position = zeros(4, self.tiling.nrow, self.tiling.ncol);
            tile_height_wrt_fig = self.tiling.position(4) / self.tiling.nrow;
            tile_width_wrt_fig = self.tiling.position(3) / self.tiling.ncol;
            for icol = 1 : self.tiling.ncol
                for irow = 1 : self.tiling.nrow
                    jrow = self.tiling.nrow - irow + 1;
                    self.tiling.tile.position(:, irow, icol) =  [ self.tiling.position(1) + (icol - 1) * tile_width_wrt_fig ...
                                                                , self.tiling.position(2) + (jrow - 1) * tile_height_wrt_fig ...
                                                                , self.tiling.tile.width * tile_width_wrt_fig ...
                                                                , self.tiling.tile.height * tile_height_wrt_fig ...
                                                                ];
                end
            end

            %%%%
            %%%% Add the missing margin lengths to the colorbar axes.
            %%%%
            if  self.cbarv.enabled
                self.cbarv.position(4) = self.tiling.position(4) - (1 - self.tiling.tile.height) * tile_height_wrt_fig;
            end
            if  self.cbarh.enabled
                self.cbarh.position(3) = self.tiling.position(3) - (1 - self.tiling.tile.width) * tile_width_wrt_fig;
            end

            %%%%
            %%%% Set the figure position.
            %%%%

            if  isempty(self.position) || any(isnan(self.position))
                fig = struct();
                self.position = get(0, 'ScreenSize');
                fig.center = [mean(self.position([1, 3])), mean(self.position([2, 4]))];
                fig.length = min(self.position(3 : 4)) * .8; % The fraction accounts for padding.
                if ~self.cbarh.enabled && self.cbarv.enabled
                    normfac.height = normfac.cbarv;
                end
                if ~self.cbarv.enabled && self.cbarh.enabled
                    normfac.width = normfac.cbarh;
                end
                fig.width = fig.length * normfac.width;
                fig.height = fig.length * normfac.height;
                self.position = [ fig.center(1) - 0.5 * fig.width ...
                                , fig.center(2) - 0.5 * fig.height ...
                                , fig.width ...
                                , fig.height ...
                                ];
            end

        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end